// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef MATML31_HXX
#define MATML31_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class Associate;
class AssociationDetails;
class BulkDetails;
class Characterization;
class ChemicalComposition;
class Class;
class ComponentDetails;
class Compound;
class Concentration;
class DataFormat;
class DimensionalDetails;
class Element;
class Form;
class Formula;
class Geometry;
class Glossary;
class GlossaryTerm;
class Graphs;
class Material;
class Metadata;
class Name;
class Notes;
class ParameterValue;
class PhaseComposition;
class ProcessingDetails;
class PropertyData;
class Qualifier;
class Relationship;
class Source;
class Specification;
class Uncertainty;
class Unit;
class Unitless;
class Units;
class Value;
class AuthorityDetails;
class DataSourceDetails;
class MeasurementTechniqueDetails;
class ParameterDetails;
class PropertyDetails;
class SourceDetails;
class SpecimenDetails;
class TestConditionDetails;
class ChemicalElementSymbol;
class CurrencyCode;
class MatML_Doc;
class ParentMaterial;
class Symbol;
class Graph;
class Data;
class Data1;
class delimiter;
class Scale;

#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class Associate: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  Associate ();

  Associate (const char*);

  Associate (const ::std::string&);

  Associate (const ::xml_schema::string&);

  Associate (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  Associate (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  Associate (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  Associate (const Associate& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual Associate*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Associate ();
};

class AssociationDetails: public ::xml_schema::type
{
  public:
  // Associate
  //
  typedef ::Associate Associate_type;
  typedef ::xsd::cxx::tree::optional< Associate_type > Associate_optional;
  typedef ::xsd::cxx::tree::traits< Associate_type, char > Associate_traits;

  const Associate_optional&
  Associate () const;

  Associate_optional&
  Associate ();

  void
  Associate (const Associate_type& x);

  void
  Associate (const Associate_optional& x);

  void
  Associate (::std::auto_ptr< Associate_type > p);

  // Relationship
  //
  typedef ::Relationship Relationship_type;
  typedef ::xsd::cxx::tree::optional< Relationship_type > Relationship_optional;
  typedef ::xsd::cxx::tree::traits< Relationship_type, char > Relationship_traits;

  const Relationship_optional&
  Relationship () const;

  Relationship_optional&
  Relationship ();

  void
  Relationship (const Relationship_type& x);

  void
  Relationship (const Relationship_optional& x);

  void
  Relationship (::std::auto_ptr< Relationship_type > p);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // Constructors.
  //
  AssociationDetails ();

  AssociationDetails (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  AssociationDetails (const AssociationDetails& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual AssociationDetails*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  AssociationDetails&
  operator= (const AssociationDetails& x);

  virtual 
  ~AssociationDetails ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Associate_optional Associate_;
  Relationship_optional Relationship_;
  Notes_optional Notes_;
};

class BulkDetails: public ::xml_schema::type
{
  public:
  // Name
  //
  typedef ::Name Name_type;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_type&
  Name () const;

  Name_type&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // Class
  //
  typedef ::Class Class_type;
  typedef ::xsd::cxx::tree::sequence< Class_type > Class_sequence;
  typedef Class_sequence::iterator Class_iterator;
  typedef Class_sequence::const_iterator Class_const_iterator;
  typedef ::xsd::cxx::tree::traits< Class_type, char > Class_traits;

  const Class_sequence&
  Class () const;

  Class_sequence&
  Class ();

  void
  Class (const Class_sequence& s);

  // Subclass
  //
  typedef ::Class Subclass_type;
  typedef ::xsd::cxx::tree::sequence< Subclass_type > Subclass_sequence;
  typedef Subclass_sequence::iterator Subclass_iterator;
  typedef Subclass_sequence::const_iterator Subclass_const_iterator;
  typedef ::xsd::cxx::tree::traits< Subclass_type, char > Subclass_traits;

  const Subclass_sequence&
  Subclass () const;

  Subclass_sequence&
  Subclass ();

  void
  Subclass (const Subclass_sequence& s);

  // Specification
  //
  typedef ::Specification Specification_type;
  typedef ::xsd::cxx::tree::sequence< Specification_type > Specification_sequence;
  typedef Specification_sequence::iterator Specification_iterator;
  typedef Specification_sequence::const_iterator Specification_const_iterator;
  typedef ::xsd::cxx::tree::traits< Specification_type, char > Specification_traits;

  const Specification_sequence&
  Specification () const;

  Specification_sequence&
  Specification ();

  void
  Specification (const Specification_sequence& s);

  // Source
  //
  typedef ::Source Source_type;
  typedef ::xsd::cxx::tree::optional< Source_type > Source_optional;
  typedef ::xsd::cxx::tree::traits< Source_type, char > Source_traits;

  const Source_optional&
  Source () const;

  Source_optional&
  Source ();

  void
  Source (const Source_type& x);

  void
  Source (const Source_optional& x);

  void
  Source (::std::auto_ptr< Source_type > p);

  // Form
  //
  typedef ::Form Form_type;
  typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
  typedef ::xsd::cxx::tree::traits< Form_type, char > Form_traits;

  const Form_optional&
  Form () const;

  Form_optional&
  Form ();

  void
  Form (const Form_type& x);

  void
  Form (const Form_optional& x);

  void
  Form (::std::auto_ptr< Form_type > p);

  // ProcessingDetails
  //
  typedef ::ProcessingDetails ProcessingDetails_type;
  typedef ::xsd::cxx::tree::sequence< ProcessingDetails_type > ProcessingDetails_sequence;
  typedef ProcessingDetails_sequence::iterator ProcessingDetails_iterator;
  typedef ProcessingDetails_sequence::const_iterator ProcessingDetails_const_iterator;
  typedef ::xsd::cxx::tree::traits< ProcessingDetails_type, char > ProcessingDetails_traits;

  const ProcessingDetails_sequence&
  ProcessingDetails () const;

  ProcessingDetails_sequence&
  ProcessingDetails ();

  void
  ProcessingDetails (const ProcessingDetails_sequence& s);

  // Characterization
  //
  typedef ::Characterization Characterization_type;
  typedef ::xsd::cxx::tree::optional< Characterization_type > Characterization_optional;
  typedef ::xsd::cxx::tree::traits< Characterization_type, char > Characterization_traits;

  const Characterization_optional&
  Characterization () const;

  Characterization_optional&
  Characterization ();

  void
  Characterization (const Characterization_type& x);

  void
  Characterization (const Characterization_optional& x);

  void
  Characterization (::std::auto_ptr< Characterization_type > p);

  // PropertyData
  //
  typedef ::PropertyData PropertyData_type;
  typedef ::xsd::cxx::tree::sequence< PropertyData_type > PropertyData_sequence;
  typedef PropertyData_sequence::iterator PropertyData_iterator;
  typedef PropertyData_sequence::const_iterator PropertyData_const_iterator;
  typedef ::xsd::cxx::tree::traits< PropertyData_type, char > PropertyData_traits;

  const PropertyData_sequence&
  PropertyData () const;

  PropertyData_sequence&
  PropertyData ();

  void
  PropertyData (const PropertyData_sequence& s);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // Constructors.
  //
  BulkDetails (const Name_type&);

  BulkDetails (::std::auto_ptr< Name_type >);

  BulkDetails (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  BulkDetails (const BulkDetails& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual BulkDetails*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  BulkDetails&
  operator= (const BulkDetails& x);

  virtual 
  ~BulkDetails ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Name_type > Name_;
  Class_sequence Class_;
  Subclass_sequence Subclass_;
  Specification_sequence Specification_;
  Source_optional Source_;
  Form_optional Form_;
  ProcessingDetails_sequence ProcessingDetails_;
  Characterization_optional Characterization_;
  PropertyData_sequence PropertyData_;
  Notes_optional Notes_;
};

class Characterization: public ::xml_schema::type
{
  public:
  // Formula
  //
  typedef ::Formula Formula_type;
  typedef ::xsd::cxx::tree::traits< Formula_type, char > Formula_traits;

  const Formula_type&
  Formula () const;

  Formula_type&
  Formula ();

  void
  Formula (const Formula_type& x);

  void
  Formula (::std::auto_ptr< Formula_type > p);

  // ChemicalComposition
  //
  typedef ::ChemicalComposition ChemicalComposition_type;
  typedef ::xsd::cxx::tree::optional< ChemicalComposition_type > ChemicalComposition_optional;
  typedef ::xsd::cxx::tree::traits< ChemicalComposition_type, char > ChemicalComposition_traits;

  const ChemicalComposition_optional&
  ChemicalComposition () const;

  ChemicalComposition_optional&
  ChemicalComposition ();

  void
  ChemicalComposition (const ChemicalComposition_type& x);

  void
  ChemicalComposition (const ChemicalComposition_optional& x);

  void
  ChemicalComposition (::std::auto_ptr< ChemicalComposition_type > p);

  // PhaseComposition
  //
  typedef ::PhaseComposition PhaseComposition_type;
  typedef ::xsd::cxx::tree::sequence< PhaseComposition_type > PhaseComposition_sequence;
  typedef PhaseComposition_sequence::iterator PhaseComposition_iterator;
  typedef PhaseComposition_sequence::const_iterator PhaseComposition_const_iterator;
  typedef ::xsd::cxx::tree::traits< PhaseComposition_type, char > PhaseComposition_traits;

  const PhaseComposition_sequence&
  PhaseComposition () const;

  PhaseComposition_sequence&
  PhaseComposition ();

  void
  PhaseComposition (const PhaseComposition_sequence& s);

  // DimensionalDetails
  //
  typedef ::DimensionalDetails DimensionalDetails_type;
  typedef ::xsd::cxx::tree::sequence< DimensionalDetails_type > DimensionalDetails_sequence;
  typedef DimensionalDetails_sequence::iterator DimensionalDetails_iterator;
  typedef DimensionalDetails_sequence::const_iterator DimensionalDetails_const_iterator;
  typedef ::xsd::cxx::tree::traits< DimensionalDetails_type, char > DimensionalDetails_traits;

  const DimensionalDetails_sequence&
  DimensionalDetails () const;

  DimensionalDetails_sequence&
  DimensionalDetails ();

  void
  DimensionalDetails (const DimensionalDetails_sequence& s);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // Constructors.
  //
  Characterization (const Formula_type&);

  Characterization (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  Characterization (const Characterization& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual Characterization*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Characterization&
  operator= (const Characterization& x);

  virtual 
  ~Characterization ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Formula_type > Formula_;
  ChemicalComposition_optional ChemicalComposition_;
  PhaseComposition_sequence PhaseComposition_;
  DimensionalDetails_sequence DimensionalDetails_;
  Notes_optional Notes_;
};

class ChemicalComposition: public ::xml_schema::type
{
  public:
  // Compound
  //
  typedef ::Compound Compound_type;
  typedef ::xsd::cxx::tree::sequence< Compound_type > Compound_sequence;
  typedef Compound_sequence::iterator Compound_iterator;
  typedef Compound_sequence::const_iterator Compound_const_iterator;
  typedef ::xsd::cxx::tree::traits< Compound_type, char > Compound_traits;

  const Compound_sequence&
  Compound () const;

  Compound_sequence&
  Compound ();

  void
  Compound (const Compound_sequence& s);

  // Element
  //
  typedef ::Element Element_type;
  typedef ::xsd::cxx::tree::sequence< Element_type > Element_sequence;
  typedef Element_sequence::iterator Element_iterator;
  typedef Element_sequence::const_iterator Element_const_iterator;
  typedef ::xsd::cxx::tree::traits< Element_type, char > Element_traits;

  const Element_sequence&
  Element () const;

  Element_sequence&
  Element ();

  void
  Element (const Element_sequence& s);

  // Constructors.
  //
  ChemicalComposition ();

  ChemicalComposition (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  ChemicalComposition (const ChemicalComposition& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual ChemicalComposition*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ChemicalComposition&
  operator= (const ChemicalComposition& x);

  virtual 
  ~ChemicalComposition ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Compound_sequence Compound_;
  Element_sequence Element_;
};

class Class: public ::xml_schema::type
{
  public:
  // Name
  //
  typedef ::Name Name_type;
  typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_optional&
  Name () const;

  Name_optional&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (const Name_optional& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // ParentMaterial
  //
  typedef ::ParentMaterial ParentMaterial_type;
  typedef ::xsd::cxx::tree::sequence< ParentMaterial_type > ParentMaterial_sequence;
  typedef ParentMaterial_sequence::iterator ParentMaterial_iterator;
  typedef ParentMaterial_sequence::const_iterator ParentMaterial_const_iterator;
  typedef ::xsd::cxx::tree::traits< ParentMaterial_type, char > ParentMaterial_traits;

  const ParentMaterial_sequence&
  ParentMaterial () const;

  ParentMaterial_sequence&
  ParentMaterial ();

  void
  ParentMaterial (const ParentMaterial_sequence& s);

  // ParentSubClass
  //
  typedef ::Class ParentSubClass_type;
  typedef ::xsd::cxx::tree::sequence< ParentSubClass_type > ParentSubClass_sequence;
  typedef ParentSubClass_sequence::iterator ParentSubClass_iterator;
  typedef ParentSubClass_sequence::const_iterator ParentSubClass_const_iterator;
  typedef ::xsd::cxx::tree::traits< ParentSubClass_type, char > ParentSubClass_traits;

  const ParentSubClass_sequence&
  ParentSubClass () const;

  ParentSubClass_sequence&
  ParentSubClass ();

  void
  ParentSubClass (const ParentSubClass_sequence& s);

  // Constructors.
  //
  Class ();

  Class (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  Class (const Class& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual Class*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Class&
  operator= (const Class& x);

  virtual 
  ~Class ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Name_optional Name_;
  ParentMaterial_sequence ParentMaterial_;
  ParentSubClass_sequence ParentSubClass_;
};

class ComponentDetails: public ::xml_schema::type
{
  public:
  // Name
  //
  typedef ::Name Name_type;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_type&
  Name () const;

  Name_type&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // Class
  //
  typedef ::Class Class_type;
  typedef ::xsd::cxx::tree::sequence< Class_type > Class_sequence;
  typedef Class_sequence::iterator Class_iterator;
  typedef Class_sequence::const_iterator Class_const_iterator;
  typedef ::xsd::cxx::tree::traits< Class_type, char > Class_traits;

  const Class_sequence&
  Class () const;

  Class_sequence&
  Class ();

  void
  Class (const Class_sequence& s);

  // Subclass
  //
  typedef ::Class Subclass_type;
  typedef ::xsd::cxx::tree::sequence< Subclass_type > Subclass_sequence;
  typedef Subclass_sequence::iterator Subclass_iterator;
  typedef Subclass_sequence::const_iterator Subclass_const_iterator;
  typedef ::xsd::cxx::tree::traits< Subclass_type, char > Subclass_traits;

  const Subclass_sequence&
  Subclass () const;

  Subclass_sequence&
  Subclass ();

  void
  Subclass (const Subclass_sequence& s);

  // Specification
  //
  typedef ::Specification Specification_type;
  typedef ::xsd::cxx::tree::sequence< Specification_type > Specification_sequence;
  typedef Specification_sequence::iterator Specification_iterator;
  typedef Specification_sequence::const_iterator Specification_const_iterator;
  typedef ::xsd::cxx::tree::traits< Specification_type, char > Specification_traits;

  const Specification_sequence&
  Specification () const;

  Specification_sequence&
  Specification ();

  void
  Specification (const Specification_sequence& s);

  // Source
  //
  typedef ::Source Source_type;
  typedef ::xsd::cxx::tree::optional< Source_type > Source_optional;
  typedef ::xsd::cxx::tree::traits< Source_type, char > Source_traits;

  const Source_optional&
  Source () const;

  Source_optional&
  Source ();

  void
  Source (const Source_type& x);

  void
  Source (const Source_optional& x);

  void
  Source (::std::auto_ptr< Source_type > p);

  // Form
  //
  typedef ::Form Form_type;
  typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
  typedef ::xsd::cxx::tree::traits< Form_type, char > Form_traits;

  const Form_optional&
  Form () const;

  Form_optional&
  Form ();

  void
  Form (const Form_type& x);

  void
  Form (const Form_optional& x);

  void
  Form (::std::auto_ptr< Form_type > p);

  // ProcessingDetails
  //
  typedef ::ProcessingDetails ProcessingDetails_type;
  typedef ::xsd::cxx::tree::sequence< ProcessingDetails_type > ProcessingDetails_sequence;
  typedef ProcessingDetails_sequence::iterator ProcessingDetails_iterator;
  typedef ProcessingDetails_sequence::const_iterator ProcessingDetails_const_iterator;
  typedef ::xsd::cxx::tree::traits< ProcessingDetails_type, char > ProcessingDetails_traits;

  const ProcessingDetails_sequence&
  ProcessingDetails () const;

  ProcessingDetails_sequence&
  ProcessingDetails ();

  void
  ProcessingDetails (const ProcessingDetails_sequence& s);

  // Characterization
  //
  typedef ::Characterization Characterization_type;
  typedef ::xsd::cxx::tree::optional< Characterization_type > Characterization_optional;
  typedef ::xsd::cxx::tree::traits< Characterization_type, char > Characterization_traits;

  const Characterization_optional&
  Characterization () const;

  Characterization_optional&
  Characterization ();

  void
  Characterization (const Characterization_type& x);

  void
  Characterization (const Characterization_optional& x);

  void
  Characterization (::std::auto_ptr< Characterization_type > p);

  // PropertyData
  //
  typedef ::PropertyData PropertyData_type;
  typedef ::xsd::cxx::tree::sequence< PropertyData_type > PropertyData_sequence;
  typedef PropertyData_sequence::iterator PropertyData_iterator;
  typedef PropertyData_sequence::const_iterator PropertyData_const_iterator;
  typedef ::xsd::cxx::tree::traits< PropertyData_type, char > PropertyData_traits;

  const PropertyData_sequence&
  PropertyData () const;

  PropertyData_sequence&
  PropertyData ();

  void
  PropertyData (const PropertyData_sequence& s);

  // AssociationDetails
  //
  typedef ::AssociationDetails AssociationDetails_type;
  typedef ::xsd::cxx::tree::sequence< AssociationDetails_type > AssociationDetails_sequence;
  typedef AssociationDetails_sequence::iterator AssociationDetails_iterator;
  typedef AssociationDetails_sequence::const_iterator AssociationDetails_const_iterator;
  typedef ::xsd::cxx::tree::traits< AssociationDetails_type, char > AssociationDetails_traits;

  const AssociationDetails_sequence&
  AssociationDetails () const;

  AssociationDetails_sequence&
  AssociationDetails ();

  void
  AssociationDetails (const AssociationDetails_sequence& s);

  // ComponentDetails
  //
  typedef ::ComponentDetails ComponentDetails1_type;
  typedef ::xsd::cxx::tree::sequence< ComponentDetails1_type > ComponentDetails1_sequence;
  typedef ComponentDetails1_sequence::iterator ComponentDetails1_iterator;
  typedef ComponentDetails1_sequence::const_iterator ComponentDetails1_const_iterator;
  typedef ::xsd::cxx::tree::traits< ComponentDetails1_type, char > ComponentDetails1_traits;

  const ComponentDetails1_sequence&
  ComponentDetails1 () const;

  ComponentDetails1_sequence&
  ComponentDetails1 ();

  void
  ComponentDetails1 (const ComponentDetails1_sequence& s);

  // id
  //
  typedef ::xml_schema::id id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::auto_ptr< id_type > p);

  // Constructors.
  //
  ComponentDetails (const Name_type&);

  ComponentDetails (::std::auto_ptr< Name_type >);

  ComponentDetails (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  ComponentDetails (const ComponentDetails& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual ComponentDetails*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ComponentDetails&
  operator= (const ComponentDetails& x);

  virtual 
  ~ComponentDetails ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Name_type > Name_;
  Class_sequence Class_;
  Subclass_sequence Subclass_;
  Specification_sequence Specification_;
  Source_optional Source_;
  Form_optional Form_;
  ProcessingDetails_sequence ProcessingDetails_;
  Characterization_optional Characterization_;
  PropertyData_sequence PropertyData_;
  AssociationDetails_sequence AssociationDetails_;
  ComponentDetails1_sequence ComponentDetails1_;
  id_optional id_;
};

class Compound: public ::xml_schema::type
{
  public:
  // Element
  //
  typedef ::Element Element_type;
  typedef ::xsd::cxx::tree::sequence< Element_type > Element_sequence;
  typedef Element_sequence::iterator Element_iterator;
  typedef Element_sequence::const_iterator Element_const_iterator;
  typedef ::xsd::cxx::tree::traits< Element_type, char > Element_traits;

  const Element_sequence&
  Element () const;

  Element_sequence&
  Element ();

  void
  Element (const Element_sequence& s);

  // Concentration
  //
  typedef ::Concentration Concentration_type;
  typedef ::xsd::cxx::tree::optional< Concentration_type > Concentration_optional;
  typedef ::xsd::cxx::tree::traits< Concentration_type, char > Concentration_traits;

  const Concentration_optional&
  Concentration () const;

  Concentration_optional&
  Concentration ();

  void
  Concentration (const Concentration_type& x);

  void
  Concentration (const Concentration_optional& x);

  void
  Concentration (::std::auto_ptr< Concentration_type > p);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // Constructors.
  //
  Compound ();

  Compound (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  Compound (const Compound& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual Compound*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Compound&
  operator= (const Compound& x);

  virtual 
  ~Compound ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Element_sequence Element_;
  Concentration_optional Concentration_;
  Notes_optional Notes_;
};

class Concentration: public ::xml_schema::type
{
  public:
  // Value
  //
  typedef ::Value Value_type;
  typedef ::xsd::cxx::tree::traits< Value_type, char > Value_traits;

  const Value_type&
  Value () const;

  Value_type&
  Value ();

  void
  Value (const Value_type& x);

  void
  Value (::std::auto_ptr< Value_type > p);

  // Units
  //
  typedef ::Units Units_type;
  typedef ::xsd::cxx::tree::traits< Units_type, char > Units_traits;

  const Units_type&
  Units () const;

  Units_type&
  Units ();

  void
  Units (const Units_type& x);

  void
  Units (::std::auto_ptr< Units_type > p);

  // Qualifier
  //
  typedef ::Qualifier Qualifier_type;
  typedef ::xsd::cxx::tree::sequence< Qualifier_type > Qualifier_sequence;
  typedef Qualifier_sequence::iterator Qualifier_iterator;
  typedef Qualifier_sequence::const_iterator Qualifier_const_iterator;
  typedef ::xsd::cxx::tree::traits< Qualifier_type, char > Qualifier_traits;

  const Qualifier_sequence&
  Qualifier () const;

  Qualifier_sequence&
  Qualifier ();

  void
  Qualifier (const Qualifier_sequence& s);

  // Uncertainty
  //
  typedef ::Uncertainty Uncertainty_type;
  typedef ::xsd::cxx::tree::sequence< Uncertainty_type > Uncertainty_sequence;
  typedef Uncertainty_sequence::iterator Uncertainty_iterator;
  typedef Uncertainty_sequence::const_iterator Uncertainty_const_iterator;
  typedef ::xsd::cxx::tree::traits< Uncertainty_type, char > Uncertainty_traits;

  const Uncertainty_sequence&
  Uncertainty () const;

  Uncertainty_sequence&
  Uncertainty ();

  void
  Uncertainty (const Uncertainty_sequence& s);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // Constructors.
  //
  Concentration (const Value_type&,
                 const Units_type&);

  Concentration (::std::auto_ptr< Value_type >,
                 ::std::auto_ptr< Units_type >);

  Concentration (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  Concentration (const Concentration& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual Concentration*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Concentration&
  operator= (const Concentration& x);

  virtual 
  ~Concentration ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Value_type > Value_;
  ::xsd::cxx::tree::one< Units_type > Units_;
  Qualifier_sequence Qualifier_;
  Uncertainty_sequence Uncertainty_;
  Notes_optional Notes_;
};

class DataFormat: public ::xml_schema::string
{
  public:
  enum value
  {
    float_,
    integer,
    string,
    exponential,
    mixed
  };

  DataFormat (value v);

  DataFormat (const char* v);

  DataFormat (const ::std::string& v);

  DataFormat (const ::xml_schema::string& v);

  DataFormat (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  DataFormat (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  DataFormat (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  DataFormat (const DataFormat& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual DataFormat*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  DataFormat&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_DataFormat_convert ();
  }

  protected:
  value
  _xsd_DataFormat_convert () const;

  public:
  static const char* const _xsd_DataFormat_literals_[5];
  static const value _xsd_DataFormat_indexes_[5];
};

class DimensionalDetails: public ::xml_schema::type
{
  public:
  // Name
  //
  typedef ::Name Name_type;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_type&
  Name () const;

  Name_type&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // Value
  //
  typedef ::Value Value_type;
  typedef ::xsd::cxx::tree::traits< Value_type, char > Value_traits;

  const Value_type&
  Value () const;

  Value_type&
  Value ();

  void
  Value (const Value_type& x);

  void
  Value (::std::auto_ptr< Value_type > p);

  // Units
  //
  typedef ::Units Units_type;
  typedef ::xsd::cxx::tree::traits< Units_type, char > Units_traits;

  const Units_type&
  Units () const;

  Units_type&
  Units ();

  void
  Units (const Units_type& x);

  void
  Units (::std::auto_ptr< Units_type > p);

  // Qualifier
  //
  typedef ::Qualifier Qualifier_type;
  typedef ::xsd::cxx::tree::optional< Qualifier_type > Qualifier_optional;
  typedef ::xsd::cxx::tree::traits< Qualifier_type, char > Qualifier_traits;

  const Qualifier_optional&
  Qualifier () const;

  Qualifier_optional&
  Qualifier ();

  void
  Qualifier (const Qualifier_type& x);

  void
  Qualifier (const Qualifier_optional& x);

  void
  Qualifier (::std::auto_ptr< Qualifier_type > p);

  // Uncertainty
  //
  typedef ::Uncertainty Uncertainty_type;
  typedef ::xsd::cxx::tree::sequence< Uncertainty_type > Uncertainty_sequence;
  typedef Uncertainty_sequence::iterator Uncertainty_iterator;
  typedef Uncertainty_sequence::const_iterator Uncertainty_const_iterator;
  typedef ::xsd::cxx::tree::traits< Uncertainty_type, char > Uncertainty_traits;

  const Uncertainty_sequence&
  Uncertainty () const;

  Uncertainty_sequence&
  Uncertainty ();

  void
  Uncertainty (const Uncertainty_sequence& s);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // Constructors.
  //
  DimensionalDetails (const Name_type&,
                      const Value_type&,
                      const Units_type&);

  DimensionalDetails (::std::auto_ptr< Name_type >,
                      ::std::auto_ptr< Value_type >,
                      ::std::auto_ptr< Units_type >);

  DimensionalDetails (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  DimensionalDetails (const DimensionalDetails& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual DimensionalDetails*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  DimensionalDetails&
  operator= (const DimensionalDetails& x);

  virtual 
  ~DimensionalDetails ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Name_type > Name_;
  ::xsd::cxx::tree::one< Value_type > Value_;
  ::xsd::cxx::tree::one< Units_type > Units_;
  Qualifier_optional Qualifier_;
  Uncertainty_sequence Uncertainty_;
  Notes_optional Notes_;
};

class Element: public ::xml_schema::type
{
  public:
  // Symbol
  //
  typedef ::Symbol Symbol_type;
  typedef ::xsd::cxx::tree::traits< Symbol_type, char > Symbol_traits;

  const Symbol_type&
  Symbol () const;

  Symbol_type&
  Symbol ();

  void
  Symbol (const Symbol_type& x);

  void
  Symbol (::std::auto_ptr< Symbol_type > p);

  // Concentration
  //
  typedef ::Concentration Concentration_type;
  typedef ::xsd::cxx::tree::optional< Concentration_type > Concentration_optional;
  typedef ::xsd::cxx::tree::traits< Concentration_type, char > Concentration_traits;

  const Concentration_optional&
  Concentration () const;

  Concentration_optional&
  Concentration ();

  void
  Concentration (const Concentration_type& x);

  void
  Concentration (const Concentration_optional& x);

  void
  Concentration (::std::auto_ptr< Concentration_type > p);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // Constructors.
  //
  Element (const Symbol_type&);

  Element (::std::auto_ptr< Symbol_type >);

  Element (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  Element (const Element& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual Element*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Element&
  operator= (const Element& x);

  virtual 
  ~Element ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Symbol_type > Symbol_;
  Concentration_optional Concentration_;
  Notes_optional Notes_;
};

class Form: public ::xml_schema::type
{
  public:
  // Description
  //
  typedef ::Name Description_type;
  typedef ::xsd::cxx::tree::traits< Description_type, char > Description_traits;

  const Description_type&
  Description () const;

  Description_type&
  Description ();

  void
  Description (const Description_type& x);

  void
  Description (::std::auto_ptr< Description_type > p);

  // Geometry
  //
  typedef ::Geometry Geometry_type;
  typedef ::xsd::cxx::tree::optional< Geometry_type > Geometry_optional;
  typedef ::xsd::cxx::tree::traits< Geometry_type, char > Geometry_traits;

  const Geometry_optional&
  Geometry () const;

  Geometry_optional&
  Geometry ();

  void
  Geometry (const Geometry_type& x);

  void
  Geometry (const Geometry_optional& x);

  void
  Geometry (::std::auto_ptr< Geometry_type > p);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // Constructors.
  //
  Form (const Description_type&);

  Form (::std::auto_ptr< Description_type >);

  Form (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  Form (const Form& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual Form*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Form&
  operator= (const Form& x);

  virtual 
  ~Form ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Description_type > Description_;
  Geometry_optional Geometry_;
  Notes_optional Notes_;
};

class Formula: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  Formula ();

  Formula (const char*);

  Formula (const ::std::string&);

  Formula (const ::xml_schema::string&);

  Formula (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  Formula (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  Formula (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  Formula (const Formula& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual Formula*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Formula ();
};

class Geometry: public ::xml_schema::type
{
  public:
  // Shape
  //
  typedef ::xml_schema::string Shape_type;
  typedef ::xsd::cxx::tree::traits< Shape_type, char > Shape_traits;

  const Shape_type&
  Shape () const;

  Shape_type&
  Shape ();

  void
  Shape (const Shape_type& x);

  void
  Shape (::std::auto_ptr< Shape_type > p);

  // Dimensions
  //
  typedef ::xml_schema::string Dimensions_type;
  typedef ::xsd::cxx::tree::optional< Dimensions_type > Dimensions_optional;
  typedef ::xsd::cxx::tree::traits< Dimensions_type, char > Dimensions_traits;

  const Dimensions_optional&
  Dimensions () const;

  Dimensions_optional&
  Dimensions ();

  void
  Dimensions (const Dimensions_type& x);

  void
  Dimensions (const Dimensions_optional& x);

  void
  Dimensions (::std::auto_ptr< Dimensions_type > p);

  // Orientation
  //
  typedef ::xml_schema::string Orientation_type;
  typedef ::xsd::cxx::tree::optional< Orientation_type > Orientation_optional;
  typedef ::xsd::cxx::tree::traits< Orientation_type, char > Orientation_traits;

  const Orientation_optional&
  Orientation () const;

  Orientation_optional&
  Orientation ();

  void
  Orientation (const Orientation_type& x);

  void
  Orientation (const Orientation_optional& x);

  void
  Orientation (::std::auto_ptr< Orientation_type > p);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // Constructors.
  //
  Geometry (const Shape_type&);

  Geometry (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  Geometry (const Geometry& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual Geometry*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Geometry&
  operator= (const Geometry& x);

  virtual 
  ~Geometry ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Shape_type > Shape_;
  Dimensions_optional Dimensions_;
  Orientation_optional Orientation_;
  Notes_optional Notes_;
};

class Glossary: public ::xml_schema::type
{
  public:
  // Term
  //
  typedef ::GlossaryTerm Term_type;
  typedef ::xsd::cxx::tree::sequence< Term_type > Term_sequence;
  typedef Term_sequence::iterator Term_iterator;
  typedef Term_sequence::const_iterator Term_const_iterator;
  typedef ::xsd::cxx::tree::traits< Term_type, char > Term_traits;

  const Term_sequence&
  Term () const;

  Term_sequence&
  Term ();

  void
  Term (const Term_sequence& s);

  // Constructors.
  //
  Glossary ();

  Glossary (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  Glossary (const Glossary& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual Glossary*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Glossary&
  operator= (const Glossary& x);

  virtual 
  ~Glossary ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Term_sequence Term_;
};

class GlossaryTerm: public ::xml_schema::type
{
  public:
  // Name
  //
  typedef ::Name Name_type;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_type&
  Name () const;

  Name_type&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // Definition
  //
  typedef ::xml_schema::string Definition_type;
  typedef ::xsd::cxx::tree::traits< Definition_type, char > Definition_traits;

  const Definition_type&
  Definition () const;

  Definition_type&
  Definition ();

  void
  Definition (const Definition_type& x);

  void
  Definition (::std::auto_ptr< Definition_type > p);

  // Abbreviation
  //
  typedef ::xml_schema::string Abbreviation_type;
  typedef ::xsd::cxx::tree::sequence< Abbreviation_type > Abbreviation_sequence;
  typedef Abbreviation_sequence::iterator Abbreviation_iterator;
  typedef Abbreviation_sequence::const_iterator Abbreviation_const_iterator;
  typedef ::xsd::cxx::tree::traits< Abbreviation_type, char > Abbreviation_traits;

  const Abbreviation_sequence&
  Abbreviation () const;

  Abbreviation_sequence&
  Abbreviation ();

  void
  Abbreviation (const Abbreviation_sequence& s);

  // Synonym
  //
  typedef ::xml_schema::string Synonym_type;
  typedef ::xsd::cxx::tree::sequence< Synonym_type > Synonym_sequence;
  typedef Synonym_sequence::iterator Synonym_iterator;
  typedef Synonym_sequence::const_iterator Synonym_const_iterator;
  typedef ::xsd::cxx::tree::traits< Synonym_type, char > Synonym_traits;

  const Synonym_sequence&
  Synonym () const;

  Synonym_sequence&
  Synonym ();

  void
  Synonym (const Synonym_sequence& s);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // Constructors.
  //
  GlossaryTerm (const Name_type&,
                const Definition_type&);

  GlossaryTerm (::std::auto_ptr< Name_type >,
                const Definition_type&);

  GlossaryTerm (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  GlossaryTerm (const GlossaryTerm& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual GlossaryTerm*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  GlossaryTerm&
  operator= (const GlossaryTerm& x);

  virtual 
  ~GlossaryTerm ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Name_type > Name_;
  ::xsd::cxx::tree::one< Definition_type > Definition_;
  Abbreviation_sequence Abbreviation_;
  Synonym_sequence Synonym_;
  Notes_optional Notes_;
};

class Graphs: public ::xml_schema::type
{
  public:
  // Graph
  //
  typedef ::Graph Graph_type;
  typedef ::xsd::cxx::tree::sequence< Graph_type > Graph_sequence;
  typedef Graph_sequence::iterator Graph_iterator;
  typedef Graph_sequence::const_iterator Graph_const_iterator;
  typedef ::xsd::cxx::tree::traits< Graph_type, char > Graph_traits;

  const Graph_sequence&
  Graph () const;

  Graph_sequence&
  Graph ();

  void
  Graph (const Graph_sequence& s);

  // Constructors.
  //
  Graphs ();

  Graphs (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  Graphs (const Graphs& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual Graphs*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Graphs&
  operator= (const Graphs& x);

  virtual 
  ~Graphs ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Graph_sequence Graph_;
};

class Material: public ::xml_schema::type
{
  public:
  // BulkDetails
  //
  typedef ::BulkDetails BulkDetails_type;
  typedef ::xsd::cxx::tree::traits< BulkDetails_type, char > BulkDetails_traits;

  const BulkDetails_type&
  BulkDetails () const;

  BulkDetails_type&
  BulkDetails ();

  void
  BulkDetails (const BulkDetails_type& x);

  void
  BulkDetails (::std::auto_ptr< BulkDetails_type > p);

  // ComponentDetails
  //
  typedef ::ComponentDetails ComponentDetails_type;
  typedef ::xsd::cxx::tree::sequence< ComponentDetails_type > ComponentDetails_sequence;
  typedef ComponentDetails_sequence::iterator ComponentDetails_iterator;
  typedef ComponentDetails_sequence::const_iterator ComponentDetails_const_iterator;
  typedef ::xsd::cxx::tree::traits< ComponentDetails_type, char > ComponentDetails_traits;

  const ComponentDetails_sequence&
  ComponentDetails () const;

  ComponentDetails_sequence&
  ComponentDetails ();

  void
  ComponentDetails (const ComponentDetails_sequence& s);

  // Graphs
  //
  typedef ::Graphs Graphs_type;
  typedef ::xsd::cxx::tree::optional< Graphs_type > Graphs_optional;
  typedef ::xsd::cxx::tree::traits< Graphs_type, char > Graphs_traits;

  const Graphs_optional&
  Graphs () const;

  Graphs_optional&
  Graphs ();

  void
  Graphs (const Graphs_type& x);

  void
  Graphs (const Graphs_optional& x);

  void
  Graphs (::std::auto_ptr< Graphs_type > p);

  // Glossary
  //
  typedef ::Glossary Glossary_type;
  typedef ::xsd::cxx::tree::optional< Glossary_type > Glossary_optional;
  typedef ::xsd::cxx::tree::traits< Glossary_type, char > Glossary_traits;

  const Glossary_optional&
  Glossary () const;

  Glossary_optional&
  Glossary ();

  void
  Glossary (const Glossary_type& x);

  void
  Glossary (const Glossary_optional& x);

  void
  Glossary (::std::auto_ptr< Glossary_type > p);

  // id
  //
  typedef ::xml_schema::id id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::auto_ptr< id_type > p);

  // layers
  //
  typedef ::xml_schema::integer layers_type;
  typedef ::xsd::cxx::tree::optional< layers_type > layers_optional;
  typedef ::xsd::cxx::tree::traits< layers_type, char > layers_traits;

  const layers_optional&
  layers () const;

  layers_optional&
  layers ();

  void
  layers (const layers_type& x);

  void
  layers (const layers_optional& x);

  // local_frame_of_reference
  //
  typedef ::xml_schema::string local_frame_of_reference_type;
  typedef ::xsd::cxx::tree::optional< local_frame_of_reference_type > local_frame_of_reference_optional;
  typedef ::xsd::cxx::tree::traits< local_frame_of_reference_type, char > local_frame_of_reference_traits;

  const local_frame_of_reference_optional&
  local_frame_of_reference () const;

  local_frame_of_reference_optional&
  local_frame_of_reference ();

  void
  local_frame_of_reference (const local_frame_of_reference_type& x);

  void
  local_frame_of_reference (const local_frame_of_reference_optional& x);

  void
  local_frame_of_reference (::std::auto_ptr< local_frame_of_reference_type > p);

  // Constructors.
  //
  Material (const BulkDetails_type&);

  Material (::std::auto_ptr< BulkDetails_type >);

  Material (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  Material (const Material& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual Material*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Material&
  operator= (const Material& x);

  virtual 
  ~Material ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< BulkDetails_type > BulkDetails_;
  ComponentDetails_sequence ComponentDetails_;
  Graphs_optional Graphs_;
  Glossary_optional Glossary_;
  id_optional id_;
  layers_optional layers_;
  local_frame_of_reference_optional local_frame_of_reference_;
};

class Metadata: public ::xml_schema::type
{
  public:
  // AuthorityDetails
  //
  typedef ::AuthorityDetails AuthorityDetails_type;
  typedef ::xsd::cxx::tree::sequence< AuthorityDetails_type > AuthorityDetails_sequence;
  typedef AuthorityDetails_sequence::iterator AuthorityDetails_iterator;
  typedef AuthorityDetails_sequence::const_iterator AuthorityDetails_const_iterator;
  typedef ::xsd::cxx::tree::traits< AuthorityDetails_type, char > AuthorityDetails_traits;

  const AuthorityDetails_sequence&
  AuthorityDetails () const;

  AuthorityDetails_sequence&
  AuthorityDetails ();

  void
  AuthorityDetails (const AuthorityDetails_sequence& s);

  // DataSourceDetails
  //
  typedef ::DataSourceDetails DataSourceDetails_type;
  typedef ::xsd::cxx::tree::sequence< DataSourceDetails_type > DataSourceDetails_sequence;
  typedef DataSourceDetails_sequence::iterator DataSourceDetails_iterator;
  typedef DataSourceDetails_sequence::const_iterator DataSourceDetails_const_iterator;
  typedef ::xsd::cxx::tree::traits< DataSourceDetails_type, char > DataSourceDetails_traits;

  const DataSourceDetails_sequence&
  DataSourceDetails () const;

  DataSourceDetails_sequence&
  DataSourceDetails ();

  void
  DataSourceDetails (const DataSourceDetails_sequence& s);

  // MeasurementTechniqueDetails
  //
  typedef ::MeasurementTechniqueDetails MeasurementTechniqueDetails_type;
  typedef ::xsd::cxx::tree::sequence< MeasurementTechniqueDetails_type > MeasurementTechniqueDetails_sequence;
  typedef MeasurementTechniqueDetails_sequence::iterator MeasurementTechniqueDetails_iterator;
  typedef MeasurementTechniqueDetails_sequence::const_iterator MeasurementTechniqueDetails_const_iterator;
  typedef ::xsd::cxx::tree::traits< MeasurementTechniqueDetails_type, char > MeasurementTechniqueDetails_traits;

  const MeasurementTechniqueDetails_sequence&
  MeasurementTechniqueDetails () const;

  MeasurementTechniqueDetails_sequence&
  MeasurementTechniqueDetails ();

  void
  MeasurementTechniqueDetails (const MeasurementTechniqueDetails_sequence& s);

  // ParameterDetails
  //
  typedef ::ParameterDetails ParameterDetails_type;
  typedef ::xsd::cxx::tree::sequence< ParameterDetails_type > ParameterDetails_sequence;
  typedef ParameterDetails_sequence::iterator ParameterDetails_iterator;
  typedef ParameterDetails_sequence::const_iterator ParameterDetails_const_iterator;
  typedef ::xsd::cxx::tree::traits< ParameterDetails_type, char > ParameterDetails_traits;

  const ParameterDetails_sequence&
  ParameterDetails () const;

  ParameterDetails_sequence&
  ParameterDetails ();

  void
  ParameterDetails (const ParameterDetails_sequence& s);

  // PropertyDetails
  //
  typedef ::PropertyDetails PropertyDetails_type;
  typedef ::xsd::cxx::tree::sequence< PropertyDetails_type > PropertyDetails_sequence;
  typedef PropertyDetails_sequence::iterator PropertyDetails_iterator;
  typedef PropertyDetails_sequence::const_iterator PropertyDetails_const_iterator;
  typedef ::xsd::cxx::tree::traits< PropertyDetails_type, char > PropertyDetails_traits;

  const PropertyDetails_sequence&
  PropertyDetails () const;

  PropertyDetails_sequence&
  PropertyDetails ();

  void
  PropertyDetails (const PropertyDetails_sequence& s);

  // SourceDetails
  //
  typedef ::SourceDetails SourceDetails_type;
  typedef ::xsd::cxx::tree::sequence< SourceDetails_type > SourceDetails_sequence;
  typedef SourceDetails_sequence::iterator SourceDetails_iterator;
  typedef SourceDetails_sequence::const_iterator SourceDetails_const_iterator;
  typedef ::xsd::cxx::tree::traits< SourceDetails_type, char > SourceDetails_traits;

  const SourceDetails_sequence&
  SourceDetails () const;

  SourceDetails_sequence&
  SourceDetails ();

  void
  SourceDetails (const SourceDetails_sequence& s);

  // SpecimenDetails
  //
  typedef ::SpecimenDetails SpecimenDetails_type;
  typedef ::xsd::cxx::tree::sequence< SpecimenDetails_type > SpecimenDetails_sequence;
  typedef SpecimenDetails_sequence::iterator SpecimenDetails_iterator;
  typedef SpecimenDetails_sequence::const_iterator SpecimenDetails_const_iterator;
  typedef ::xsd::cxx::tree::traits< SpecimenDetails_type, char > SpecimenDetails_traits;

  const SpecimenDetails_sequence&
  SpecimenDetails () const;

  SpecimenDetails_sequence&
  SpecimenDetails ();

  void
  SpecimenDetails (const SpecimenDetails_sequence& s);

  // TestConditionDetails
  //
  typedef ::TestConditionDetails TestConditionDetails_type;
  typedef ::xsd::cxx::tree::sequence< TestConditionDetails_type > TestConditionDetails_sequence;
  typedef TestConditionDetails_sequence::iterator TestConditionDetails_iterator;
  typedef TestConditionDetails_sequence::const_iterator TestConditionDetails_const_iterator;
  typedef ::xsd::cxx::tree::traits< TestConditionDetails_type, char > TestConditionDetails_traits;

  const TestConditionDetails_sequence&
  TestConditionDetails () const;

  TestConditionDetails_sequence&
  TestConditionDetails ();

  void
  TestConditionDetails (const TestConditionDetails_sequence& s);

  // Constructors.
  //
  Metadata ();

  Metadata (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  Metadata (const Metadata& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual Metadata*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Metadata&
  operator= (const Metadata& x);

  virtual 
  ~Metadata ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  AuthorityDetails_sequence AuthorityDetails_;
  DataSourceDetails_sequence DataSourceDetails_;
  MeasurementTechniqueDetails_sequence MeasurementTechniqueDetails_;
  ParameterDetails_sequence ParameterDetails_;
  PropertyDetails_sequence PropertyDetails_;
  SourceDetails_sequence SourceDetails_;
  SpecimenDetails_sequence SpecimenDetails_;
  TestConditionDetails_sequence TestConditionDetails_;
};

class Name: public ::xml_schema::string
{
  public:
  // authority
  //
  typedef ::xml_schema::idref authority_type;
  typedef ::xsd::cxx::tree::optional< authority_type > authority_optional;
  typedef ::xsd::cxx::tree::traits< authority_type, char > authority_traits;

  const authority_optional&
  authority () const;

  authority_optional&
  authority ();

  void
  authority (const authority_type& x);

  void
  authority (const authority_optional& x);

  void
  authority (::std::auto_ptr< authority_type > p);

  // Constructors.
  //
  Name ();

  Name (const char*);

  Name (const ::std::string&);

  Name (const ::xml_schema::string&);

  Name (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  Name (const Name& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual Name*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Name&
  operator= (const Name& x);

  virtual 
  ~Name ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  authority_optional authority_;
};

class Notes: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  Notes ();

  Notes (const char*);

  Notes (const ::std::string&);

  Notes (const ::xml_schema::string&);

  Notes (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  Notes (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  Notes (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  Notes (const Notes& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual Notes*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Notes ();
};

class ParameterValue: public ::xml_schema::type
{
  public:
  // Data
  //
  typedef ::Data Data_type;
  typedef ::xsd::cxx::tree::traits< Data_type, char > Data_traits;

  const Data_type&
  Data () const;

  Data_type&
  Data ();

  void
  Data (const Data_type& x);

  void
  Data (::std::auto_ptr< Data_type > p);

  // Uncertainty
  //
  typedef ::Uncertainty Uncertainty_type;
  typedef ::xsd::cxx::tree::sequence< Uncertainty_type > Uncertainty_sequence;
  typedef Uncertainty_sequence::iterator Uncertainty_iterator;
  typedef Uncertainty_sequence::const_iterator Uncertainty_const_iterator;
  typedef ::xsd::cxx::tree::traits< Uncertainty_type, char > Uncertainty_traits;

  const Uncertainty_sequence&
  Uncertainty () const;

  Uncertainty_sequence&
  Uncertainty ();

  void
  Uncertainty (const Uncertainty_sequence& s);

  // Qualifier
  //
  typedef ::Qualifier Qualifier_type;
  typedef ::xsd::cxx::tree::sequence< Qualifier_type > Qualifier_sequence;
  typedef Qualifier_sequence::iterator Qualifier_iterator;
  typedef Qualifier_sequence::const_iterator Qualifier_const_iterator;
  typedef ::xsd::cxx::tree::traits< Qualifier_type, char > Qualifier_traits;

  const Qualifier_sequence&
  Qualifier () const;

  Qualifier_sequence&
  Qualifier ();

  void
  Qualifier (const Qualifier_sequence& s);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // parameter
  //
  typedef ::xml_schema::idref parameter_type;
  typedef ::xsd::cxx::tree::traits< parameter_type, char > parameter_traits;

  const parameter_type&
  parameter () const;

  parameter_type&
  parameter ();

  void
  parameter (const parameter_type& x);

  void
  parameter (::std::auto_ptr< parameter_type > p);

  // format
  //
  typedef ::DataFormat format_type;
  typedef ::xsd::cxx::tree::traits< format_type, char > format_traits;

  const format_type&
  format () const;

  format_type&
  format ();

  void
  format (const format_type& x);

  void
  format (::std::auto_ptr< format_type > p);

  // Constructors.
  //
  ParameterValue (const Data_type&,
                  const parameter_type&,
                  const format_type&);

  ParameterValue (::std::auto_ptr< Data_type >,
                  const parameter_type&,
                  const format_type&);

  ParameterValue (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  ParameterValue (const ParameterValue& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual ParameterValue*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ParameterValue&
  operator= (const ParameterValue& x);

  virtual 
  ~ParameterValue ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Data_type > Data_;
  Uncertainty_sequence Uncertainty_;
  Qualifier_sequence Qualifier_;
  Notes_optional Notes_;
  ::xsd::cxx::tree::one< parameter_type > parameter_;
  ::xsd::cxx::tree::one< format_type > format_;
};

class PhaseComposition: public ::xml_schema::type
{
  public:
  // Name
  //
  typedef ::Name Name_type;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_type&
  Name () const;

  Name_type&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // Concentration
  //
  typedef ::Concentration Concentration_type;
  typedef ::xsd::cxx::tree::optional< Concentration_type > Concentration_optional;
  typedef ::xsd::cxx::tree::traits< Concentration_type, char > Concentration_traits;

  const Concentration_optional&
  Concentration () const;

  Concentration_optional&
  Concentration ();

  void
  Concentration (const Concentration_type& x);

  void
  Concentration (const Concentration_optional& x);

  void
  Concentration (::std::auto_ptr< Concentration_type > p);

  // PropertyData
  //
  typedef ::PropertyData PropertyData_type;
  typedef ::xsd::cxx::tree::sequence< PropertyData_type > PropertyData_sequence;
  typedef PropertyData_sequence::iterator PropertyData_iterator;
  typedef PropertyData_sequence::const_iterator PropertyData_const_iterator;
  typedef ::xsd::cxx::tree::traits< PropertyData_type, char > PropertyData_traits;

  const PropertyData_sequence&
  PropertyData () const;

  PropertyData_sequence&
  PropertyData ();

  void
  PropertyData (const PropertyData_sequence& s);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // Constructors.
  //
  PhaseComposition (const Name_type&);

  PhaseComposition (::std::auto_ptr< Name_type >);

  PhaseComposition (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  PhaseComposition (const PhaseComposition& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual PhaseComposition*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  PhaseComposition&
  operator= (const PhaseComposition& x);

  virtual 
  ~PhaseComposition ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Name_type > Name_;
  Concentration_optional Concentration_;
  PropertyData_sequence PropertyData_;
  Notes_optional Notes_;
};

class ProcessingDetails: public ::xml_schema::type
{
  public:
  // Name
  //
  typedef ::Name Name_type;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_type&
  Name () const;

  Name_type&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // ParameterValue
  //
  typedef ::ParameterValue ParameterValue_type;
  typedef ::xsd::cxx::tree::sequence< ParameterValue_type > ParameterValue_sequence;
  typedef ParameterValue_sequence::iterator ParameterValue_iterator;
  typedef ParameterValue_sequence::const_iterator ParameterValue_const_iterator;
  typedef ::xsd::cxx::tree::traits< ParameterValue_type, char > ParameterValue_traits;

  const ParameterValue_sequence&
  ParameterValue () const;

  ParameterValue_sequence&
  ParameterValue ();

  void
  ParameterValue (const ParameterValue_sequence& s);

  // Result
  //
  typedef ::xml_schema::string Result_type;
  typedef ::xsd::cxx::tree::optional< Result_type > Result_optional;
  typedef ::xsd::cxx::tree::traits< Result_type, char > Result_traits;

  const Result_optional&
  Result () const;

  Result_optional&
  Result ();

  void
  Result (const Result_type& x);

  void
  Result (const Result_optional& x);

  void
  Result (::std::auto_ptr< Result_type > p);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // Constructors.
  //
  ProcessingDetails (const Name_type&);

  ProcessingDetails (::std::auto_ptr< Name_type >);

  ProcessingDetails (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  ProcessingDetails (const ProcessingDetails& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual ProcessingDetails*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ProcessingDetails&
  operator= (const ProcessingDetails& x);

  virtual 
  ~ProcessingDetails ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Name_type > Name_;
  ParameterValue_sequence ParameterValue_;
  Result_optional Result_;
  Notes_optional Notes_;
};

class PropertyData: public ::xml_schema::type
{
  public:
  // Data
  //
  typedef ::Data1 Data_type;
  typedef ::xsd::cxx::tree::traits< Data_type, char > Data_traits;

  const Data_type&
  Data () const;

  Data_type&
  Data ();

  void
  Data (const Data_type& x);

  void
  Data (::std::auto_ptr< Data_type > p);

  // Uncertainty
  //
  typedef ::Uncertainty Uncertainty_type;
  typedef ::xsd::cxx::tree::sequence< Uncertainty_type > Uncertainty_sequence;
  typedef Uncertainty_sequence::iterator Uncertainty_iterator;
  typedef Uncertainty_sequence::const_iterator Uncertainty_const_iterator;
  typedef ::xsd::cxx::tree::traits< Uncertainty_type, char > Uncertainty_traits;

  const Uncertainty_sequence&
  Uncertainty () const;

  Uncertainty_sequence&
  Uncertainty ();

  void
  Uncertainty (const Uncertainty_sequence& s);

  // Qualifier
  //
  typedef ::Qualifier Qualifier_type;
  typedef ::xsd::cxx::tree::sequence< Qualifier_type > Qualifier_sequence;
  typedef Qualifier_sequence::iterator Qualifier_iterator;
  typedef Qualifier_sequence::const_iterator Qualifier_const_iterator;
  typedef ::xsd::cxx::tree::traits< Qualifier_type, char > Qualifier_traits;

  const Qualifier_sequence&
  Qualifier () const;

  Qualifier_sequence&
  Qualifier ();

  void
  Qualifier (const Qualifier_sequence& s);

  // ParameterValue
  //
  typedef ::ParameterValue ParameterValue_type;
  typedef ::xsd::cxx::tree::sequence< ParameterValue_type > ParameterValue_sequence;
  typedef ParameterValue_sequence::iterator ParameterValue_iterator;
  typedef ParameterValue_sequence::const_iterator ParameterValue_const_iterator;
  typedef ::xsd::cxx::tree::traits< ParameterValue_type, char > ParameterValue_traits;

  const ParameterValue_sequence&
  ParameterValue () const;

  ParameterValue_sequence&
  ParameterValue ();

  void
  ParameterValue (const ParameterValue_sequence& s);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // property
  //
  typedef ::xml_schema::idref property_type;
  typedef ::xsd::cxx::tree::traits< property_type, char > property_traits;

  const property_type&
  property () const;

  property_type&
  property ();

  void
  property (const property_type& x);

  void
  property (::std::auto_ptr< property_type > p);

  // technique
  //
  typedef ::xml_schema::idref technique_type;
  typedef ::xsd::cxx::tree::optional< technique_type > technique_optional;
  typedef ::xsd::cxx::tree::traits< technique_type, char > technique_traits;

  const technique_optional&
  technique () const;

  technique_optional&
  technique ();

  void
  technique (const technique_type& x);

  void
  technique (const technique_optional& x);

  void
  technique (::std::auto_ptr< technique_type > p);

  // source
  //
  typedef ::xml_schema::idref source_type;
  typedef ::xsd::cxx::tree::optional< source_type > source_optional;
  typedef ::xsd::cxx::tree::traits< source_type, char > source_traits;

  const source_optional&
  source () const;

  source_optional&
  source ();

  void
  source (const source_type& x);

  void
  source (const source_optional& x);

  void
  source (::std::auto_ptr< source_type > p);

  // specimen
  //
  typedef ::xml_schema::idref specimen_type;
  typedef ::xsd::cxx::tree::optional< specimen_type > specimen_optional;
  typedef ::xsd::cxx::tree::traits< specimen_type, char > specimen_traits;

  const specimen_optional&
  specimen () const;

  specimen_optional&
  specimen ();

  void
  specimen (const specimen_type& x);

  void
  specimen (const specimen_optional& x);

  void
  specimen (::std::auto_ptr< specimen_type > p);

  // test
  //
  typedef ::xml_schema::idref test_type;
  typedef ::xsd::cxx::tree::optional< test_type > test_optional;
  typedef ::xsd::cxx::tree::traits< test_type, char > test_traits;

  const test_optional&
  test () const;

  test_optional&
  test ();

  void
  test (const test_type& x);

  void
  test (const test_optional& x);

  void
  test (::std::auto_ptr< test_type > p);

  // delimiter
  //
  typedef ::delimiter delimiter_type;
  typedef ::xsd::cxx::tree::traits< delimiter_type, char > delimiter_traits;

  const delimiter_type&
  delimiter () const;

  delimiter_type&
  delimiter ();

  void
  delimiter (const delimiter_type& x);

  void
  delimiter (::std::auto_ptr< delimiter_type > p);

  static const delimiter_type&
  delimiter_default_value ();

  // quote
  //
  typedef ::xml_schema::string quote_type;
  typedef ::xsd::cxx::tree::optional< quote_type > quote_optional;
  typedef ::xsd::cxx::tree::traits< quote_type, char > quote_traits;

  const quote_optional&
  quote () const;

  quote_optional&
  quote ();

  void
  quote (const quote_type& x);

  void
  quote (const quote_optional& x);

  void
  quote (::std::auto_ptr< quote_type > p);

  // Constructors.
  //
  PropertyData (const Data_type&,
                const property_type&);

  PropertyData (::std::auto_ptr< Data_type >,
                const property_type&);

  PropertyData (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  PropertyData (const PropertyData& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual PropertyData*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  PropertyData&
  operator= (const PropertyData& x);

  virtual 
  ~PropertyData ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Data_type > Data_;
  Uncertainty_sequence Uncertainty_;
  Qualifier_sequence Qualifier_;
  ParameterValue_sequence ParameterValue_;
  Notes_optional Notes_;
  ::xsd::cxx::tree::one< property_type > property_;
  technique_optional technique_;
  source_optional source_;
  specimen_optional specimen_;
  test_optional test_;
  ::xsd::cxx::tree::one< delimiter_type > delimiter_;
  static const delimiter_type delimiter_default_value_;
  quote_optional quote_;
};

class Qualifier: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  Qualifier ();

  Qualifier (const char*);

  Qualifier (const ::std::string&);

  Qualifier (const ::xml_schema::string&);

  Qualifier (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  Qualifier (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  Qualifier (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  Qualifier (const Qualifier& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual Qualifier*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Qualifier ();
};

class Relationship: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  Relationship ();

  Relationship (const char*);

  Relationship (const ::std::string&);

  Relationship (const ::xml_schema::string&);

  Relationship (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  Relationship (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  Relationship (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  Relationship (const Relationship& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual Relationship*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Relationship ();
};

class Source: public ::xml_schema::type
{
  public:
  // source
  //
  typedef ::xml_schema::idref source_type;
  typedef ::xsd::cxx::tree::optional< source_type > source_optional;
  typedef ::xsd::cxx::tree::traits< source_type, char > source_traits;

  const source_optional&
  source () const;

  source_optional&
  source ();

  void
  source (const source_type& x);

  void
  source (const source_optional& x);

  void
  source (::std::auto_ptr< source_type > p);

  // Constructors.
  //
  Source ();

  Source (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  Source (const Source& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual Source*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Source&
  operator= (const Source& x);

  virtual 
  ~Source ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  source_optional source_;
};

class Specification: public ::xml_schema::string
{
  public:
  // authority
  //
  typedef ::xml_schema::idref authority_type;
  typedef ::xsd::cxx::tree::optional< authority_type > authority_optional;
  typedef ::xsd::cxx::tree::traits< authority_type, char > authority_traits;

  const authority_optional&
  authority () const;

  authority_optional&
  authority ();

  void
  authority (const authority_type& x);

  void
  authority (const authority_optional& x);

  void
  authority (::std::auto_ptr< authority_type > p);

  // Constructors.
  //
  Specification ();

  Specification (const char*);

  Specification (const ::std::string&);

  Specification (const ::xml_schema::string&);

  Specification (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  Specification (const Specification& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual Specification*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Specification&
  operator= (const Specification& x);

  virtual 
  ~Specification ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  authority_optional authority_;
};

class Uncertainty: public ::xml_schema::type
{
  public:
  // Value
  //
  typedef ::Value Value_type;
  typedef ::xsd::cxx::tree::traits< Value_type, char > Value_traits;

  const Value_type&
  Value () const;

  Value_type&
  Value ();

  void
  Value (const Value_type& x);

  void
  Value (::std::auto_ptr< Value_type > p);

  // Units
  //
  typedef ::Units Units_type;
  typedef ::xsd::cxx::tree::optional< Units_type > Units_optional;
  typedef ::xsd::cxx::tree::traits< Units_type, char > Units_traits;

  const Units_optional&
  Units () const;

  Units_optional&
  Units ();

  void
  Units (const Units_type& x);

  void
  Units (const Units_optional& x);

  void
  Units (::std::auto_ptr< Units_type > p);

  // Unitless
  //
  typedef ::Unitless Unitless_type;
  typedef ::xsd::cxx::tree::optional< Unitless_type > Unitless_optional;
  typedef ::xsd::cxx::tree::traits< Unitless_type, char > Unitless_traits;

  const Unitless_optional&
  Unitless () const;

  Unitless_optional&
  Unitless ();

  void
  Unitless (const Unitless_type& x);

  void
  Unitless (const Unitless_optional& x);

  void
  Unitless (::std::auto_ptr< Unitless_type > p);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // Scale
  //
  typedef ::Scale Scale_type;
  typedef ::xsd::cxx::tree::optional< Scale_type > Scale_optional;
  typedef ::xsd::cxx::tree::traits< Scale_type, char > Scale_traits;

  const Scale_optional&
  Scale () const;

  Scale_optional&
  Scale ();

  void
  Scale (const Scale_type& x);

  void
  Scale (const Scale_optional& x);

  void
  Scale (::std::auto_ptr< Scale_type > p);

  static const Scale_type&
  Scale_default_value ();

  // DistributionType
  //
  typedef ::xml_schema::string DistributionType_type;
  typedef ::xsd::cxx::tree::traits< DistributionType_type, char > DistributionType_traits;

  const DistributionType_type&
  DistributionType () const;

  DistributionType_type&
  DistributionType ();

  void
  DistributionType (const DistributionType_type& x);

  void
  DistributionType (::std::auto_ptr< DistributionType_type > p);

  static const DistributionType_type&
  DistributionType_default_value ();

  // Num_Std_Dev
  //
  typedef ::xml_schema::float_ Num_Std_Dev_type;
  typedef ::xsd::cxx::tree::traits< Num_Std_Dev_type, char > Num_Std_Dev_traits;

  const Num_Std_Dev_type&
  Num_Std_Dev () const;

  Num_Std_Dev_type&
  Num_Std_Dev ();

  void
  Num_Std_Dev (const Num_Std_Dev_type& x);

  static Num_Std_Dev_type
  Num_Std_Dev_default_value ();

  // Percentile
  //
  typedef ::xml_schema::float_ Percentile_type;
  typedef ::xsd::cxx::tree::optional< Percentile_type > Percentile_optional;
  typedef ::xsd::cxx::tree::traits< Percentile_type, char > Percentile_traits;

  const Percentile_optional&
  Percentile () const;

  Percentile_optional&
  Percentile ();

  void
  Percentile (const Percentile_type& x);

  void
  Percentile (const Percentile_optional& x);

  // ConfidenceLevel
  //
  typedef ::xml_schema::float_ ConfidenceLevel_type;
  typedef ::xsd::cxx::tree::optional< ConfidenceLevel_type > ConfidenceLevel_optional;
  typedef ::xsd::cxx::tree::traits< ConfidenceLevel_type, char > ConfidenceLevel_traits;

  const ConfidenceLevel_optional&
  ConfidenceLevel () const;

  ConfidenceLevel_optional&
  ConfidenceLevel ();

  void
  ConfidenceLevel (const ConfidenceLevel_type& x);

  void
  ConfidenceLevel (const ConfidenceLevel_optional& x);

  // Constructors.
  //
  Uncertainty (const Value_type&);

  Uncertainty (::std::auto_ptr< Value_type >);

  Uncertainty (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  Uncertainty (const Uncertainty& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual Uncertainty*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Uncertainty&
  operator= (const Uncertainty& x);

  virtual 
  ~Uncertainty ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Value_type > Value_;
  Units_optional Units_;
  Unitless_optional Unitless_;
  Notes_optional Notes_;
  Scale_optional Scale_;
  static const Scale_type Scale_default_value_;
  ::xsd::cxx::tree::one< DistributionType_type > DistributionType_;
  static const DistributionType_type DistributionType_default_value_;
  ::xsd::cxx::tree::one< Num_Std_Dev_type > Num_Std_Dev_;
  Percentile_optional Percentile_;
  ConfidenceLevel_optional ConfidenceLevel_;
};

class Unit: public ::xml_schema::type
{
  public:
  // Name
  //
  typedef ::xml_schema::string Name_type;
  typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_optional&
  Name () const;

  Name_optional&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (const Name_optional& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // Currency
  //
  typedef ::CurrencyCode Currency_type;
  typedef ::xsd::cxx::tree::optional< Currency_type > Currency_optional;
  typedef ::xsd::cxx::tree::traits< Currency_type, char > Currency_traits;

  const Currency_optional&
  Currency () const;

  Currency_optional&
  Currency ();

  void
  Currency (const Currency_type& x);

  void
  Currency (const Currency_optional& x);

  void
  Currency (::std::auto_ptr< Currency_type > p);

  // power
  //
  typedef ::xml_schema::decimal power_type;
  typedef ::xsd::cxx::tree::optional< power_type > power_optional;
  typedef ::xsd::cxx::tree::traits< power_type, char, ::xsd::cxx::tree::schema_type::decimal > power_traits;

  const power_optional&
  power () const;

  power_optional&
  power ();

  void
  power (const power_type& x);

  void
  power (const power_optional& x);

  // description
  //
  typedef ::xml_schema::string description_type;
  typedef ::xsd::cxx::tree::optional< description_type > description_optional;
  typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

  const description_optional&
  description () const;

  description_optional&
  description ();

  void
  description (const description_type& x);

  void
  description (const description_optional& x);

  void
  description (::std::auto_ptr< description_type > p);

  // Constructors.
  //
  Unit ();

  Unit (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  Unit (const Unit& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual Unit*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Unit&
  operator= (const Unit& x);

  virtual 
  ~Unit ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Name_optional Name_;
  Currency_optional Currency_;
  power_optional power_;
  description_optional description_;
};

class Unitless: public ::xml_schema::type
{
  public:
  // Constructors.
  //
  Unitless ();

  Unitless (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  Unitless (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  Unitless (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  Unitless (const Unitless& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual Unitless*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Unitless ();
};

class Units: public ::xml_schema::type
{
  public:
  // Unit
  //
  typedef ::Unit Unit_type;
  typedef ::xsd::cxx::tree::sequence< Unit_type > Unit_sequence;
  typedef Unit_sequence::iterator Unit_iterator;
  typedef Unit_sequence::const_iterator Unit_const_iterator;
  typedef ::xsd::cxx::tree::traits< Unit_type, char > Unit_traits;

  const Unit_sequence&
  Unit () const;

  Unit_sequence&
  Unit ();

  void
  Unit (const Unit_sequence& s);

  // system
  //
  typedef ::xml_schema::string system_type;
  typedef ::xsd::cxx::tree::optional< system_type > system_optional;
  typedef ::xsd::cxx::tree::traits< system_type, char > system_traits;

  const system_optional&
  system () const;

  system_optional&
  system ();

  void
  system (const system_type& x);

  void
  system (const system_optional& x);

  void
  system (::std::auto_ptr< system_type > p);

  // factor
  //
  typedef ::xml_schema::float_ factor_type;
  typedef ::xsd::cxx::tree::optional< factor_type > factor_optional;
  typedef ::xsd::cxx::tree::traits< factor_type, char > factor_traits;

  const factor_optional&
  factor () const;

  factor_optional&
  factor ();

  void
  factor (const factor_type& x);

  void
  factor (const factor_optional& x);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::auto_ptr< name_type > p);

  // description
  //
  typedef ::xml_schema::string description_type;
  typedef ::xsd::cxx::tree::optional< description_type > description_optional;
  typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

  const description_optional&
  description () const;

  description_optional&
  description ();

  void
  description (const description_type& x);

  void
  description (const description_optional& x);

  void
  description (::std::auto_ptr< description_type > p);

  // Constructors.
  //
  Units ();

  Units (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  Units (const Units& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual Units*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Units&
  operator= (const Units& x);

  virtual 
  ~Units ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Unit_sequence Unit_;
  system_optional system_;
  factor_optional factor_;
  name_optional name_;
  description_optional description_;
};

class Value: public ::xml_schema::string
{
  public:
  // format
  //
  typedef ::DataFormat format_type;
  typedef ::xsd::cxx::tree::traits< format_type, char > format_traits;

  const format_type&
  format () const;

  format_type&
  format ();

  void
  format (const format_type& x);

  void
  format (::std::auto_ptr< format_type > p);

  // Constructors.
  //
  Value (const format_type&);

  Value (const char*,
         const format_type&);

  Value (const ::std::string&,
         const format_type&);

  Value (const ::xml_schema::string&,
         const format_type&);

  Value (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  Value (const Value& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual Value*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Value&
  operator= (const Value& x);

  virtual 
  ~Value ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< format_type > format_;
};

class AuthorityDetails: public ::xml_schema::type
{
  public:
  // Name
  //
  typedef ::Name Name_type;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_type&
  Name () const;

  Name_type&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // id
  //
  typedef ::xml_schema::id id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // Constructors.
  //
  AuthorityDetails (const Name_type&,
                    const id_type&);

  AuthorityDetails (::std::auto_ptr< Name_type >,
                    const id_type&);

  AuthorityDetails (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  AuthorityDetails (const AuthorityDetails& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual AuthorityDetails*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  AuthorityDetails&
  operator= (const AuthorityDetails& x);

  virtual 
  ~AuthorityDetails ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Name_type > Name_;
  Notes_optional Notes_;
  ::xsd::cxx::tree::one< id_type > id_;
};

class DataSourceDetails: public ::xml_schema::type
{
  public:
  // Name
  //
  typedef ::Name Name_type;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_type&
  Name () const;

  Name_type&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // id
  //
  typedef ::xml_schema::id id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // type
  //
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::auto_ptr< type_type > p);

  // Constructors.
  //
  DataSourceDetails (const Name_type&,
                     const id_type&);

  DataSourceDetails (::std::auto_ptr< Name_type >,
                     const id_type&);

  DataSourceDetails (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  DataSourceDetails (const DataSourceDetails& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual DataSourceDetails*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  DataSourceDetails&
  operator= (const DataSourceDetails& x);

  virtual 
  ~DataSourceDetails ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Name_type > Name_;
  Notes_optional Notes_;
  ::xsd::cxx::tree::one< id_type > id_;
  type_optional type_;
};

class MeasurementTechniqueDetails: public ::xml_schema::type
{
  public:
  // Name
  //
  typedef ::Name Name_type;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_type&
  Name () const;

  Name_type&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // id
  //
  typedef ::xml_schema::id id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // Constructors.
  //
  MeasurementTechniqueDetails (const Name_type&,
                               const id_type&);

  MeasurementTechniqueDetails (::std::auto_ptr< Name_type >,
                               const id_type&);

  MeasurementTechniqueDetails (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  MeasurementTechniqueDetails (const MeasurementTechniqueDetails& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  virtual MeasurementTechniqueDetails*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  MeasurementTechniqueDetails&
  operator= (const MeasurementTechniqueDetails& x);

  virtual 
  ~MeasurementTechniqueDetails ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Name_type > Name_;
  Notes_optional Notes_;
  ::xsd::cxx::tree::one< id_type > id_;
};

class ParameterDetails: public ::xml_schema::type
{
  public:
  // Name
  //
  typedef ::Name Name_type;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_type&
  Name () const;

  Name_type&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // Units
  //
  typedef ::Units Units_type;
  typedef ::xsd::cxx::tree::optional< Units_type > Units_optional;
  typedef ::xsd::cxx::tree::traits< Units_type, char > Units_traits;

  const Units_optional&
  Units () const;

  Units_optional&
  Units ();

  void
  Units (const Units_type& x);

  void
  Units (const Units_optional& x);

  void
  Units (::std::auto_ptr< Units_type > p);

  // Unitless
  //
  typedef ::Unitless Unitless_type;
  typedef ::xsd::cxx::tree::optional< Unitless_type > Unitless_optional;
  typedef ::xsd::cxx::tree::traits< Unitless_type, char > Unitless_traits;

  const Unitless_optional&
  Unitless () const;

  Unitless_optional&
  Unitless ();

  void
  Unitless (const Unitless_type& x);

  void
  Unitless (const Unitless_optional& x);

  void
  Unitless (::std::auto_ptr< Unitless_type > p);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // id
  //
  typedef ::xml_schema::id id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // Constructors.
  //
  ParameterDetails (const Name_type&,
                    const id_type&);

  ParameterDetails (::std::auto_ptr< Name_type >,
                    const id_type&);

  ParameterDetails (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  ParameterDetails (const ParameterDetails& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual ParameterDetails*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ParameterDetails&
  operator= (const ParameterDetails& x);

  virtual 
  ~ParameterDetails ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Name_type > Name_;
  Units_optional Units_;
  Unitless_optional Unitless_;
  Notes_optional Notes_;
  ::xsd::cxx::tree::one< id_type > id_;
};

class PropertyDetails: public ::xml_schema::type
{
  public:
  // Name
  //
  typedef ::Name Name_type;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_type&
  Name () const;

  Name_type&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // Units
  //
  typedef ::Units Units_type;
  typedef ::xsd::cxx::tree::optional< Units_type > Units_optional;
  typedef ::xsd::cxx::tree::traits< Units_type, char > Units_traits;

  const Units_optional&
  Units () const;

  Units_optional&
  Units ();

  void
  Units (const Units_type& x);

  void
  Units (const Units_optional& x);

  void
  Units (::std::auto_ptr< Units_type > p);

  // Unitless
  //
  typedef ::Unitless Unitless_type;
  typedef ::xsd::cxx::tree::optional< Unitless_type > Unitless_optional;
  typedef ::xsd::cxx::tree::traits< Unitless_type, char > Unitless_traits;

  const Unitless_optional&
  Unitless () const;

  Unitless_optional&
  Unitless ();

  void
  Unitless (const Unitless_type& x);

  void
  Unitless (const Unitless_optional& x);

  void
  Unitless (::std::auto_ptr< Unitless_type > p);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // id
  //
  typedef ::xml_schema::id id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // type
  //
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::auto_ptr< type_type > p);

  // Constructors.
  //
  PropertyDetails (const Name_type&,
                   const id_type&);

  PropertyDetails (::std::auto_ptr< Name_type >,
                   const id_type&);

  PropertyDetails (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  PropertyDetails (const PropertyDetails& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual PropertyDetails*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  PropertyDetails&
  operator= (const PropertyDetails& x);

  virtual 
  ~PropertyDetails ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Name_type > Name_;
  Units_optional Units_;
  Unitless_optional Unitless_;
  Notes_optional Notes_;
  ::xsd::cxx::tree::one< id_type > id_;
  type_optional type_;
};

class SourceDetails: public ::xml_schema::type
{
  public:
  // Name
  //
  typedef ::Name Name_type;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_type&
  Name () const;

  Name_type&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // id
  //
  typedef ::xml_schema::id id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // type
  //
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::auto_ptr< type_type > p);

  // Constructors.
  //
  SourceDetails (const Name_type&,
                 const id_type&);

  SourceDetails (::std::auto_ptr< Name_type >,
                 const id_type&);

  SourceDetails (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  SourceDetails (const SourceDetails& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual SourceDetails*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  SourceDetails&
  operator= (const SourceDetails& x);

  virtual 
  ~SourceDetails ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Name_type > Name_;
  Notes_optional Notes_;
  ::xsd::cxx::tree::one< id_type > id_;
  type_optional type_;
};

class SpecimenDetails: public ::xml_schema::type
{
  public:
  // Name
  //
  typedef ::Name Name_type;
  typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_optional&
  Name () const;

  Name_optional&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (const Name_optional& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // Geometry
  //
  typedef ::Geometry Geometry_type;
  typedef ::xsd::cxx::tree::optional< Geometry_type > Geometry_optional;
  typedef ::xsd::cxx::tree::traits< Geometry_type, char > Geometry_traits;

  const Geometry_optional&
  Geometry () const;

  Geometry_optional&
  Geometry ();

  void
  Geometry (const Geometry_type& x);

  void
  Geometry (const Geometry_optional& x);

  void
  Geometry (::std::auto_ptr< Geometry_type > p);

  // id
  //
  typedef ::xml_schema::id id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // type
  //
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::auto_ptr< type_type > p);

  // Constructors.
  //
  SpecimenDetails (const id_type&);

  SpecimenDetails (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  SpecimenDetails (const SpecimenDetails& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual SpecimenDetails*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  SpecimenDetails&
  operator= (const SpecimenDetails& x);

  virtual 
  ~SpecimenDetails ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Name_optional Name_;
  Notes_optional Notes_;
  Geometry_optional Geometry_;
  ::xsd::cxx::tree::one< id_type > id_;
  type_optional type_;
};

class TestConditionDetails: public ::xml_schema::type
{
  public:
  // ParameterValue
  //
  typedef ::ParameterValue ParameterValue_type;
  typedef ::xsd::cxx::tree::sequence< ParameterValue_type > ParameterValue_sequence;
  typedef ParameterValue_sequence::iterator ParameterValue_iterator;
  typedef ParameterValue_sequence::const_iterator ParameterValue_const_iterator;
  typedef ::xsd::cxx::tree::traits< ParameterValue_type, char > ParameterValue_traits;

  const ParameterValue_sequence&
  ParameterValue () const;

  ParameterValue_sequence&
  ParameterValue ();

  void
  ParameterValue (const ParameterValue_sequence& s);

  // Notes
  //
  typedef ::Notes Notes_type;
  typedef ::xsd::cxx::tree::optional< Notes_type > Notes_optional;
  typedef ::xsd::cxx::tree::traits< Notes_type, char > Notes_traits;

  const Notes_optional&
  Notes () const;

  Notes_optional&
  Notes ();

  void
  Notes (const Notes_type& x);

  void
  Notes (const Notes_optional& x);

  void
  Notes (::std::auto_ptr< Notes_type > p);

  // id
  //
  typedef ::xml_schema::id id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // Constructors.
  //
  TestConditionDetails (const id_type&);

  TestConditionDetails (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  TestConditionDetails (const TestConditionDetails& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual TestConditionDetails*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  TestConditionDetails&
  operator= (const TestConditionDetails& x);

  virtual 
  ~TestConditionDetails ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ParameterValue_sequence ParameterValue_;
  Notes_optional Notes_;
  ::xsd::cxx::tree::one< id_type > id_;
};

class ChemicalElementSymbol: public ::xml_schema::string
{
  public:
  enum value
  {
    H,
    He,
    Li,
    Be,
    B,
    C,
    N,
    O,
    F,
    Ne,
    Na,
    Mg,
    Al,
    Si,
    P,
    S,
    Cl,
    Ar,
    K,
    Ca,
    Sc,
    Ti,
    V,
    Cr,
    Mn,
    Fe,
    Co,
    Ni,
    Cu,
    Zn,
    Ga,
    Ge,
    As,
    Se,
    Br,
    Kr,
    Rb,
    Sr,
    Y,
    Zr,
    Nb,
    Mo,
    Tc,
    Ru,
    Rh,
    Pd,
    Ag,
    Cd,
    In,
    Sn,
    Sb,
    Te,
    I,
    Xe,
    Cs,
    Ba,
    La,
    Ce,
    Pr,
    Nd,
    Pm,
    Sm,
    Eu,
    Gd,
    Tb,
    Dy,
    Ho,
    Er,
    Tm,
    Yb,
    Lu,
    Hf,
    Ta,
    W,
    Re,
    Os,
    Ir,
    Pt,
    Au,
    Hg,
    Tl,
    Pb,
    Bi,
    Po,
    At,
    Rn,
    Fr,
    Ra,
    Ac,
    Th,
    Pa,
    U,
    Np,
    Pu,
    Am,
    Cm,
    Bk,
    Cf,
    Es,
    Fm,
    Md,
    No,
    Lr,
    Rf,
    Db,
    Sg,
    Bh,
    Hs,
    Mt,
    Uun,
    Uuu,
    Uub,
    Uuq,
    Uuh,
    Uuo
  };

  ChemicalElementSymbol (value v);

  ChemicalElementSymbol (const char* v);

  ChemicalElementSymbol (const ::std::string& v);

  ChemicalElementSymbol (const ::xml_schema::string& v);

  ChemicalElementSymbol (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  ChemicalElementSymbol (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  ChemicalElementSymbol (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  ChemicalElementSymbol (const ChemicalElementSymbol& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual ChemicalElementSymbol*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ChemicalElementSymbol&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_ChemicalElementSymbol_convert ();
  }

  protected:
  value
  _xsd_ChemicalElementSymbol_convert () const;

  public:
  static const char* const _xsd_ChemicalElementSymbol_literals_[115];
  static const value _xsd_ChemicalElementSymbol_indexes_[115];
};

class CurrencyCode: public ::xml_schema::string
{
  public:
  enum value
  {
    AFA,
    ALL,
    AMD,
    ANG,
    AOA,
    ARS,
    ATS,
    AUD,
    AWG,
    AZM,
    BAM,
    BBD,
    BDT,
    BEF,
    BGL,
    BGN,
    BHD,
    BIF,
    BMD,
    BND,
    BOB,
    BOV,
    BRL,
    BSD,
    BTN,
    BWP,
    BYB,
    BYR,
    BZD,
    CAD,
    CDF,
    CHF,
    CLF,
    CLP,
    CNY,
    COP,
    CRC,
    CUP,
    CVE,
    CYP,
    CZK,
    DEM,
    DJF,
    DKK,
    DOP,
    DZD,
    EEK,
    EGP,
    ERN,
    ESP,
    ETB,
    EUR,
    FIM,
    FJD,
    FKP,
    FRF,
    GBP,
    GEL,
    GHC,
    GIP,
    GMD,
    GNF,
    GRD,
    GTQ,
    GWP,
    GYD,
    HKD,
    HNL,
    HRK,
    HTG,
    HUF,
    IDR,
    IEP,
    ILS,
    INR,
    IQD,
    IRR,
    ISK,
    ITL,
    JMD,
    JOD,
    JPY,
    KES,
    KGS,
    KHR,
    KMF,
    KPW,
    KRW,
    KWD,
    KYD,
    KZT,
    LAK,
    LBP,
    LKR,
    LRD,
    LSL,
    LTL,
    LUF,
    LVL,
    LYD,
    MAD,
    MDL,
    MGF,
    MKD,
    MMK,
    MNT,
    MOP,
    MRO,
    MTL,
    MUR,
    MVR,
    MWK,
    MXN,
    MXV,
    MYR,
    MZM,
    NAD,
    NGN,
    NIO,
    NLG,
    NOK,
    NPR,
    NZD,
    OMR,
    PAB,
    PEN,
    PGK,
    PHP,
    PKR,
    PLN,
    PTE,
    PYG,
    QAR,
    ROL,
    RUB,
    RUR,
    RWF,
    SAR,
    SBD,
    SCR,
    SDD,
    SEK,
    SGD,
    SHP,
    SIT,
    SKK,
    SLL,
    SOS,
    SRG,
    STD,
    SVC,
    SYP,
    SZL,
    THB,
    TJR,
    TMM,
    TND,
    TOP,
    TPE,
    TRL,
    TTD,
    TWD,
    TZS,
    UAH,
    UGX,
    USD,
    UYU,
    UZS,
    VEB,
    VND,
    VUV,
    WST,
    XAF,
    XCD,
    XDR,
    XOF,
    XPF,
    YER,
    YUM,
    ZAR,
    ZMK,
    ZWD
  };

  CurrencyCode (value v);

  CurrencyCode (const char* v);

  CurrencyCode (const ::std::string& v);

  CurrencyCode (const ::xml_schema::string& v);

  CurrencyCode (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  CurrencyCode (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  CurrencyCode (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  CurrencyCode (const CurrencyCode& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual CurrencyCode*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  CurrencyCode&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_CurrencyCode_convert ();
  }

  protected:
  value
  _xsd_CurrencyCode_convert () const;

  public:
  static const char* const _xsd_CurrencyCode_literals_[182];
  static const value _xsd_CurrencyCode_indexes_[182];
};

class MatML_Doc: public ::xml_schema::type
{
  public:
  // Material
  //
  typedef ::Material Material_type;
  typedef ::xsd::cxx::tree::sequence< Material_type > Material_sequence;
  typedef Material_sequence::iterator Material_iterator;
  typedef Material_sequence::const_iterator Material_const_iterator;
  typedef ::xsd::cxx::tree::traits< Material_type, char > Material_traits;

  const Material_sequence&
  Material () const;

  Material_sequence&
  Material ();

  void
  Material (const Material_sequence& s);

  // Metadata
  //
  typedef ::Metadata Metadata_type;
  typedef ::xsd::cxx::tree::optional< Metadata_type > Metadata_optional;
  typedef ::xsd::cxx::tree::traits< Metadata_type, char > Metadata_traits;

  const Metadata_optional&
  Metadata () const;

  Metadata_optional&
  Metadata ();

  void
  Metadata (const Metadata_type& x);

  void
  Metadata (const Metadata_optional& x);

  void
  Metadata (::std::auto_ptr< Metadata_type > p);

  // Constructors.
  //
  MatML_Doc ();

  MatML_Doc (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  MatML_Doc (const MatML_Doc& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual MatML_Doc*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  MatML_Doc&
  operator= (const MatML_Doc& x);

  virtual 
  ~MatML_Doc ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Material_sequence Material_;
  Metadata_optional Metadata_;
};

class ParentMaterial: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::idref id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // Constructors.
  //
  ParentMaterial (const id_type&);

  ParentMaterial (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  ParentMaterial (const ParentMaterial& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual ParentMaterial*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ParentMaterial&
  operator= (const ParentMaterial& x);

  virtual 
  ~ParentMaterial ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< id_type > id_;
};

class Symbol: public ::ChemicalElementSymbol
{
  public:
  // subscript
  //
  typedef ::xml_schema::string subscript_type;
  typedef ::xsd::cxx::tree::traits< subscript_type, char > subscript_traits;

  const subscript_type&
  subscript () const;

  subscript_type&
  subscript ();

  void
  subscript (const subscript_type& x);

  void
  subscript (::std::auto_ptr< subscript_type > p);

  static const subscript_type&
  subscript_default_value ();

  // Constructors.
  //
  Symbol (::ChemicalElementSymbol::value);

  Symbol (const char*);

  Symbol (const ::std::string&);

  Symbol (const ::ChemicalElementSymbol&);

  Symbol (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  Symbol (const Symbol& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual Symbol*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Symbol&
  operator= (const Symbol& x);

  virtual 
  ~Symbol ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< subscript_type > subscript_;
  static const subscript_type subscript_default_value_;
};

class Graph: public ::xml_schema::type
{
  public:
  // Constructors.
  //
  Graph ();

  Graph (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  Graph (const Graph& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual Graph*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Graph ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
};

class Data: public ::xml_schema::string
{
  public:
  // format
  //
  typedef ::DataFormat format_type;
  typedef ::xsd::cxx::tree::optional< format_type > format_optional;
  typedef ::xsd::cxx::tree::traits< format_type, char > format_traits;

  const format_optional&
  format () const;

  format_optional&
  format ();

  void
  format (const format_type& x);

  void
  format (const format_optional& x);

  void
  format (::std::auto_ptr< format_type > p);

  // Constructors.
  //
  Data ();

  Data (const char*);

  Data (const ::std::string&);

  Data (const ::xml_schema::string&);

  Data (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  Data (const Data& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual Data*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Data&
  operator= (const Data& x);

  virtual 
  ~Data ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  format_optional format_;
};

class Data1: public ::xml_schema::string
{
  public:
  // format
  //
  typedef ::DataFormat format_type;
  typedef ::xsd::cxx::tree::traits< format_type, char > format_traits;

  const format_type&
  format () const;

  format_type&
  format ();

  void
  format (const format_type& x);

  void
  format (::std::auto_ptr< format_type > p);

  // Constructors.
  //
  Data1 (const format_type&);

  Data1 (const char*,
         const format_type&);

  Data1 (const ::std::string&,
         const format_type&);

  Data1 (const ::xml_schema::string&,
         const format_type&);

  Data1 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  Data1 (const Data1& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual Data1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Data1&
  operator= (const Data1& x);

  virtual 
  ~Data1 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< format_type > format_;
};

class delimiter: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  delimiter ();

  delimiter (const char*);

  delimiter (const ::std::string&);

  delimiter (const ::xml_schema::string&);

  delimiter (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  delimiter (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  delimiter (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  delimiter (const delimiter& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual delimiter*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~delimiter ();
};

class Scale: public ::xml_schema::string
{
  public:
  enum value
  {
    Linear,
    Logarithmic
  };

  Scale (value v);

  Scale (const char* v);

  Scale (const ::std::string& v);

  Scale (const ::xml_schema::string& v);

  Scale (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  Scale (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  Scale (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  Scale (const Scale& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual Scale*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Scale&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_Scale_convert ();
  }

  protected:
  value
  _xsd_Scale_convert () const;

  public:
  static const char* const _xsd_Scale_literals_[2];
  static const value _xsd_Scale_indexes_[2];
};

#include <iosfwd>

::std::ostream&
operator<< (::std::ostream&, const Associate&);

::std::ostream&
operator<< (::std::ostream&, const AssociationDetails&);

::std::ostream&
operator<< (::std::ostream&, const BulkDetails&);

::std::ostream&
operator<< (::std::ostream&, const Characterization&);

::std::ostream&
operator<< (::std::ostream&, const ChemicalComposition&);

::std::ostream&
operator<< (::std::ostream&, const Class&);

::std::ostream&
operator<< (::std::ostream&, const ComponentDetails&);

::std::ostream&
operator<< (::std::ostream&, const Compound&);

::std::ostream&
operator<< (::std::ostream&, const Concentration&);

::std::ostream&
operator<< (::std::ostream&, DataFormat::value);

::std::ostream&
operator<< (::std::ostream&, const DataFormat&);

::std::ostream&
operator<< (::std::ostream&, const DimensionalDetails&);

::std::ostream&
operator<< (::std::ostream&, const Element&);

::std::ostream&
operator<< (::std::ostream&, const Form&);

::std::ostream&
operator<< (::std::ostream&, const Formula&);

::std::ostream&
operator<< (::std::ostream&, const Geometry&);

::std::ostream&
operator<< (::std::ostream&, const Glossary&);

::std::ostream&
operator<< (::std::ostream&, const GlossaryTerm&);

::std::ostream&
operator<< (::std::ostream&, const Graphs&);

::std::ostream&
operator<< (::std::ostream&, const Material&);

::std::ostream&
operator<< (::std::ostream&, const Metadata&);

::std::ostream&
operator<< (::std::ostream&, const Name&);

::std::ostream&
operator<< (::std::ostream&, const Notes&);

::std::ostream&
operator<< (::std::ostream&, const ParameterValue&);

::std::ostream&
operator<< (::std::ostream&, const PhaseComposition&);

::std::ostream&
operator<< (::std::ostream&, const ProcessingDetails&);

::std::ostream&
operator<< (::std::ostream&, const PropertyData&);

::std::ostream&
operator<< (::std::ostream&, const Qualifier&);

::std::ostream&
operator<< (::std::ostream&, const Relationship&);

::std::ostream&
operator<< (::std::ostream&, const Source&);

::std::ostream&
operator<< (::std::ostream&, const Specification&);

::std::ostream&
operator<< (::std::ostream&, const Uncertainty&);

::std::ostream&
operator<< (::std::ostream&, const Unit&);

::std::ostream&
operator<< (::std::ostream&, const Unitless&);

::std::ostream&
operator<< (::std::ostream&, const Units&);

::std::ostream&
operator<< (::std::ostream&, const Value&);

::std::ostream&
operator<< (::std::ostream&, const AuthorityDetails&);

::std::ostream&
operator<< (::std::ostream&, const DataSourceDetails&);

::std::ostream&
operator<< (::std::ostream&, const MeasurementTechniqueDetails&);

::std::ostream&
operator<< (::std::ostream&, const ParameterDetails&);

::std::ostream&
operator<< (::std::ostream&, const PropertyDetails&);

::std::ostream&
operator<< (::std::ostream&, const SourceDetails&);

::std::ostream&
operator<< (::std::ostream&, const SpecimenDetails&);

::std::ostream&
operator<< (::std::ostream&, const TestConditionDetails&);

::std::ostream&
operator<< (::std::ostream&, ChemicalElementSymbol::value);

::std::ostream&
operator<< (::std::ostream&, const ChemicalElementSymbol&);

::std::ostream&
operator<< (::std::ostream&, CurrencyCode::value);

::std::ostream&
operator<< (::std::ostream&, const CurrencyCode&);

::std::ostream&
operator<< (::std::ostream&, const MatML_Doc&);

::std::ostream&
operator<< (::std::ostream&, const ParentMaterial&);

::std::ostream&
operator<< (::std::ostream&, const Symbol&);

::std::ostream&
operator<< (::std::ostream&, const Graph&);

::std::ostream&
operator<< (::std::ostream&, const Data&);

::std::ostream&
operator<< (::std::ostream&, const Data1&);

::std::ostream&
operator<< (::std::ostream&, const delimiter&);

::std::ostream&
operator<< (::std::ostream&, Scale::value);

::std::ostream&
operator<< (::std::ostream&, const Scale&);

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::MatML_Doc >
MatML_Doc_ (const ::std::string& uri,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::MatML_Doc >
MatML_Doc_ (const ::std::string& uri,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::MatML_Doc >
MatML_Doc_ (const ::std::string& uri,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::MatML_Doc >
MatML_Doc_ (::std::istream& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::MatML_Doc >
MatML_Doc_ (::std::istream& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::MatML_Doc >
MatML_Doc_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::MatML_Doc >
MatML_Doc_ (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::MatML_Doc >
MatML_Doc_ (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::MatML_Doc >
MatML_Doc_ (::std::istream& is,
            const ::std::string& id,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::MatML_Doc >
MatML_Doc_ (::xercesc::InputSource& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::MatML_Doc >
MatML_Doc_ (::xercesc::InputSource& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::MatML_Doc >
MatML_Doc_ (::xercesc::InputSource& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::MatML_Doc >
MatML_Doc_ (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::MatML_Doc >
MatML_Doc_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

// Serialize to std::ostream.
//

void
MatML_Doc_ (::std::ostream& os,
            const ::MatML_Doc& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

void
MatML_Doc_ (::std::ostream& os,
            const ::MatML_Doc& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

void
MatML_Doc_ (::std::ostream& os,
            const ::MatML_Doc& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
MatML_Doc_ (::xercesc::XMLFormatTarget& ft,
            const ::MatML_Doc& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

void
MatML_Doc_ (::xercesc::XMLFormatTarget& ft,
            const ::MatML_Doc& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

void
MatML_Doc_ (::xercesc::XMLFormatTarget& ft,
            const ::MatML_Doc& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
MatML_Doc_ (::xercesc::DOMDocument& d,
            const ::MatML_Doc& x,
            ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
MatML_Doc_ (const ::MatML_Doc& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            ::xml_schema::flags f = 0);

void
operator<< (::xercesc::DOMElement&, const Associate&);

void
operator<< (::xercesc::DOMAttr&, const Associate&);

void
operator<< (::xml_schema::list_stream&,
            const Associate&);

void
operator<< (::xercesc::DOMElement&, const AssociationDetails&);

void
operator<< (::xercesc::DOMElement&, const BulkDetails&);

void
operator<< (::xercesc::DOMElement&, const Characterization&);

void
operator<< (::xercesc::DOMElement&, const ChemicalComposition&);

void
operator<< (::xercesc::DOMElement&, const Class&);

void
operator<< (::xercesc::DOMElement&, const ComponentDetails&);

void
operator<< (::xercesc::DOMElement&, const Compound&);

void
operator<< (::xercesc::DOMElement&, const Concentration&);

void
operator<< (::xercesc::DOMElement&, const DataFormat&);

void
operator<< (::xercesc::DOMAttr&, const DataFormat&);

void
operator<< (::xml_schema::list_stream&,
            const DataFormat&);

void
operator<< (::xercesc::DOMElement&, const DimensionalDetails&);

void
operator<< (::xercesc::DOMElement&, const Element&);

void
operator<< (::xercesc::DOMElement&, const Form&);

void
operator<< (::xercesc::DOMElement&, const Formula&);

void
operator<< (::xercesc::DOMAttr&, const Formula&);

void
operator<< (::xml_schema::list_stream&,
            const Formula&);

void
operator<< (::xercesc::DOMElement&, const Geometry&);

void
operator<< (::xercesc::DOMElement&, const Glossary&);

void
operator<< (::xercesc::DOMElement&, const GlossaryTerm&);

void
operator<< (::xercesc::DOMElement&, const Graphs&);

void
operator<< (::xercesc::DOMElement&, const Material&);

void
operator<< (::xercesc::DOMElement&, const Metadata&);

void
operator<< (::xercesc::DOMElement&, const Name&);

void
operator<< (::xercesc::DOMElement&, const Notes&);

void
operator<< (::xercesc::DOMAttr&, const Notes&);

void
operator<< (::xml_schema::list_stream&,
            const Notes&);

void
operator<< (::xercesc::DOMElement&, const ParameterValue&);

void
operator<< (::xercesc::DOMElement&, const PhaseComposition&);

void
operator<< (::xercesc::DOMElement&, const ProcessingDetails&);

void
operator<< (::xercesc::DOMElement&, const PropertyData&);

void
operator<< (::xercesc::DOMElement&, const Qualifier&);

void
operator<< (::xercesc::DOMAttr&, const Qualifier&);

void
operator<< (::xml_schema::list_stream&,
            const Qualifier&);

void
operator<< (::xercesc::DOMElement&, const Relationship&);

void
operator<< (::xercesc::DOMAttr&, const Relationship&);

void
operator<< (::xml_schema::list_stream&,
            const Relationship&);

void
operator<< (::xercesc::DOMElement&, const Source&);

void
operator<< (::xercesc::DOMElement&, const Specification&);

void
operator<< (::xercesc::DOMElement&, const Uncertainty&);

void
operator<< (::xercesc::DOMElement&, const Unit&);

void
operator<< (::xercesc::DOMElement&, const Unitless&);

void
operator<< (::xercesc::DOMAttr&, const Unitless&);

void
operator<< (::xml_schema::list_stream&,
            const Unitless&);

void
operator<< (::xercesc::DOMElement&, const Units&);

void
operator<< (::xercesc::DOMElement&, const Value&);

void
operator<< (::xercesc::DOMElement&, const AuthorityDetails&);

void
operator<< (::xercesc::DOMElement&, const DataSourceDetails&);

void
operator<< (::xercesc::DOMElement&, const MeasurementTechniqueDetails&);

void
operator<< (::xercesc::DOMElement&, const ParameterDetails&);

void
operator<< (::xercesc::DOMElement&, const PropertyDetails&);

void
operator<< (::xercesc::DOMElement&, const SourceDetails&);

void
operator<< (::xercesc::DOMElement&, const SpecimenDetails&);

void
operator<< (::xercesc::DOMElement&, const TestConditionDetails&);

void
operator<< (::xercesc::DOMElement&, const ChemicalElementSymbol&);

void
operator<< (::xercesc::DOMAttr&, const ChemicalElementSymbol&);

void
operator<< (::xml_schema::list_stream&,
            const ChemicalElementSymbol&);

void
operator<< (::xercesc::DOMElement&, const CurrencyCode&);

void
operator<< (::xercesc::DOMAttr&, const CurrencyCode&);

void
operator<< (::xml_schema::list_stream&,
            const CurrencyCode&);

void
operator<< (::xercesc::DOMElement&, const MatML_Doc&);

void
operator<< (::xercesc::DOMElement&, const ParentMaterial&);

void
operator<< (::xercesc::DOMElement&, const Symbol&);

void
operator<< (::xercesc::DOMElement&, const Graph&);

void
operator<< (::xercesc::DOMElement&, const Data&);

void
operator<< (::xercesc::DOMElement&, const Data1&);

void
operator<< (::xercesc::DOMElement&, const delimiter&);

void
operator<< (::xercesc::DOMAttr&, const delimiter&);

void
operator<< (::xml_schema::list_stream&,
            const delimiter&);

void
operator<< (::xercesc::DOMElement&, const Scale&);

void
operator<< (::xercesc::DOMAttr&, const Scale&);

void
operator<< (::xml_schema::list_stream&,
            const Scale&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // MATML31_HXX
