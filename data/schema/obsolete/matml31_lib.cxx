// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "matml31_lib.hxx"

namespace bellshire
{
  namespace lib
  {
    // Associate
    // 


    // AssociationDetails
    // 

    const AssociationDetails::Associate_optional& AssociationDetails::
    Associate () const
    {
      return this->Associate_;
    }

    AssociationDetails::Associate_optional& AssociationDetails::
    Associate ()
    {
      return this->Associate_;
    }

    void AssociationDetails::
    Associate (const Associate_type& x)
    {
      this->Associate_.set (x);
    }

    void AssociationDetails::
    Associate (const Associate_optional& x)
    {
      this->Associate_ = x;
    }

    void AssociationDetails::
    Associate (::std::unique_ptr< Associate_type > x)
    {
      this->Associate_.set (std::move (x));
    }

    const AssociationDetails::Relationship_optional& AssociationDetails::
    Relationship () const
    {
      return this->Relationship_;
    }

    AssociationDetails::Relationship_optional& AssociationDetails::
    Relationship ()
    {
      return this->Relationship_;
    }

    void AssociationDetails::
    Relationship (const Relationship_type& x)
    {
      this->Relationship_.set (x);
    }

    void AssociationDetails::
    Relationship (const Relationship_optional& x)
    {
      this->Relationship_ = x;
    }

    void AssociationDetails::
    Relationship (::std::unique_ptr< Relationship_type > x)
    {
      this->Relationship_.set (std::move (x));
    }

    const AssociationDetails::Notes_optional& AssociationDetails::
    Notes () const
    {
      return this->Notes_;
    }

    AssociationDetails::Notes_optional& AssociationDetails::
    Notes ()
    {
      return this->Notes_;
    }

    void AssociationDetails::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void AssociationDetails::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void AssociationDetails::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }


    // BulkDetails
    // 

    const BulkDetails::Name_type& BulkDetails::
    Name () const
    {
      return this->Name_.get ();
    }

    BulkDetails::Name_type& BulkDetails::
    Name ()
    {
      return this->Name_.get ();
    }

    void BulkDetails::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void BulkDetails::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const BulkDetails::Class_sequence& BulkDetails::
    Class () const
    {
      return this->Class_;
    }

    BulkDetails::Class_sequence& BulkDetails::
    Class ()
    {
      return this->Class_;
    }

    void BulkDetails::
    Class (const Class_sequence& s)
    {
      this->Class_ = s;
    }

    const BulkDetails::Subclass_sequence& BulkDetails::
    Subclass () const
    {
      return this->Subclass_;
    }

    BulkDetails::Subclass_sequence& BulkDetails::
    Subclass ()
    {
      return this->Subclass_;
    }

    void BulkDetails::
    Subclass (const Subclass_sequence& s)
    {
      this->Subclass_ = s;
    }

    const BulkDetails::Specification_sequence& BulkDetails::
    Specification () const
    {
      return this->Specification_;
    }

    BulkDetails::Specification_sequence& BulkDetails::
    Specification ()
    {
      return this->Specification_;
    }

    void BulkDetails::
    Specification (const Specification_sequence& s)
    {
      this->Specification_ = s;
    }

    const BulkDetails::Source_optional& BulkDetails::
    Source () const
    {
      return this->Source_;
    }

    BulkDetails::Source_optional& BulkDetails::
    Source ()
    {
      return this->Source_;
    }

    void BulkDetails::
    Source (const Source_type& x)
    {
      this->Source_.set (x);
    }

    void BulkDetails::
    Source (const Source_optional& x)
    {
      this->Source_ = x;
    }

    void BulkDetails::
    Source (::std::unique_ptr< Source_type > x)
    {
      this->Source_.set (std::move (x));
    }

    const BulkDetails::Form_optional& BulkDetails::
    Form () const
    {
      return this->Form_;
    }

    BulkDetails::Form_optional& BulkDetails::
    Form ()
    {
      return this->Form_;
    }

    void BulkDetails::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void BulkDetails::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void BulkDetails::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }

    const BulkDetails::ProcessingDetails_sequence& BulkDetails::
    ProcessingDetails () const
    {
      return this->ProcessingDetails_;
    }

    BulkDetails::ProcessingDetails_sequence& BulkDetails::
    ProcessingDetails ()
    {
      return this->ProcessingDetails_;
    }

    void BulkDetails::
    ProcessingDetails (const ProcessingDetails_sequence& s)
    {
      this->ProcessingDetails_ = s;
    }

    const BulkDetails::Characterization_optional& BulkDetails::
    Characterization () const
    {
      return this->Characterization_;
    }

    BulkDetails::Characterization_optional& BulkDetails::
    Characterization ()
    {
      return this->Characterization_;
    }

    void BulkDetails::
    Characterization (const Characterization_type& x)
    {
      this->Characterization_.set (x);
    }

    void BulkDetails::
    Characterization (const Characterization_optional& x)
    {
      this->Characterization_ = x;
    }

    void BulkDetails::
    Characterization (::std::unique_ptr< Characterization_type > x)
    {
      this->Characterization_.set (std::move (x));
    }

    const BulkDetails::PropertyData_sequence& BulkDetails::
    PropertyData () const
    {
      return this->PropertyData_;
    }

    BulkDetails::PropertyData_sequence& BulkDetails::
    PropertyData ()
    {
      return this->PropertyData_;
    }

    void BulkDetails::
    PropertyData (const PropertyData_sequence& s)
    {
      this->PropertyData_ = s;
    }

    const BulkDetails::Notes_optional& BulkDetails::
    Notes () const
    {
      return this->Notes_;
    }

    BulkDetails::Notes_optional& BulkDetails::
    Notes ()
    {
      return this->Notes_;
    }

    void BulkDetails::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void BulkDetails::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void BulkDetails::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }


    // Characterization
    // 

    const Characterization::Formula_type& Characterization::
    Formula () const
    {
      return this->Formula_.get ();
    }

    Characterization::Formula_type& Characterization::
    Formula ()
    {
      return this->Formula_.get ();
    }

    void Characterization::
    Formula (const Formula_type& x)
    {
      this->Formula_.set (x);
    }

    void Characterization::
    Formula (::std::unique_ptr< Formula_type > x)
    {
      this->Formula_.set (std::move (x));
    }

    const Characterization::ChemicalComposition_optional& Characterization::
    ChemicalComposition () const
    {
      return this->ChemicalComposition_;
    }

    Characterization::ChemicalComposition_optional& Characterization::
    ChemicalComposition ()
    {
      return this->ChemicalComposition_;
    }

    void Characterization::
    ChemicalComposition (const ChemicalComposition_type& x)
    {
      this->ChemicalComposition_.set (x);
    }

    void Characterization::
    ChemicalComposition (const ChemicalComposition_optional& x)
    {
      this->ChemicalComposition_ = x;
    }

    void Characterization::
    ChemicalComposition (::std::unique_ptr< ChemicalComposition_type > x)
    {
      this->ChemicalComposition_.set (std::move (x));
    }

    const Characterization::PhaseComposition_sequence& Characterization::
    PhaseComposition () const
    {
      return this->PhaseComposition_;
    }

    Characterization::PhaseComposition_sequence& Characterization::
    PhaseComposition ()
    {
      return this->PhaseComposition_;
    }

    void Characterization::
    PhaseComposition (const PhaseComposition_sequence& s)
    {
      this->PhaseComposition_ = s;
    }

    const Characterization::DimensionalDetails_sequence& Characterization::
    DimensionalDetails () const
    {
      return this->DimensionalDetails_;
    }

    Characterization::DimensionalDetails_sequence& Characterization::
    DimensionalDetails ()
    {
      return this->DimensionalDetails_;
    }

    void Characterization::
    DimensionalDetails (const DimensionalDetails_sequence& s)
    {
      this->DimensionalDetails_ = s;
    }

    const Characterization::Notes_optional& Characterization::
    Notes () const
    {
      return this->Notes_;
    }

    Characterization::Notes_optional& Characterization::
    Notes ()
    {
      return this->Notes_;
    }

    void Characterization::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void Characterization::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void Characterization::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }


    // ChemicalComposition
    // 

    const ChemicalComposition::Compound_sequence& ChemicalComposition::
    Compound () const
    {
      return this->Compound_;
    }

    ChemicalComposition::Compound_sequence& ChemicalComposition::
    Compound ()
    {
      return this->Compound_;
    }

    void ChemicalComposition::
    Compound (const Compound_sequence& s)
    {
      this->Compound_ = s;
    }

    const ChemicalComposition::Element_sequence& ChemicalComposition::
    Element () const
    {
      return this->Element_;
    }

    ChemicalComposition::Element_sequence& ChemicalComposition::
    Element ()
    {
      return this->Element_;
    }

    void ChemicalComposition::
    Element (const Element_sequence& s)
    {
      this->Element_ = s;
    }


    // Class
    // 

    const Class::Name_optional& Class::
    Name () const
    {
      return this->Name_;
    }

    Class::Name_optional& Class::
    Name ()
    {
      return this->Name_;
    }

    void Class::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void Class::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void Class::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const Class::ParentMaterial_sequence& Class::
    ParentMaterial () const
    {
      return this->ParentMaterial_;
    }

    Class::ParentMaterial_sequence& Class::
    ParentMaterial ()
    {
      return this->ParentMaterial_;
    }

    void Class::
    ParentMaterial (const ParentMaterial_sequence& s)
    {
      this->ParentMaterial_ = s;
    }

    const Class::ParentSubClass_sequence& Class::
    ParentSubClass () const
    {
      return this->ParentSubClass_;
    }

    Class::ParentSubClass_sequence& Class::
    ParentSubClass ()
    {
      return this->ParentSubClass_;
    }

    void Class::
    ParentSubClass (const ParentSubClass_sequence& s)
    {
      this->ParentSubClass_ = s;
    }


    // ComponentDetails
    // 

    const ComponentDetails::Name_type& ComponentDetails::
    Name () const
    {
      return this->Name_.get ();
    }

    ComponentDetails::Name_type& ComponentDetails::
    Name ()
    {
      return this->Name_.get ();
    }

    void ComponentDetails::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void ComponentDetails::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const ComponentDetails::Class_sequence& ComponentDetails::
    Class () const
    {
      return this->Class_;
    }

    ComponentDetails::Class_sequence& ComponentDetails::
    Class ()
    {
      return this->Class_;
    }

    void ComponentDetails::
    Class (const Class_sequence& s)
    {
      this->Class_ = s;
    }

    const ComponentDetails::Subclass_sequence& ComponentDetails::
    Subclass () const
    {
      return this->Subclass_;
    }

    ComponentDetails::Subclass_sequence& ComponentDetails::
    Subclass ()
    {
      return this->Subclass_;
    }

    void ComponentDetails::
    Subclass (const Subclass_sequence& s)
    {
      this->Subclass_ = s;
    }

    const ComponentDetails::Specification_sequence& ComponentDetails::
    Specification () const
    {
      return this->Specification_;
    }

    ComponentDetails::Specification_sequence& ComponentDetails::
    Specification ()
    {
      return this->Specification_;
    }

    void ComponentDetails::
    Specification (const Specification_sequence& s)
    {
      this->Specification_ = s;
    }

    const ComponentDetails::Source_optional& ComponentDetails::
    Source () const
    {
      return this->Source_;
    }

    ComponentDetails::Source_optional& ComponentDetails::
    Source ()
    {
      return this->Source_;
    }

    void ComponentDetails::
    Source (const Source_type& x)
    {
      this->Source_.set (x);
    }

    void ComponentDetails::
    Source (const Source_optional& x)
    {
      this->Source_ = x;
    }

    void ComponentDetails::
    Source (::std::unique_ptr< Source_type > x)
    {
      this->Source_.set (std::move (x));
    }

    const ComponentDetails::Form_optional& ComponentDetails::
    Form () const
    {
      return this->Form_;
    }

    ComponentDetails::Form_optional& ComponentDetails::
    Form ()
    {
      return this->Form_;
    }

    void ComponentDetails::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void ComponentDetails::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void ComponentDetails::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }

    const ComponentDetails::ProcessingDetails_sequence& ComponentDetails::
    ProcessingDetails () const
    {
      return this->ProcessingDetails_;
    }

    ComponentDetails::ProcessingDetails_sequence& ComponentDetails::
    ProcessingDetails ()
    {
      return this->ProcessingDetails_;
    }

    void ComponentDetails::
    ProcessingDetails (const ProcessingDetails_sequence& s)
    {
      this->ProcessingDetails_ = s;
    }

    const ComponentDetails::Characterization_optional& ComponentDetails::
    Characterization () const
    {
      return this->Characterization_;
    }

    ComponentDetails::Characterization_optional& ComponentDetails::
    Characterization ()
    {
      return this->Characterization_;
    }

    void ComponentDetails::
    Characterization (const Characterization_type& x)
    {
      this->Characterization_.set (x);
    }

    void ComponentDetails::
    Characterization (const Characterization_optional& x)
    {
      this->Characterization_ = x;
    }

    void ComponentDetails::
    Characterization (::std::unique_ptr< Characterization_type > x)
    {
      this->Characterization_.set (std::move (x));
    }

    const ComponentDetails::PropertyData_sequence& ComponentDetails::
    PropertyData () const
    {
      return this->PropertyData_;
    }

    ComponentDetails::PropertyData_sequence& ComponentDetails::
    PropertyData ()
    {
      return this->PropertyData_;
    }

    void ComponentDetails::
    PropertyData (const PropertyData_sequence& s)
    {
      this->PropertyData_ = s;
    }

    const ComponentDetails::AssociationDetails_sequence& ComponentDetails::
    AssociationDetails () const
    {
      return this->AssociationDetails_;
    }

    ComponentDetails::AssociationDetails_sequence& ComponentDetails::
    AssociationDetails ()
    {
      return this->AssociationDetails_;
    }

    void ComponentDetails::
    AssociationDetails (const AssociationDetails_sequence& s)
    {
      this->AssociationDetails_ = s;
    }

    const ComponentDetails::ComponentDetails1_sequence& ComponentDetails::
    ComponentDetails1 () const
    {
      return this->ComponentDetails1_;
    }

    ComponentDetails::ComponentDetails1_sequence& ComponentDetails::
    ComponentDetails1 ()
    {
      return this->ComponentDetails1_;
    }

    void ComponentDetails::
    ComponentDetails1 (const ComponentDetails1_sequence& s)
    {
      this->ComponentDetails1_ = s;
    }

    const ComponentDetails::id_optional& ComponentDetails::
    id () const
    {
      return this->id_;
    }

    ComponentDetails::id_optional& ComponentDetails::
    id ()
    {
      return this->id_;
    }

    void ComponentDetails::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void ComponentDetails::
    id (const id_optional& x)
    {
      this->id_ = x;
    }

    void ComponentDetails::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // Compound
    // 

    const Compound::Element_sequence& Compound::
    Element () const
    {
      return this->Element_;
    }

    Compound::Element_sequence& Compound::
    Element ()
    {
      return this->Element_;
    }

    void Compound::
    Element (const Element_sequence& s)
    {
      this->Element_ = s;
    }

    const Compound::Concentration_optional& Compound::
    Concentration () const
    {
      return this->Concentration_;
    }

    Compound::Concentration_optional& Compound::
    Concentration ()
    {
      return this->Concentration_;
    }

    void Compound::
    Concentration (const Concentration_type& x)
    {
      this->Concentration_.set (x);
    }

    void Compound::
    Concentration (const Concentration_optional& x)
    {
      this->Concentration_ = x;
    }

    void Compound::
    Concentration (::std::unique_ptr< Concentration_type > x)
    {
      this->Concentration_.set (std::move (x));
    }

    const Compound::Notes_optional& Compound::
    Notes () const
    {
      return this->Notes_;
    }

    Compound::Notes_optional& Compound::
    Notes ()
    {
      return this->Notes_;
    }

    void Compound::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void Compound::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void Compound::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }


    // Concentration
    // 

    const Concentration::Value_type& Concentration::
    Value () const
    {
      return this->Value_.get ();
    }

    Concentration::Value_type& Concentration::
    Value ()
    {
      return this->Value_.get ();
    }

    void Concentration::
    Value (const Value_type& x)
    {
      this->Value_.set (x);
    }

    void Concentration::
    Value (::std::unique_ptr< Value_type > x)
    {
      this->Value_.set (std::move (x));
    }

    const Concentration::Units_type& Concentration::
    Units () const
    {
      return this->Units_.get ();
    }

    Concentration::Units_type& Concentration::
    Units ()
    {
      return this->Units_.get ();
    }

    void Concentration::
    Units (const Units_type& x)
    {
      this->Units_.set (x);
    }

    void Concentration::
    Units (::std::unique_ptr< Units_type > x)
    {
      this->Units_.set (std::move (x));
    }

    const Concentration::Qualifier_sequence& Concentration::
    Qualifier () const
    {
      return this->Qualifier_;
    }

    Concentration::Qualifier_sequence& Concentration::
    Qualifier ()
    {
      return this->Qualifier_;
    }

    void Concentration::
    Qualifier (const Qualifier_sequence& s)
    {
      this->Qualifier_ = s;
    }

    const Concentration::Uncertainty_sequence& Concentration::
    Uncertainty () const
    {
      return this->Uncertainty_;
    }

    Concentration::Uncertainty_sequence& Concentration::
    Uncertainty ()
    {
      return this->Uncertainty_;
    }

    void Concentration::
    Uncertainty (const Uncertainty_sequence& s)
    {
      this->Uncertainty_ = s;
    }

    const Concentration::Notes_optional& Concentration::
    Notes () const
    {
      return this->Notes_;
    }

    Concentration::Notes_optional& Concentration::
    Notes ()
    {
      return this->Notes_;
    }

    void Concentration::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void Concentration::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void Concentration::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }


    // DataFormat
    // 

    DataFormat::
    DataFormat (value v)
    : ::xml_schema::string (_xsd_DataFormat_literals_[v])
    {
    }

    DataFormat::
    DataFormat (const char* v)
    : ::xml_schema::string (v)
    {
    }

    DataFormat::
    DataFormat (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    DataFormat::
    DataFormat (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    DataFormat::
    DataFormat (const DataFormat& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    DataFormat& DataFormat::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_DataFormat_literals_[v]);

      return *this;
    }


    // DimensionalDetails
    // 

    const DimensionalDetails::Name_type& DimensionalDetails::
    Name () const
    {
      return this->Name_.get ();
    }

    DimensionalDetails::Name_type& DimensionalDetails::
    Name ()
    {
      return this->Name_.get ();
    }

    void DimensionalDetails::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void DimensionalDetails::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const DimensionalDetails::Value_type& DimensionalDetails::
    Value () const
    {
      return this->Value_.get ();
    }

    DimensionalDetails::Value_type& DimensionalDetails::
    Value ()
    {
      return this->Value_.get ();
    }

    void DimensionalDetails::
    Value (const Value_type& x)
    {
      this->Value_.set (x);
    }

    void DimensionalDetails::
    Value (::std::unique_ptr< Value_type > x)
    {
      this->Value_.set (std::move (x));
    }

    const DimensionalDetails::Units_type& DimensionalDetails::
    Units () const
    {
      return this->Units_.get ();
    }

    DimensionalDetails::Units_type& DimensionalDetails::
    Units ()
    {
      return this->Units_.get ();
    }

    void DimensionalDetails::
    Units (const Units_type& x)
    {
      this->Units_.set (x);
    }

    void DimensionalDetails::
    Units (::std::unique_ptr< Units_type > x)
    {
      this->Units_.set (std::move (x));
    }

    const DimensionalDetails::Qualifier_optional& DimensionalDetails::
    Qualifier () const
    {
      return this->Qualifier_;
    }

    DimensionalDetails::Qualifier_optional& DimensionalDetails::
    Qualifier ()
    {
      return this->Qualifier_;
    }

    void DimensionalDetails::
    Qualifier (const Qualifier_type& x)
    {
      this->Qualifier_.set (x);
    }

    void DimensionalDetails::
    Qualifier (const Qualifier_optional& x)
    {
      this->Qualifier_ = x;
    }

    void DimensionalDetails::
    Qualifier (::std::unique_ptr< Qualifier_type > x)
    {
      this->Qualifier_.set (std::move (x));
    }

    const DimensionalDetails::Uncertainty_sequence& DimensionalDetails::
    Uncertainty () const
    {
      return this->Uncertainty_;
    }

    DimensionalDetails::Uncertainty_sequence& DimensionalDetails::
    Uncertainty ()
    {
      return this->Uncertainty_;
    }

    void DimensionalDetails::
    Uncertainty (const Uncertainty_sequence& s)
    {
      this->Uncertainty_ = s;
    }

    const DimensionalDetails::Notes_optional& DimensionalDetails::
    Notes () const
    {
      return this->Notes_;
    }

    DimensionalDetails::Notes_optional& DimensionalDetails::
    Notes ()
    {
      return this->Notes_;
    }

    void DimensionalDetails::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void DimensionalDetails::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void DimensionalDetails::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }


    // Element
    // 

    const Element::Symbol_type& Element::
    Symbol () const
    {
      return this->Symbol_.get ();
    }

    Element::Symbol_type& Element::
    Symbol ()
    {
      return this->Symbol_.get ();
    }

    void Element::
    Symbol (const Symbol_type& x)
    {
      this->Symbol_.set (x);
    }

    void Element::
    Symbol (::std::unique_ptr< Symbol_type > x)
    {
      this->Symbol_.set (std::move (x));
    }

    const Element::Concentration_optional& Element::
    Concentration () const
    {
      return this->Concentration_;
    }

    Element::Concentration_optional& Element::
    Concentration ()
    {
      return this->Concentration_;
    }

    void Element::
    Concentration (const Concentration_type& x)
    {
      this->Concentration_.set (x);
    }

    void Element::
    Concentration (const Concentration_optional& x)
    {
      this->Concentration_ = x;
    }

    void Element::
    Concentration (::std::unique_ptr< Concentration_type > x)
    {
      this->Concentration_.set (std::move (x));
    }

    const Element::Notes_optional& Element::
    Notes () const
    {
      return this->Notes_;
    }

    Element::Notes_optional& Element::
    Notes ()
    {
      return this->Notes_;
    }

    void Element::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void Element::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void Element::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }


    // Form
    // 

    const Form::Description_type& Form::
    Description () const
    {
      return this->Description_.get ();
    }

    Form::Description_type& Form::
    Description ()
    {
      return this->Description_.get ();
    }

    void Form::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void Form::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }

    const Form::Geometry_optional& Form::
    Geometry () const
    {
      return this->Geometry_;
    }

    Form::Geometry_optional& Form::
    Geometry ()
    {
      return this->Geometry_;
    }

    void Form::
    Geometry (const Geometry_type& x)
    {
      this->Geometry_.set (x);
    }

    void Form::
    Geometry (const Geometry_optional& x)
    {
      this->Geometry_ = x;
    }

    void Form::
    Geometry (::std::unique_ptr< Geometry_type > x)
    {
      this->Geometry_.set (std::move (x));
    }

    const Form::Notes_optional& Form::
    Notes () const
    {
      return this->Notes_;
    }

    Form::Notes_optional& Form::
    Notes ()
    {
      return this->Notes_;
    }

    void Form::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void Form::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void Form::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }


    // Formula
    // 


    // Geometry
    // 

    const Geometry::Shape_type& Geometry::
    Shape () const
    {
      return this->Shape_.get ();
    }

    Geometry::Shape_type& Geometry::
    Shape ()
    {
      return this->Shape_.get ();
    }

    void Geometry::
    Shape (const Shape_type& x)
    {
      this->Shape_.set (x);
    }

    void Geometry::
    Shape (::std::unique_ptr< Shape_type > x)
    {
      this->Shape_.set (std::move (x));
    }

    const Geometry::Dimensions_optional& Geometry::
    Dimensions () const
    {
      return this->Dimensions_;
    }

    Geometry::Dimensions_optional& Geometry::
    Dimensions ()
    {
      return this->Dimensions_;
    }

    void Geometry::
    Dimensions (const Dimensions_type& x)
    {
      this->Dimensions_.set (x);
    }

    void Geometry::
    Dimensions (const Dimensions_optional& x)
    {
      this->Dimensions_ = x;
    }

    void Geometry::
    Dimensions (::std::unique_ptr< Dimensions_type > x)
    {
      this->Dimensions_.set (std::move (x));
    }

    const Geometry::Orientation_optional& Geometry::
    Orientation () const
    {
      return this->Orientation_;
    }

    Geometry::Orientation_optional& Geometry::
    Orientation ()
    {
      return this->Orientation_;
    }

    void Geometry::
    Orientation (const Orientation_type& x)
    {
      this->Orientation_.set (x);
    }

    void Geometry::
    Orientation (const Orientation_optional& x)
    {
      this->Orientation_ = x;
    }

    void Geometry::
    Orientation (::std::unique_ptr< Orientation_type > x)
    {
      this->Orientation_.set (std::move (x));
    }

    const Geometry::Notes_optional& Geometry::
    Notes () const
    {
      return this->Notes_;
    }

    Geometry::Notes_optional& Geometry::
    Notes ()
    {
      return this->Notes_;
    }

    void Geometry::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void Geometry::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void Geometry::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }


    // Glossary
    // 

    const Glossary::Term_sequence& Glossary::
    Term () const
    {
      return this->Term_;
    }

    Glossary::Term_sequence& Glossary::
    Term ()
    {
      return this->Term_;
    }

    void Glossary::
    Term (const Term_sequence& s)
    {
      this->Term_ = s;
    }


    // GlossaryTerm
    // 

    const GlossaryTerm::Name_type& GlossaryTerm::
    Name () const
    {
      return this->Name_.get ();
    }

    GlossaryTerm::Name_type& GlossaryTerm::
    Name ()
    {
      return this->Name_.get ();
    }

    void GlossaryTerm::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void GlossaryTerm::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const GlossaryTerm::Definition_type& GlossaryTerm::
    Definition () const
    {
      return this->Definition_.get ();
    }

    GlossaryTerm::Definition_type& GlossaryTerm::
    Definition ()
    {
      return this->Definition_.get ();
    }

    void GlossaryTerm::
    Definition (const Definition_type& x)
    {
      this->Definition_.set (x);
    }

    void GlossaryTerm::
    Definition (::std::unique_ptr< Definition_type > x)
    {
      this->Definition_.set (std::move (x));
    }

    const GlossaryTerm::Abbreviation_sequence& GlossaryTerm::
    Abbreviation () const
    {
      return this->Abbreviation_;
    }

    GlossaryTerm::Abbreviation_sequence& GlossaryTerm::
    Abbreviation ()
    {
      return this->Abbreviation_;
    }

    void GlossaryTerm::
    Abbreviation (const Abbreviation_sequence& s)
    {
      this->Abbreviation_ = s;
    }

    const GlossaryTerm::Synonym_sequence& GlossaryTerm::
    Synonym () const
    {
      return this->Synonym_;
    }

    GlossaryTerm::Synonym_sequence& GlossaryTerm::
    Synonym ()
    {
      return this->Synonym_;
    }

    void GlossaryTerm::
    Synonym (const Synonym_sequence& s)
    {
      this->Synonym_ = s;
    }

    const GlossaryTerm::Notes_optional& GlossaryTerm::
    Notes () const
    {
      return this->Notes_;
    }

    GlossaryTerm::Notes_optional& GlossaryTerm::
    Notes ()
    {
      return this->Notes_;
    }

    void GlossaryTerm::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void GlossaryTerm::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void GlossaryTerm::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }


    // Graphs
    // 

    const Graphs::Graph_sequence& Graphs::
    Graph () const
    {
      return this->Graph_;
    }

    Graphs::Graph_sequence& Graphs::
    Graph ()
    {
      return this->Graph_;
    }

    void Graphs::
    Graph (const Graph_sequence& s)
    {
      this->Graph_ = s;
    }


    // Material
    // 

    const Material::BulkDetails_type& Material::
    BulkDetails () const
    {
      return this->BulkDetails_.get ();
    }

    Material::BulkDetails_type& Material::
    BulkDetails ()
    {
      return this->BulkDetails_.get ();
    }

    void Material::
    BulkDetails (const BulkDetails_type& x)
    {
      this->BulkDetails_.set (x);
    }

    void Material::
    BulkDetails (::std::unique_ptr< BulkDetails_type > x)
    {
      this->BulkDetails_.set (std::move (x));
    }

    const Material::ComponentDetails_sequence& Material::
    ComponentDetails () const
    {
      return this->ComponentDetails_;
    }

    Material::ComponentDetails_sequence& Material::
    ComponentDetails ()
    {
      return this->ComponentDetails_;
    }

    void Material::
    ComponentDetails (const ComponentDetails_sequence& s)
    {
      this->ComponentDetails_ = s;
    }

    const Material::Graphs_optional& Material::
    Graphs () const
    {
      return this->Graphs_;
    }

    Material::Graphs_optional& Material::
    Graphs ()
    {
      return this->Graphs_;
    }

    void Material::
    Graphs (const Graphs_type& x)
    {
      this->Graphs_.set (x);
    }

    void Material::
    Graphs (const Graphs_optional& x)
    {
      this->Graphs_ = x;
    }

    void Material::
    Graphs (::std::unique_ptr< Graphs_type > x)
    {
      this->Graphs_.set (std::move (x));
    }

    const Material::Glossary_optional& Material::
    Glossary () const
    {
      return this->Glossary_;
    }

    Material::Glossary_optional& Material::
    Glossary ()
    {
      return this->Glossary_;
    }

    void Material::
    Glossary (const Glossary_type& x)
    {
      this->Glossary_.set (x);
    }

    void Material::
    Glossary (const Glossary_optional& x)
    {
      this->Glossary_ = x;
    }

    void Material::
    Glossary (::std::unique_ptr< Glossary_type > x)
    {
      this->Glossary_.set (std::move (x));
    }

    const Material::id_optional& Material::
    id () const
    {
      return this->id_;
    }

    Material::id_optional& Material::
    id ()
    {
      return this->id_;
    }

    void Material::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void Material::
    id (const id_optional& x)
    {
      this->id_ = x;
    }

    void Material::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const Material::layers_optional& Material::
    layers () const
    {
      return this->layers_;
    }

    Material::layers_optional& Material::
    layers ()
    {
      return this->layers_;
    }

    void Material::
    layers (const layers_type& x)
    {
      this->layers_.set (x);
    }

    void Material::
    layers (const layers_optional& x)
    {
      this->layers_ = x;
    }

    const Material::local_frame_of_reference_optional& Material::
    local_frame_of_reference () const
    {
      return this->local_frame_of_reference_;
    }

    Material::local_frame_of_reference_optional& Material::
    local_frame_of_reference ()
    {
      return this->local_frame_of_reference_;
    }

    void Material::
    local_frame_of_reference (const local_frame_of_reference_type& x)
    {
      this->local_frame_of_reference_.set (x);
    }

    void Material::
    local_frame_of_reference (const local_frame_of_reference_optional& x)
    {
      this->local_frame_of_reference_ = x;
    }

    void Material::
    local_frame_of_reference (::std::unique_ptr< local_frame_of_reference_type > x)
    {
      this->local_frame_of_reference_.set (std::move (x));
    }


    // Metadata
    // 

    const Metadata::AuthorityDetails_sequence& Metadata::
    AuthorityDetails () const
    {
      return this->AuthorityDetails_;
    }

    Metadata::AuthorityDetails_sequence& Metadata::
    AuthorityDetails ()
    {
      return this->AuthorityDetails_;
    }

    void Metadata::
    AuthorityDetails (const AuthorityDetails_sequence& s)
    {
      this->AuthorityDetails_ = s;
    }

    const Metadata::DataSourceDetails_sequence& Metadata::
    DataSourceDetails () const
    {
      return this->DataSourceDetails_;
    }

    Metadata::DataSourceDetails_sequence& Metadata::
    DataSourceDetails ()
    {
      return this->DataSourceDetails_;
    }

    void Metadata::
    DataSourceDetails (const DataSourceDetails_sequence& s)
    {
      this->DataSourceDetails_ = s;
    }

    const Metadata::MeasurementTechniqueDetails_sequence& Metadata::
    MeasurementTechniqueDetails () const
    {
      return this->MeasurementTechniqueDetails_;
    }

    Metadata::MeasurementTechniqueDetails_sequence& Metadata::
    MeasurementTechniqueDetails ()
    {
      return this->MeasurementTechniqueDetails_;
    }

    void Metadata::
    MeasurementTechniqueDetails (const MeasurementTechniqueDetails_sequence& s)
    {
      this->MeasurementTechniqueDetails_ = s;
    }

    const Metadata::ParameterDetails_sequence& Metadata::
    ParameterDetails () const
    {
      return this->ParameterDetails_;
    }

    Metadata::ParameterDetails_sequence& Metadata::
    ParameterDetails ()
    {
      return this->ParameterDetails_;
    }

    void Metadata::
    ParameterDetails (const ParameterDetails_sequence& s)
    {
      this->ParameterDetails_ = s;
    }

    const Metadata::PropertyDetails_sequence& Metadata::
    PropertyDetails () const
    {
      return this->PropertyDetails_;
    }

    Metadata::PropertyDetails_sequence& Metadata::
    PropertyDetails ()
    {
      return this->PropertyDetails_;
    }

    void Metadata::
    PropertyDetails (const PropertyDetails_sequence& s)
    {
      this->PropertyDetails_ = s;
    }

    const Metadata::SourceDetails_sequence& Metadata::
    SourceDetails () const
    {
      return this->SourceDetails_;
    }

    Metadata::SourceDetails_sequence& Metadata::
    SourceDetails ()
    {
      return this->SourceDetails_;
    }

    void Metadata::
    SourceDetails (const SourceDetails_sequence& s)
    {
      this->SourceDetails_ = s;
    }

    const Metadata::SpecimenDetails_sequence& Metadata::
    SpecimenDetails () const
    {
      return this->SpecimenDetails_;
    }

    Metadata::SpecimenDetails_sequence& Metadata::
    SpecimenDetails ()
    {
      return this->SpecimenDetails_;
    }

    void Metadata::
    SpecimenDetails (const SpecimenDetails_sequence& s)
    {
      this->SpecimenDetails_ = s;
    }

    const Metadata::TestConditionDetails_sequence& Metadata::
    TestConditionDetails () const
    {
      return this->TestConditionDetails_;
    }

    Metadata::TestConditionDetails_sequence& Metadata::
    TestConditionDetails ()
    {
      return this->TestConditionDetails_;
    }

    void Metadata::
    TestConditionDetails (const TestConditionDetails_sequence& s)
    {
      this->TestConditionDetails_ = s;
    }


    // Name
    // 

    const Name::authority_optional& Name::
    authority () const
    {
      return this->authority_;
    }

    Name::authority_optional& Name::
    authority ()
    {
      return this->authority_;
    }

    void Name::
    authority (const authority_type& x)
    {
      this->authority_.set (x);
    }

    void Name::
    authority (const authority_optional& x)
    {
      this->authority_ = x;
    }

    void Name::
    authority (::std::unique_ptr< authority_type > x)
    {
      this->authority_.set (std::move (x));
    }


    // Notes
    // 


    // ParameterValue
    // 

    const ParameterValue::Data_type& ParameterValue::
    Data () const
    {
      return this->Data_.get ();
    }

    ParameterValue::Data_type& ParameterValue::
    Data ()
    {
      return this->Data_.get ();
    }

    void ParameterValue::
    Data (const Data_type& x)
    {
      this->Data_.set (x);
    }

    void ParameterValue::
    Data (::std::unique_ptr< Data_type > x)
    {
      this->Data_.set (std::move (x));
    }

    const ParameterValue::Uncertainty_sequence& ParameterValue::
    Uncertainty () const
    {
      return this->Uncertainty_;
    }

    ParameterValue::Uncertainty_sequence& ParameterValue::
    Uncertainty ()
    {
      return this->Uncertainty_;
    }

    void ParameterValue::
    Uncertainty (const Uncertainty_sequence& s)
    {
      this->Uncertainty_ = s;
    }

    const ParameterValue::Qualifier_sequence& ParameterValue::
    Qualifier () const
    {
      return this->Qualifier_;
    }

    ParameterValue::Qualifier_sequence& ParameterValue::
    Qualifier ()
    {
      return this->Qualifier_;
    }

    void ParameterValue::
    Qualifier (const Qualifier_sequence& s)
    {
      this->Qualifier_ = s;
    }

    const ParameterValue::Notes_optional& ParameterValue::
    Notes () const
    {
      return this->Notes_;
    }

    ParameterValue::Notes_optional& ParameterValue::
    Notes ()
    {
      return this->Notes_;
    }

    void ParameterValue::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void ParameterValue::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void ParameterValue::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }

    const ParameterValue::parameter_type& ParameterValue::
    parameter () const
    {
      return this->parameter_.get ();
    }

    ParameterValue::parameter_type& ParameterValue::
    parameter ()
    {
      return this->parameter_.get ();
    }

    void ParameterValue::
    parameter (const parameter_type& x)
    {
      this->parameter_.set (x);
    }

    void ParameterValue::
    parameter (::std::unique_ptr< parameter_type > x)
    {
      this->parameter_.set (std::move (x));
    }

    const ParameterValue::format_type& ParameterValue::
    format () const
    {
      return this->format_.get ();
    }

    ParameterValue::format_type& ParameterValue::
    format ()
    {
      return this->format_.get ();
    }

    void ParameterValue::
    format (const format_type& x)
    {
      this->format_.set (x);
    }

    void ParameterValue::
    format (::std::unique_ptr< format_type > x)
    {
      this->format_.set (std::move (x));
    }


    // PhaseComposition
    // 

    const PhaseComposition::Name_type& PhaseComposition::
    Name () const
    {
      return this->Name_.get ();
    }

    PhaseComposition::Name_type& PhaseComposition::
    Name ()
    {
      return this->Name_.get ();
    }

    void PhaseComposition::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void PhaseComposition::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const PhaseComposition::Concentration_optional& PhaseComposition::
    Concentration () const
    {
      return this->Concentration_;
    }

    PhaseComposition::Concentration_optional& PhaseComposition::
    Concentration ()
    {
      return this->Concentration_;
    }

    void PhaseComposition::
    Concentration (const Concentration_type& x)
    {
      this->Concentration_.set (x);
    }

    void PhaseComposition::
    Concentration (const Concentration_optional& x)
    {
      this->Concentration_ = x;
    }

    void PhaseComposition::
    Concentration (::std::unique_ptr< Concentration_type > x)
    {
      this->Concentration_.set (std::move (x));
    }

    const PhaseComposition::PropertyData_sequence& PhaseComposition::
    PropertyData () const
    {
      return this->PropertyData_;
    }

    PhaseComposition::PropertyData_sequence& PhaseComposition::
    PropertyData ()
    {
      return this->PropertyData_;
    }

    void PhaseComposition::
    PropertyData (const PropertyData_sequence& s)
    {
      this->PropertyData_ = s;
    }

    const PhaseComposition::Notes_optional& PhaseComposition::
    Notes () const
    {
      return this->Notes_;
    }

    PhaseComposition::Notes_optional& PhaseComposition::
    Notes ()
    {
      return this->Notes_;
    }

    void PhaseComposition::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void PhaseComposition::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void PhaseComposition::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }


    // ProcessingDetails
    // 

    const ProcessingDetails::Name_type& ProcessingDetails::
    Name () const
    {
      return this->Name_.get ();
    }

    ProcessingDetails::Name_type& ProcessingDetails::
    Name ()
    {
      return this->Name_.get ();
    }

    void ProcessingDetails::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void ProcessingDetails::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const ProcessingDetails::ParameterValue_sequence& ProcessingDetails::
    ParameterValue () const
    {
      return this->ParameterValue_;
    }

    ProcessingDetails::ParameterValue_sequence& ProcessingDetails::
    ParameterValue ()
    {
      return this->ParameterValue_;
    }

    void ProcessingDetails::
    ParameterValue (const ParameterValue_sequence& s)
    {
      this->ParameterValue_ = s;
    }

    const ProcessingDetails::Result_optional& ProcessingDetails::
    Result () const
    {
      return this->Result_;
    }

    ProcessingDetails::Result_optional& ProcessingDetails::
    Result ()
    {
      return this->Result_;
    }

    void ProcessingDetails::
    Result (const Result_type& x)
    {
      this->Result_.set (x);
    }

    void ProcessingDetails::
    Result (const Result_optional& x)
    {
      this->Result_ = x;
    }

    void ProcessingDetails::
    Result (::std::unique_ptr< Result_type > x)
    {
      this->Result_.set (std::move (x));
    }

    const ProcessingDetails::Notes_optional& ProcessingDetails::
    Notes () const
    {
      return this->Notes_;
    }

    ProcessingDetails::Notes_optional& ProcessingDetails::
    Notes ()
    {
      return this->Notes_;
    }

    void ProcessingDetails::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void ProcessingDetails::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void ProcessingDetails::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }


    // PropertyData
    // 

    const PropertyData::Data_type& PropertyData::
    Data () const
    {
      return this->Data_.get ();
    }

    PropertyData::Data_type& PropertyData::
    Data ()
    {
      return this->Data_.get ();
    }

    void PropertyData::
    Data (const Data_type& x)
    {
      this->Data_.set (x);
    }

    void PropertyData::
    Data (::std::unique_ptr< Data_type > x)
    {
      this->Data_.set (std::move (x));
    }

    const PropertyData::Uncertainty_sequence& PropertyData::
    Uncertainty () const
    {
      return this->Uncertainty_;
    }

    PropertyData::Uncertainty_sequence& PropertyData::
    Uncertainty ()
    {
      return this->Uncertainty_;
    }

    void PropertyData::
    Uncertainty (const Uncertainty_sequence& s)
    {
      this->Uncertainty_ = s;
    }

    const PropertyData::Qualifier_sequence& PropertyData::
    Qualifier () const
    {
      return this->Qualifier_;
    }

    PropertyData::Qualifier_sequence& PropertyData::
    Qualifier ()
    {
      return this->Qualifier_;
    }

    void PropertyData::
    Qualifier (const Qualifier_sequence& s)
    {
      this->Qualifier_ = s;
    }

    const PropertyData::ParameterValue_sequence& PropertyData::
    ParameterValue () const
    {
      return this->ParameterValue_;
    }

    PropertyData::ParameterValue_sequence& PropertyData::
    ParameterValue ()
    {
      return this->ParameterValue_;
    }

    void PropertyData::
    ParameterValue (const ParameterValue_sequence& s)
    {
      this->ParameterValue_ = s;
    }

    const PropertyData::Notes_optional& PropertyData::
    Notes () const
    {
      return this->Notes_;
    }

    PropertyData::Notes_optional& PropertyData::
    Notes ()
    {
      return this->Notes_;
    }

    void PropertyData::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void PropertyData::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void PropertyData::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }

    const PropertyData::property_type& PropertyData::
    property () const
    {
      return this->property_.get ();
    }

    PropertyData::property_type& PropertyData::
    property ()
    {
      return this->property_.get ();
    }

    void PropertyData::
    property (const property_type& x)
    {
      this->property_.set (x);
    }

    void PropertyData::
    property (::std::unique_ptr< property_type > x)
    {
      this->property_.set (std::move (x));
    }

    const PropertyData::technique_optional& PropertyData::
    technique () const
    {
      return this->technique_;
    }

    PropertyData::technique_optional& PropertyData::
    technique ()
    {
      return this->technique_;
    }

    void PropertyData::
    technique (const technique_type& x)
    {
      this->technique_.set (x);
    }

    void PropertyData::
    technique (const technique_optional& x)
    {
      this->technique_ = x;
    }

    void PropertyData::
    technique (::std::unique_ptr< technique_type > x)
    {
      this->technique_.set (std::move (x));
    }

    const PropertyData::source_optional& PropertyData::
    source () const
    {
      return this->source_;
    }

    PropertyData::source_optional& PropertyData::
    source ()
    {
      return this->source_;
    }

    void PropertyData::
    source (const source_type& x)
    {
      this->source_.set (x);
    }

    void PropertyData::
    source (const source_optional& x)
    {
      this->source_ = x;
    }

    void PropertyData::
    source (::std::unique_ptr< source_type > x)
    {
      this->source_.set (std::move (x));
    }

    const PropertyData::specimen_optional& PropertyData::
    specimen () const
    {
      return this->specimen_;
    }

    PropertyData::specimen_optional& PropertyData::
    specimen ()
    {
      return this->specimen_;
    }

    void PropertyData::
    specimen (const specimen_type& x)
    {
      this->specimen_.set (x);
    }

    void PropertyData::
    specimen (const specimen_optional& x)
    {
      this->specimen_ = x;
    }

    void PropertyData::
    specimen (::std::unique_ptr< specimen_type > x)
    {
      this->specimen_.set (std::move (x));
    }

    const PropertyData::test_optional& PropertyData::
    test () const
    {
      return this->test_;
    }

    PropertyData::test_optional& PropertyData::
    test ()
    {
      return this->test_;
    }

    void PropertyData::
    test (const test_type& x)
    {
      this->test_.set (x);
    }

    void PropertyData::
    test (const test_optional& x)
    {
      this->test_ = x;
    }

    void PropertyData::
    test (::std::unique_ptr< test_type > x)
    {
      this->test_.set (std::move (x));
    }

    const PropertyData::delimiter_type& PropertyData::
    delimiter () const
    {
      return this->delimiter_.get ();
    }

    PropertyData::delimiter_type& PropertyData::
    delimiter ()
    {
      return this->delimiter_.get ();
    }

    void PropertyData::
    delimiter (const delimiter_type& x)
    {
      this->delimiter_.set (x);
    }

    void PropertyData::
    delimiter (::std::unique_ptr< delimiter_type > x)
    {
      this->delimiter_.set (std::move (x));
    }

    const PropertyData::delimiter_type& PropertyData::
    delimiter_default_value ()
    {
      return delimiter_default_value_;
    }

    const PropertyData::quote_optional& PropertyData::
    quote () const
    {
      return this->quote_;
    }

    PropertyData::quote_optional& PropertyData::
    quote ()
    {
      return this->quote_;
    }

    void PropertyData::
    quote (const quote_type& x)
    {
      this->quote_.set (x);
    }

    void PropertyData::
    quote (const quote_optional& x)
    {
      this->quote_ = x;
    }

    void PropertyData::
    quote (::std::unique_ptr< quote_type > x)
    {
      this->quote_.set (std::move (x));
    }


    // Qualifier
    // 


    // Relationship
    // 


    // Source
    // 

    const Source::source_optional& Source::
    source () const
    {
      return this->source_;
    }

    Source::source_optional& Source::
    source ()
    {
      return this->source_;
    }

    void Source::
    source (const source_type& x)
    {
      this->source_.set (x);
    }

    void Source::
    source (const source_optional& x)
    {
      this->source_ = x;
    }

    void Source::
    source (::std::unique_ptr< source_type > x)
    {
      this->source_.set (std::move (x));
    }


    // Specification
    // 

    const Specification::authority_optional& Specification::
    authority () const
    {
      return this->authority_;
    }

    Specification::authority_optional& Specification::
    authority ()
    {
      return this->authority_;
    }

    void Specification::
    authority (const authority_type& x)
    {
      this->authority_.set (x);
    }

    void Specification::
    authority (const authority_optional& x)
    {
      this->authority_ = x;
    }

    void Specification::
    authority (::std::unique_ptr< authority_type > x)
    {
      this->authority_.set (std::move (x));
    }


    // Uncertainty
    // 

    const Uncertainty::Value_type& Uncertainty::
    Value () const
    {
      return this->Value_.get ();
    }

    Uncertainty::Value_type& Uncertainty::
    Value ()
    {
      return this->Value_.get ();
    }

    void Uncertainty::
    Value (const Value_type& x)
    {
      this->Value_.set (x);
    }

    void Uncertainty::
    Value (::std::unique_ptr< Value_type > x)
    {
      this->Value_.set (std::move (x));
    }

    const Uncertainty::Units_optional& Uncertainty::
    Units () const
    {
      return this->Units_;
    }

    Uncertainty::Units_optional& Uncertainty::
    Units ()
    {
      return this->Units_;
    }

    void Uncertainty::
    Units (const Units_type& x)
    {
      this->Units_.set (x);
    }

    void Uncertainty::
    Units (const Units_optional& x)
    {
      this->Units_ = x;
    }

    void Uncertainty::
    Units (::std::unique_ptr< Units_type > x)
    {
      this->Units_.set (std::move (x));
    }

    const Uncertainty::Unitless_optional& Uncertainty::
    Unitless () const
    {
      return this->Unitless_;
    }

    Uncertainty::Unitless_optional& Uncertainty::
    Unitless ()
    {
      return this->Unitless_;
    }

    void Uncertainty::
    Unitless (const Unitless_type& x)
    {
      this->Unitless_.set (x);
    }

    void Uncertainty::
    Unitless (const Unitless_optional& x)
    {
      this->Unitless_ = x;
    }

    void Uncertainty::
    Unitless (::std::unique_ptr< Unitless_type > x)
    {
      this->Unitless_.set (std::move (x));
    }

    const Uncertainty::Notes_optional& Uncertainty::
    Notes () const
    {
      return this->Notes_;
    }

    Uncertainty::Notes_optional& Uncertainty::
    Notes ()
    {
      return this->Notes_;
    }

    void Uncertainty::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void Uncertainty::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void Uncertainty::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }

    const Uncertainty::Scale_optional& Uncertainty::
    Scale () const
    {
      return this->Scale_;
    }

    Uncertainty::Scale_optional& Uncertainty::
    Scale ()
    {
      return this->Scale_;
    }

    void Uncertainty::
    Scale (const Scale_type& x)
    {
      this->Scale_.set (x);
    }

    void Uncertainty::
    Scale (const Scale_optional& x)
    {
      this->Scale_ = x;
    }

    void Uncertainty::
    Scale (::std::unique_ptr< Scale_type > x)
    {
      this->Scale_.set (std::move (x));
    }

    const Uncertainty::Scale_type& Uncertainty::
    Scale_default_value ()
    {
      return Scale_default_value_;
    }

    const Uncertainty::DistributionType_type& Uncertainty::
    DistributionType () const
    {
      return this->DistributionType_.get ();
    }

    Uncertainty::DistributionType_type& Uncertainty::
    DistributionType ()
    {
      return this->DistributionType_.get ();
    }

    void Uncertainty::
    DistributionType (const DistributionType_type& x)
    {
      this->DistributionType_.set (x);
    }

    void Uncertainty::
    DistributionType (::std::unique_ptr< DistributionType_type > x)
    {
      this->DistributionType_.set (std::move (x));
    }

    const Uncertainty::DistributionType_type& Uncertainty::
    DistributionType_default_value ()
    {
      return DistributionType_default_value_;
    }

    const Uncertainty::Num_Std_Dev_type& Uncertainty::
    Num_Std_Dev () const
    {
      return this->Num_Std_Dev_.get ();
    }

    Uncertainty::Num_Std_Dev_type& Uncertainty::
    Num_Std_Dev ()
    {
      return this->Num_Std_Dev_.get ();
    }

    void Uncertainty::
    Num_Std_Dev (const Num_Std_Dev_type& x)
    {
      this->Num_Std_Dev_.set (x);
    }

    Uncertainty::Num_Std_Dev_type Uncertainty::
    Num_Std_Dev_default_value ()
    {
      return Num_Std_Dev_type (2.0F);
    }

    const Uncertainty::Percentile_optional& Uncertainty::
    Percentile () const
    {
      return this->Percentile_;
    }

    Uncertainty::Percentile_optional& Uncertainty::
    Percentile ()
    {
      return this->Percentile_;
    }

    void Uncertainty::
    Percentile (const Percentile_type& x)
    {
      this->Percentile_.set (x);
    }

    void Uncertainty::
    Percentile (const Percentile_optional& x)
    {
      this->Percentile_ = x;
    }

    const Uncertainty::ConfidenceLevel_optional& Uncertainty::
    ConfidenceLevel () const
    {
      return this->ConfidenceLevel_;
    }

    Uncertainty::ConfidenceLevel_optional& Uncertainty::
    ConfidenceLevel ()
    {
      return this->ConfidenceLevel_;
    }

    void Uncertainty::
    ConfidenceLevel (const ConfidenceLevel_type& x)
    {
      this->ConfidenceLevel_.set (x);
    }

    void Uncertainty::
    ConfidenceLevel (const ConfidenceLevel_optional& x)
    {
      this->ConfidenceLevel_ = x;
    }


    // Unit
    // 

    const Unit::Name_optional& Unit::
    Name () const
    {
      return this->Name_;
    }

    Unit::Name_optional& Unit::
    Name ()
    {
      return this->Name_;
    }

    void Unit::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void Unit::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void Unit::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const Unit::Currency_optional& Unit::
    Currency () const
    {
      return this->Currency_;
    }

    Unit::Currency_optional& Unit::
    Currency ()
    {
      return this->Currency_;
    }

    void Unit::
    Currency (const Currency_type& x)
    {
      this->Currency_.set (x);
    }

    void Unit::
    Currency (const Currency_optional& x)
    {
      this->Currency_ = x;
    }

    void Unit::
    Currency (::std::unique_ptr< Currency_type > x)
    {
      this->Currency_.set (std::move (x));
    }

    const Unit::power_optional& Unit::
    power () const
    {
      return this->power_;
    }

    Unit::power_optional& Unit::
    power ()
    {
      return this->power_;
    }

    void Unit::
    power (const power_type& x)
    {
      this->power_.set (x);
    }

    void Unit::
    power (const power_optional& x)
    {
      this->power_ = x;
    }

    const Unit::description_optional& Unit::
    description () const
    {
      return this->description_;
    }

    Unit::description_optional& Unit::
    description ()
    {
      return this->description_;
    }

    void Unit::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void Unit::
    description (const description_optional& x)
    {
      this->description_ = x;
    }

    void Unit::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }


    // Unitless
    // 


    // Units
    // 

    const Units::Unit_sequence& Units::
    Unit () const
    {
      return this->Unit_;
    }

    Units::Unit_sequence& Units::
    Unit ()
    {
      return this->Unit_;
    }

    void Units::
    Unit (const Unit_sequence& s)
    {
      this->Unit_ = s;
    }

    const Units::system_optional& Units::
    system () const
    {
      return this->system_;
    }

    Units::system_optional& Units::
    system ()
    {
      return this->system_;
    }

    void Units::
    system (const system_type& x)
    {
      this->system_.set (x);
    }

    void Units::
    system (const system_optional& x)
    {
      this->system_ = x;
    }

    void Units::
    system (::std::unique_ptr< system_type > x)
    {
      this->system_.set (std::move (x));
    }

    const Units::factor_optional& Units::
    factor () const
    {
      return this->factor_;
    }

    Units::factor_optional& Units::
    factor ()
    {
      return this->factor_;
    }

    void Units::
    factor (const factor_type& x)
    {
      this->factor_.set (x);
    }

    void Units::
    factor (const factor_optional& x)
    {
      this->factor_ = x;
    }

    const Units::name_optional& Units::
    name () const
    {
      return this->name_;
    }

    Units::name_optional& Units::
    name ()
    {
      return this->name_;
    }

    void Units::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void Units::
    name (const name_optional& x)
    {
      this->name_ = x;
    }

    void Units::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const Units::description_optional& Units::
    description () const
    {
      return this->description_;
    }

    Units::description_optional& Units::
    description ()
    {
      return this->description_;
    }

    void Units::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void Units::
    description (const description_optional& x)
    {
      this->description_ = x;
    }

    void Units::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }


    // Value
    // 

    const Value::format_type& Value::
    format () const
    {
      return this->format_.get ();
    }

    Value::format_type& Value::
    format ()
    {
      return this->format_.get ();
    }

    void Value::
    format (const format_type& x)
    {
      this->format_.set (x);
    }

    void Value::
    format (::std::unique_ptr< format_type > x)
    {
      this->format_.set (std::move (x));
    }


    // AuthorityDetails
    // 

    const AuthorityDetails::Name_type& AuthorityDetails::
    Name () const
    {
      return this->Name_.get ();
    }

    AuthorityDetails::Name_type& AuthorityDetails::
    Name ()
    {
      return this->Name_.get ();
    }

    void AuthorityDetails::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void AuthorityDetails::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const AuthorityDetails::Notes_optional& AuthorityDetails::
    Notes () const
    {
      return this->Notes_;
    }

    AuthorityDetails::Notes_optional& AuthorityDetails::
    Notes ()
    {
      return this->Notes_;
    }

    void AuthorityDetails::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void AuthorityDetails::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void AuthorityDetails::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }

    const AuthorityDetails::id_type& AuthorityDetails::
    id () const
    {
      return this->id_.get ();
    }

    AuthorityDetails::id_type& AuthorityDetails::
    id ()
    {
      return this->id_.get ();
    }

    void AuthorityDetails::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void AuthorityDetails::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // DataSourceDetails
    // 

    const DataSourceDetails::Name_type& DataSourceDetails::
    Name () const
    {
      return this->Name_.get ();
    }

    DataSourceDetails::Name_type& DataSourceDetails::
    Name ()
    {
      return this->Name_.get ();
    }

    void DataSourceDetails::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void DataSourceDetails::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const DataSourceDetails::Notes_optional& DataSourceDetails::
    Notes () const
    {
      return this->Notes_;
    }

    DataSourceDetails::Notes_optional& DataSourceDetails::
    Notes ()
    {
      return this->Notes_;
    }

    void DataSourceDetails::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void DataSourceDetails::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void DataSourceDetails::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }

    const DataSourceDetails::id_type& DataSourceDetails::
    id () const
    {
      return this->id_.get ();
    }

    DataSourceDetails::id_type& DataSourceDetails::
    id ()
    {
      return this->id_.get ();
    }

    void DataSourceDetails::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void DataSourceDetails::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const DataSourceDetails::type_optional& DataSourceDetails::
    type () const
    {
      return this->type_;
    }

    DataSourceDetails::type_optional& DataSourceDetails::
    type ()
    {
      return this->type_;
    }

    void DataSourceDetails::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void DataSourceDetails::
    type (const type_optional& x)
    {
      this->type_ = x;
    }

    void DataSourceDetails::
    type (::std::unique_ptr< type_type > x)
    {
      this->type_.set (std::move (x));
    }


    // MeasurementTechniqueDetails
    // 

    const MeasurementTechniqueDetails::Name_type& MeasurementTechniqueDetails::
    Name () const
    {
      return this->Name_.get ();
    }

    MeasurementTechniqueDetails::Name_type& MeasurementTechniqueDetails::
    Name ()
    {
      return this->Name_.get ();
    }

    void MeasurementTechniqueDetails::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void MeasurementTechniqueDetails::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const MeasurementTechniqueDetails::Notes_optional& MeasurementTechniqueDetails::
    Notes () const
    {
      return this->Notes_;
    }

    MeasurementTechniqueDetails::Notes_optional& MeasurementTechniqueDetails::
    Notes ()
    {
      return this->Notes_;
    }

    void MeasurementTechniqueDetails::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void MeasurementTechniqueDetails::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void MeasurementTechniqueDetails::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }

    const MeasurementTechniqueDetails::id_type& MeasurementTechniqueDetails::
    id () const
    {
      return this->id_.get ();
    }

    MeasurementTechniqueDetails::id_type& MeasurementTechniqueDetails::
    id ()
    {
      return this->id_.get ();
    }

    void MeasurementTechniqueDetails::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void MeasurementTechniqueDetails::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // ParameterDetails
    // 

    const ParameterDetails::Name_type& ParameterDetails::
    Name () const
    {
      return this->Name_.get ();
    }

    ParameterDetails::Name_type& ParameterDetails::
    Name ()
    {
      return this->Name_.get ();
    }

    void ParameterDetails::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void ParameterDetails::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const ParameterDetails::Units_optional& ParameterDetails::
    Units () const
    {
      return this->Units_;
    }

    ParameterDetails::Units_optional& ParameterDetails::
    Units ()
    {
      return this->Units_;
    }

    void ParameterDetails::
    Units (const Units_type& x)
    {
      this->Units_.set (x);
    }

    void ParameterDetails::
    Units (const Units_optional& x)
    {
      this->Units_ = x;
    }

    void ParameterDetails::
    Units (::std::unique_ptr< Units_type > x)
    {
      this->Units_.set (std::move (x));
    }

    const ParameterDetails::Unitless_optional& ParameterDetails::
    Unitless () const
    {
      return this->Unitless_;
    }

    ParameterDetails::Unitless_optional& ParameterDetails::
    Unitless ()
    {
      return this->Unitless_;
    }

    void ParameterDetails::
    Unitless (const Unitless_type& x)
    {
      this->Unitless_.set (x);
    }

    void ParameterDetails::
    Unitless (const Unitless_optional& x)
    {
      this->Unitless_ = x;
    }

    void ParameterDetails::
    Unitless (::std::unique_ptr< Unitless_type > x)
    {
      this->Unitless_.set (std::move (x));
    }

    const ParameterDetails::Notes_optional& ParameterDetails::
    Notes () const
    {
      return this->Notes_;
    }

    ParameterDetails::Notes_optional& ParameterDetails::
    Notes ()
    {
      return this->Notes_;
    }

    void ParameterDetails::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void ParameterDetails::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void ParameterDetails::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }

    const ParameterDetails::id_type& ParameterDetails::
    id () const
    {
      return this->id_.get ();
    }

    ParameterDetails::id_type& ParameterDetails::
    id ()
    {
      return this->id_.get ();
    }

    void ParameterDetails::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void ParameterDetails::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // PropertyDetails
    // 

    const PropertyDetails::Name_type& PropertyDetails::
    Name () const
    {
      return this->Name_.get ();
    }

    PropertyDetails::Name_type& PropertyDetails::
    Name ()
    {
      return this->Name_.get ();
    }

    void PropertyDetails::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void PropertyDetails::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const PropertyDetails::Units_optional& PropertyDetails::
    Units () const
    {
      return this->Units_;
    }

    PropertyDetails::Units_optional& PropertyDetails::
    Units ()
    {
      return this->Units_;
    }

    void PropertyDetails::
    Units (const Units_type& x)
    {
      this->Units_.set (x);
    }

    void PropertyDetails::
    Units (const Units_optional& x)
    {
      this->Units_ = x;
    }

    void PropertyDetails::
    Units (::std::unique_ptr< Units_type > x)
    {
      this->Units_.set (std::move (x));
    }

    const PropertyDetails::Unitless_optional& PropertyDetails::
    Unitless () const
    {
      return this->Unitless_;
    }

    PropertyDetails::Unitless_optional& PropertyDetails::
    Unitless ()
    {
      return this->Unitless_;
    }

    void PropertyDetails::
    Unitless (const Unitless_type& x)
    {
      this->Unitless_.set (x);
    }

    void PropertyDetails::
    Unitless (const Unitless_optional& x)
    {
      this->Unitless_ = x;
    }

    void PropertyDetails::
    Unitless (::std::unique_ptr< Unitless_type > x)
    {
      this->Unitless_.set (std::move (x));
    }

    const PropertyDetails::Notes_optional& PropertyDetails::
    Notes () const
    {
      return this->Notes_;
    }

    PropertyDetails::Notes_optional& PropertyDetails::
    Notes ()
    {
      return this->Notes_;
    }

    void PropertyDetails::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void PropertyDetails::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void PropertyDetails::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }

    const PropertyDetails::id_type& PropertyDetails::
    id () const
    {
      return this->id_.get ();
    }

    PropertyDetails::id_type& PropertyDetails::
    id ()
    {
      return this->id_.get ();
    }

    void PropertyDetails::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void PropertyDetails::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const PropertyDetails::type_optional& PropertyDetails::
    type () const
    {
      return this->type_;
    }

    PropertyDetails::type_optional& PropertyDetails::
    type ()
    {
      return this->type_;
    }

    void PropertyDetails::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void PropertyDetails::
    type (const type_optional& x)
    {
      this->type_ = x;
    }

    void PropertyDetails::
    type (::std::unique_ptr< type_type > x)
    {
      this->type_.set (std::move (x));
    }


    // SourceDetails
    // 

    const SourceDetails::Name_type& SourceDetails::
    Name () const
    {
      return this->Name_.get ();
    }

    SourceDetails::Name_type& SourceDetails::
    Name ()
    {
      return this->Name_.get ();
    }

    void SourceDetails::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void SourceDetails::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const SourceDetails::Notes_optional& SourceDetails::
    Notes () const
    {
      return this->Notes_;
    }

    SourceDetails::Notes_optional& SourceDetails::
    Notes ()
    {
      return this->Notes_;
    }

    void SourceDetails::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void SourceDetails::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void SourceDetails::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }

    const SourceDetails::id_type& SourceDetails::
    id () const
    {
      return this->id_.get ();
    }

    SourceDetails::id_type& SourceDetails::
    id ()
    {
      return this->id_.get ();
    }

    void SourceDetails::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void SourceDetails::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const SourceDetails::type_optional& SourceDetails::
    type () const
    {
      return this->type_;
    }

    SourceDetails::type_optional& SourceDetails::
    type ()
    {
      return this->type_;
    }

    void SourceDetails::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void SourceDetails::
    type (const type_optional& x)
    {
      this->type_ = x;
    }

    void SourceDetails::
    type (::std::unique_ptr< type_type > x)
    {
      this->type_.set (std::move (x));
    }


    // SpecimenDetails
    // 

    const SpecimenDetails::Name_optional& SpecimenDetails::
    Name () const
    {
      return this->Name_;
    }

    SpecimenDetails::Name_optional& SpecimenDetails::
    Name ()
    {
      return this->Name_;
    }

    void SpecimenDetails::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void SpecimenDetails::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void SpecimenDetails::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const SpecimenDetails::Notes_optional& SpecimenDetails::
    Notes () const
    {
      return this->Notes_;
    }

    SpecimenDetails::Notes_optional& SpecimenDetails::
    Notes ()
    {
      return this->Notes_;
    }

    void SpecimenDetails::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void SpecimenDetails::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void SpecimenDetails::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }

    const SpecimenDetails::Geometry_optional& SpecimenDetails::
    Geometry () const
    {
      return this->Geometry_;
    }

    SpecimenDetails::Geometry_optional& SpecimenDetails::
    Geometry ()
    {
      return this->Geometry_;
    }

    void SpecimenDetails::
    Geometry (const Geometry_type& x)
    {
      this->Geometry_.set (x);
    }

    void SpecimenDetails::
    Geometry (const Geometry_optional& x)
    {
      this->Geometry_ = x;
    }

    void SpecimenDetails::
    Geometry (::std::unique_ptr< Geometry_type > x)
    {
      this->Geometry_.set (std::move (x));
    }

    const SpecimenDetails::id_type& SpecimenDetails::
    id () const
    {
      return this->id_.get ();
    }

    SpecimenDetails::id_type& SpecimenDetails::
    id ()
    {
      return this->id_.get ();
    }

    void SpecimenDetails::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void SpecimenDetails::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const SpecimenDetails::type_optional& SpecimenDetails::
    type () const
    {
      return this->type_;
    }

    SpecimenDetails::type_optional& SpecimenDetails::
    type ()
    {
      return this->type_;
    }

    void SpecimenDetails::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void SpecimenDetails::
    type (const type_optional& x)
    {
      this->type_ = x;
    }

    void SpecimenDetails::
    type (::std::unique_ptr< type_type > x)
    {
      this->type_.set (std::move (x));
    }


    // TestConditionDetails
    // 

    const TestConditionDetails::ParameterValue_sequence& TestConditionDetails::
    ParameterValue () const
    {
      return this->ParameterValue_;
    }

    TestConditionDetails::ParameterValue_sequence& TestConditionDetails::
    ParameterValue ()
    {
      return this->ParameterValue_;
    }

    void TestConditionDetails::
    ParameterValue (const ParameterValue_sequence& s)
    {
      this->ParameterValue_ = s;
    }

    const TestConditionDetails::Notes_optional& TestConditionDetails::
    Notes () const
    {
      return this->Notes_;
    }

    TestConditionDetails::Notes_optional& TestConditionDetails::
    Notes ()
    {
      return this->Notes_;
    }

    void TestConditionDetails::
    Notes (const Notes_type& x)
    {
      this->Notes_.set (x);
    }

    void TestConditionDetails::
    Notes (const Notes_optional& x)
    {
      this->Notes_ = x;
    }

    void TestConditionDetails::
    Notes (::std::unique_ptr< Notes_type > x)
    {
      this->Notes_.set (std::move (x));
    }

    const TestConditionDetails::id_type& TestConditionDetails::
    id () const
    {
      return this->id_.get ();
    }

    TestConditionDetails::id_type& TestConditionDetails::
    id ()
    {
      return this->id_.get ();
    }

    void TestConditionDetails::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void TestConditionDetails::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // ChemicalElementSymbol
    // 

    ChemicalElementSymbol::
    ChemicalElementSymbol (value v)
    : ::xml_schema::string (_xsd_ChemicalElementSymbol_literals_[v])
    {
    }

    ChemicalElementSymbol::
    ChemicalElementSymbol (const char* v)
    : ::xml_schema::string (v)
    {
    }

    ChemicalElementSymbol::
    ChemicalElementSymbol (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    ChemicalElementSymbol::
    ChemicalElementSymbol (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    ChemicalElementSymbol::
    ChemicalElementSymbol (const ChemicalElementSymbol& v,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    ChemicalElementSymbol& ChemicalElementSymbol::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_ChemicalElementSymbol_literals_[v]);

      return *this;
    }


    // CurrencyCode
    // 

    CurrencyCode::
    CurrencyCode (value v)
    : ::xml_schema::string (_xsd_CurrencyCode_literals_[v])
    {
    }

    CurrencyCode::
    CurrencyCode (const char* v)
    : ::xml_schema::string (v)
    {
    }

    CurrencyCode::
    CurrencyCode (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    CurrencyCode::
    CurrencyCode (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    CurrencyCode::
    CurrencyCode (const CurrencyCode& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    CurrencyCode& CurrencyCode::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_CurrencyCode_literals_[v]);

      return *this;
    }


    // Associate_lib
    // 

    const Associate_lib::value_type& Associate_lib::
    value () const
    {
      return this->value_.get ();
    }

    Associate_lib::value_type& Associate_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Associate_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Associate_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // AssociationDetails_lib
    // 

    const AssociationDetails_lib::value_type& AssociationDetails_lib::
    value () const
    {
      return this->value_.get ();
    }

    AssociationDetails_lib::value_type& AssociationDetails_lib::
    value ()
    {
      return this->value_.get ();
    }

    void AssociationDetails_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void AssociationDetails_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // AuthorityDetails_lib
    // 

    const AuthorityDetails_lib::value_type& AuthorityDetails_lib::
    value () const
    {
      return this->value_.get ();
    }

    AuthorityDetails_lib::value_type& AuthorityDetails_lib::
    value ()
    {
      return this->value_.get ();
    }

    void AuthorityDetails_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void AuthorityDetails_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // BulkDetails_lib
    // 

    const BulkDetails_lib::value_type& BulkDetails_lib::
    value () const
    {
      return this->value_.get ();
    }

    BulkDetails_lib::value_type& BulkDetails_lib::
    value ()
    {
      return this->value_.get ();
    }

    void BulkDetails_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void BulkDetails_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Characterization_lib
    // 

    const Characterization_lib::value_type& Characterization_lib::
    value () const
    {
      return this->value_.get ();
    }

    Characterization_lib::value_type& Characterization_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Characterization_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Characterization_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // ChemicalComposition_lib
    // 

    const ChemicalComposition_lib::value_type& ChemicalComposition_lib::
    value () const
    {
      return this->value_.get ();
    }

    ChemicalComposition_lib::value_type& ChemicalComposition_lib::
    value ()
    {
      return this->value_.get ();
    }

    void ChemicalComposition_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void ChemicalComposition_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // ChemicalElementSymbol_lib
    // 

    const ChemicalElementSymbol_lib::value_type& ChemicalElementSymbol_lib::
    value () const
    {
      return this->value_.get ();
    }

    ChemicalElementSymbol_lib::value_type& ChemicalElementSymbol_lib::
    value ()
    {
      return this->value_.get ();
    }

    void ChemicalElementSymbol_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void ChemicalElementSymbol_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Class_lib
    // 

    const Class_lib::value_type& Class_lib::
    value () const
    {
      return this->value_.get ();
    }

    Class_lib::value_type& Class_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Class_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Class_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // ComponentDetails_lib
    // 

    const ComponentDetails_lib::value_type& ComponentDetails_lib::
    value () const
    {
      return this->value_.get ();
    }

    ComponentDetails_lib::value_type& ComponentDetails_lib::
    value ()
    {
      return this->value_.get ();
    }

    void ComponentDetails_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void ComponentDetails_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Compound_lib
    // 

    const Compound_lib::value_type& Compound_lib::
    value () const
    {
      return this->value_.get ();
    }

    Compound_lib::value_type& Compound_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Compound_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Compound_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Concentration_lib
    // 

    const Concentration_lib::value_type& Concentration_lib::
    value () const
    {
      return this->value_.get ();
    }

    Concentration_lib::value_type& Concentration_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Concentration_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Concentration_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // CurrencyCode_lib
    // 

    const CurrencyCode_lib::value_type& CurrencyCode_lib::
    value () const
    {
      return this->value_.get ();
    }

    CurrencyCode_lib::value_type& CurrencyCode_lib::
    value ()
    {
      return this->value_.get ();
    }

    void CurrencyCode_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void CurrencyCode_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // DataFormat_lib
    // 

    const DataFormat_lib::value_type& DataFormat_lib::
    value () const
    {
      return this->value_.get ();
    }

    DataFormat_lib::value_type& DataFormat_lib::
    value ()
    {
      return this->value_.get ();
    }

    void DataFormat_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void DataFormat_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // DataSourceDetails_lib
    // 

    const DataSourceDetails_lib::value_type& DataSourceDetails_lib::
    value () const
    {
      return this->value_.get ();
    }

    DataSourceDetails_lib::value_type& DataSourceDetails_lib::
    value ()
    {
      return this->value_.get ();
    }

    void DataSourceDetails_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void DataSourceDetails_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // DimensionalDetails_lib
    // 

    const DimensionalDetails_lib::value_type& DimensionalDetails_lib::
    value () const
    {
      return this->value_.get ();
    }

    DimensionalDetails_lib::value_type& DimensionalDetails_lib::
    value ()
    {
      return this->value_.get ();
    }

    void DimensionalDetails_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void DimensionalDetails_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Element_lib
    // 

    const Element_lib::value_type& Element_lib::
    value () const
    {
      return this->value_.get ();
    }

    Element_lib::value_type& Element_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Element_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Element_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Form_lib
    // 

    const Form_lib::value_type& Form_lib::
    value () const
    {
      return this->value_.get ();
    }

    Form_lib::value_type& Form_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Form_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Form_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Formula_lib
    // 

    const Formula_lib::value_type& Formula_lib::
    value () const
    {
      return this->value_.get ();
    }

    Formula_lib::value_type& Formula_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Formula_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Formula_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Geometry_lib
    // 

    const Geometry_lib::value_type& Geometry_lib::
    value () const
    {
      return this->value_.get ();
    }

    Geometry_lib::value_type& Geometry_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Geometry_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Geometry_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Glossary_lib
    // 

    const Glossary_lib::value_type& Glossary_lib::
    value () const
    {
      return this->value_.get ();
    }

    Glossary_lib::value_type& Glossary_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Glossary_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Glossary_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // GlossaryTerm_lib
    // 

    const GlossaryTerm_lib::value_type& GlossaryTerm_lib::
    value () const
    {
      return this->value_.get ();
    }

    GlossaryTerm_lib::value_type& GlossaryTerm_lib::
    value ()
    {
      return this->value_.get ();
    }

    void GlossaryTerm_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void GlossaryTerm_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Graphs_lib
    // 

    const Graphs_lib::value_type& Graphs_lib::
    value () const
    {
      return this->value_.get ();
    }

    Graphs_lib::value_type& Graphs_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Graphs_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Graphs_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Material_lib
    // 

    const Material_lib::value_type& Material_lib::
    value () const
    {
      return this->value_.get ();
    }

    Material_lib::value_type& Material_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Material_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Material_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // MeasurementTechniqueDetails_lib
    // 

    const MeasurementTechniqueDetails_lib::value_type& MeasurementTechniqueDetails_lib::
    value () const
    {
      return this->value_.get ();
    }

    MeasurementTechniqueDetails_lib::value_type& MeasurementTechniqueDetails_lib::
    value ()
    {
      return this->value_.get ();
    }

    void MeasurementTechniqueDetails_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void MeasurementTechniqueDetails_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Metadata_lib
    // 

    const Metadata_lib::value_type& Metadata_lib::
    value () const
    {
      return this->value_.get ();
    }

    Metadata_lib::value_type& Metadata_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Metadata_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Metadata_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Name_lib
    // 

    const Name_lib::value_type& Name_lib::
    value () const
    {
      return this->value_.get ();
    }

    Name_lib::value_type& Name_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Name_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Name_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Notes_lib
    // 

    const Notes_lib::value_type& Notes_lib::
    value () const
    {
      return this->value_.get ();
    }

    Notes_lib::value_type& Notes_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Notes_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Notes_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // ParameterDetails_lib
    // 

    const ParameterDetails_lib::value_type& ParameterDetails_lib::
    value () const
    {
      return this->value_.get ();
    }

    ParameterDetails_lib::value_type& ParameterDetails_lib::
    value ()
    {
      return this->value_.get ();
    }

    void ParameterDetails_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void ParameterDetails_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // ParameterValue_lib
    // 

    const ParameterValue_lib::value_type& ParameterValue_lib::
    value () const
    {
      return this->value_.get ();
    }

    ParameterValue_lib::value_type& ParameterValue_lib::
    value ()
    {
      return this->value_.get ();
    }

    void ParameterValue_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void ParameterValue_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // PhaseComposition_lib
    // 

    const PhaseComposition_lib::value_type& PhaseComposition_lib::
    value () const
    {
      return this->value_.get ();
    }

    PhaseComposition_lib::value_type& PhaseComposition_lib::
    value ()
    {
      return this->value_.get ();
    }

    void PhaseComposition_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void PhaseComposition_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // ProcessingDetails_lib
    // 

    const ProcessingDetails_lib::value_type& ProcessingDetails_lib::
    value () const
    {
      return this->value_.get ();
    }

    ProcessingDetails_lib::value_type& ProcessingDetails_lib::
    value ()
    {
      return this->value_.get ();
    }

    void ProcessingDetails_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void ProcessingDetails_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // PropertyData_lib
    // 

    const PropertyData_lib::value_type& PropertyData_lib::
    value () const
    {
      return this->value_.get ();
    }

    PropertyData_lib::value_type& PropertyData_lib::
    value ()
    {
      return this->value_.get ();
    }

    void PropertyData_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void PropertyData_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // PropertyDetails_lib
    // 

    const PropertyDetails_lib::value_type& PropertyDetails_lib::
    value () const
    {
      return this->value_.get ();
    }

    PropertyDetails_lib::value_type& PropertyDetails_lib::
    value ()
    {
      return this->value_.get ();
    }

    void PropertyDetails_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void PropertyDetails_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Qualifier_lib
    // 

    const Qualifier_lib::value_type& Qualifier_lib::
    value () const
    {
      return this->value_.get ();
    }

    Qualifier_lib::value_type& Qualifier_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Qualifier_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Qualifier_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Relationship_lib
    // 

    const Relationship_lib::value_type& Relationship_lib::
    value () const
    {
      return this->value_.get ();
    }

    Relationship_lib::value_type& Relationship_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Relationship_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Relationship_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Source_lib
    // 

    const Source_lib::value_type& Source_lib::
    value () const
    {
      return this->value_.get ();
    }

    Source_lib::value_type& Source_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Source_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Source_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // SourceDetails_lib
    // 

    const SourceDetails_lib::value_type& SourceDetails_lib::
    value () const
    {
      return this->value_.get ();
    }

    SourceDetails_lib::value_type& SourceDetails_lib::
    value ()
    {
      return this->value_.get ();
    }

    void SourceDetails_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void SourceDetails_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Specification_lib
    // 

    const Specification_lib::value_type& Specification_lib::
    value () const
    {
      return this->value_.get ();
    }

    Specification_lib::value_type& Specification_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Specification_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Specification_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // SpecimenDetails_lib
    // 

    const SpecimenDetails_lib::value_type& SpecimenDetails_lib::
    value () const
    {
      return this->value_.get ();
    }

    SpecimenDetails_lib::value_type& SpecimenDetails_lib::
    value ()
    {
      return this->value_.get ();
    }

    void SpecimenDetails_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void SpecimenDetails_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // TestConditionDetails_lib
    // 

    const TestConditionDetails_lib::value_type& TestConditionDetails_lib::
    value () const
    {
      return this->value_.get ();
    }

    TestConditionDetails_lib::value_type& TestConditionDetails_lib::
    value ()
    {
      return this->value_.get ();
    }

    void TestConditionDetails_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void TestConditionDetails_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Uncertainty_lib
    // 

    const Uncertainty_lib::value_type& Uncertainty_lib::
    value () const
    {
      return this->value_.get ();
    }

    Uncertainty_lib::value_type& Uncertainty_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Uncertainty_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Uncertainty_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Unit_lib
    // 

    const Unit_lib::value_type& Unit_lib::
    value () const
    {
      return this->value_.get ();
    }

    Unit_lib::value_type& Unit_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Unit_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Unit_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Unitless_lib
    // 

    const Unitless_lib::value_type& Unitless_lib::
    value () const
    {
      return this->value_.get ();
    }

    Unitless_lib::value_type& Unitless_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Unitless_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Unitless_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Units_lib
    // 

    const Units_lib::value_type& Units_lib::
    value () const
    {
      return this->value_.get ();
    }

    Units_lib::value_type& Units_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Units_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Units_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // Value_lib
    // 

    const Value_lib::value_type& Value_lib::
    value () const
    {
      return this->value_.get ();
    }

    Value_lib::value_type& Value_lib::
    value ()
    {
      return this->value_.get ();
    }

    void Value_lib::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Value_lib::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    // ParentMaterial
    // 

    const ParentMaterial::id_type& ParentMaterial::
    id () const
    {
      return this->id_.get ();
    }

    ParentMaterial::id_type& ParentMaterial::
    id ()
    {
      return this->id_.get ();
    }

    void ParentMaterial::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void ParentMaterial::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // Symbol
    // 

    const Symbol::subscript_type& Symbol::
    subscript () const
    {
      return this->subscript_.get ();
    }

    Symbol::subscript_type& Symbol::
    subscript ()
    {
      return this->subscript_.get ();
    }

    void Symbol::
    subscript (const subscript_type& x)
    {
      this->subscript_.set (x);
    }

    void Symbol::
    subscript (::std::unique_ptr< subscript_type > x)
    {
      this->subscript_.set (std::move (x));
    }

    const Symbol::subscript_type& Symbol::
    subscript_default_value ()
    {
      return subscript_default_value_;
    }


    // Graph
    // 


    // Data
    // 

    const Data::format_optional& Data::
    format () const
    {
      return this->format_;
    }

    Data::format_optional& Data::
    format ()
    {
      return this->format_;
    }

    void Data::
    format (const format_type& x)
    {
      this->format_.set (x);
    }

    void Data::
    format (const format_optional& x)
    {
      this->format_ = x;
    }

    void Data::
    format (::std::unique_ptr< format_type > x)
    {
      this->format_.set (std::move (x));
    }


    // Data1
    // 

    const Data1::format_type& Data1::
    format () const
    {
      return this->format_.get ();
    }

    Data1::format_type& Data1::
    format ()
    {
      return this->format_.get ();
    }

    void Data1::
    format (const format_type& x)
    {
      this->format_.set (x);
    }

    void Data1::
    format (::std::unique_ptr< format_type > x)
    {
      this->format_.set (std::move (x));
    }


    // delimiter
    // 


    // Scale
    // 

    Scale::
    Scale (value v)
    : ::xml_schema::string (_xsd_Scale_literals_[v])
    {
    }

    Scale::
    Scale (const char* v)
    : ::xml_schema::string (v)
    {
    }

    Scale::
    Scale (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    Scale::
    Scale (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    Scale::
    Scale (const Scale& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    Scale& Scale::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_Scale_literals_[v]);

      return *this;
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace bellshire
{
  namespace lib
  {
    // Associate
    //

    Associate::
    Associate ()
    : ::xml_schema::string ()
    {
    }

    Associate::
    Associate (const char* _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    Associate::
    Associate (const ::std::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    Associate::
    Associate (const ::xml_schema::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    Associate::
    Associate (const Associate& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    Associate::
    Associate (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    Associate::
    Associate (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    Associate::
    Associate (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    Associate* Associate::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Associate (*this, f, c);
    }

    Associate::
    ~Associate ()
    {
    }

    // AssociationDetails
    //

    AssociationDetails::
    AssociationDetails ()
    : ::xml_schema::type (),
      Associate_ (this),
      Relationship_ (this),
      Notes_ (this)
    {
    }

    AssociationDetails::
    AssociationDetails (const AssociationDetails& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Associate_ (x.Associate_, f, this),
      Relationship_ (x.Relationship_, f, this),
      Notes_ (x.Notes_, f, this)
    {
    }

    AssociationDetails::
    AssociationDetails (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Associate_ (this),
      Relationship_ (this),
      Notes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AssociationDetails::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Associate
        //
        if (n.name () == "Associate" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Associate_type > r (
            Associate_traits::create (i, f, this));

          if (!this->Associate_)
          {
            this->Associate_.set (::std::move (r));
            continue;
          }
        }

        // Relationship
        //
        if (n.name () == "Relationship" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Relationship_type > r (
            Relationship_traits::create (i, f, this));

          if (!this->Relationship_)
          {
            this->Relationship_.set (::std::move (r));
            continue;
          }
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    AssociationDetails* AssociationDetails::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AssociationDetails (*this, f, c);
    }

    AssociationDetails& AssociationDetails::
    operator= (const AssociationDetails& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Associate_ = x.Associate_;
        this->Relationship_ = x.Relationship_;
        this->Notes_ = x.Notes_;
      }

      return *this;
    }

    AssociationDetails::
    ~AssociationDetails ()
    {
    }

    // BulkDetails
    //

    BulkDetails::
    BulkDetails (const Name_type& Name)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Class_ (this),
      Subclass_ (this),
      Specification_ (this),
      Source_ (this),
      Form_ (this),
      ProcessingDetails_ (this),
      Characterization_ (this),
      PropertyData_ (this),
      Notes_ (this)
    {
    }

    BulkDetails::
    BulkDetails (::std::unique_ptr< Name_type > Name)
    : ::xml_schema::type (),
      Name_ (std::move (Name), this),
      Class_ (this),
      Subclass_ (this),
      Specification_ (this),
      Source_ (this),
      Form_ (this),
      ProcessingDetails_ (this),
      Characterization_ (this),
      PropertyData_ (this),
      Notes_ (this)
    {
    }

    BulkDetails::
    BulkDetails (const BulkDetails& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Class_ (x.Class_, f, this),
      Subclass_ (x.Subclass_, f, this),
      Specification_ (x.Specification_, f, this),
      Source_ (x.Source_, f, this),
      Form_ (x.Form_, f, this),
      ProcessingDetails_ (x.ProcessingDetails_, f, this),
      Characterization_ (x.Characterization_, f, this),
      PropertyData_ (x.PropertyData_, f, this),
      Notes_ (x.Notes_, f, this)
    {
    }

    BulkDetails::
    BulkDetails (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Class_ (this),
      Subclass_ (this),
      Specification_ (this),
      Source_ (this),
      Form_ (this),
      ProcessingDetails_ (this),
      Characterization_ (this),
      PropertyData_ (this),
      Notes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void BulkDetails::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Class
        //
        if (n.name () == "Class" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Class_type > r (
            Class_traits::create (i, f, this));

          this->Class_.push_back (::std::move (r));
          continue;
        }

        // Subclass
        //
        if (n.name () == "Subclass" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Subclass_type > r (
            Subclass_traits::create (i, f, this));

          this->Subclass_.push_back (::std::move (r));
          continue;
        }

        // Specification
        //
        if (n.name () == "Specification" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Specification_type > r (
            Specification_traits::create (i, f, this));

          this->Specification_.push_back (::std::move (r));
          continue;
        }

        // Source
        //
        if (n.name () == "Source" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Source_type > r (
            Source_traits::create (i, f, this));

          if (!this->Source_)
          {
            this->Source_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        // ProcessingDetails
        //
        if (n.name () == "ProcessingDetails" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ProcessingDetails_type > r (
            ProcessingDetails_traits::create (i, f, this));

          this->ProcessingDetails_.push_back (::std::move (r));
          continue;
        }

        // Characterization
        //
        if (n.name () == "Characterization" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Characterization_type > r (
            Characterization_traits::create (i, f, this));

          if (!this->Characterization_)
          {
            this->Characterization_.set (::std::move (r));
            continue;
          }
        }

        // PropertyData
        //
        if (n.name () == "PropertyData" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< PropertyData_type > r (
            PropertyData_traits::create (i, f, this));

          this->PropertyData_.push_back (::std::move (r));
          continue;
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "");
      }
    }

    BulkDetails* BulkDetails::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BulkDetails (*this, f, c);
    }

    BulkDetails& BulkDetails::
    operator= (const BulkDetails& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Class_ = x.Class_;
        this->Subclass_ = x.Subclass_;
        this->Specification_ = x.Specification_;
        this->Source_ = x.Source_;
        this->Form_ = x.Form_;
        this->ProcessingDetails_ = x.ProcessingDetails_;
        this->Characterization_ = x.Characterization_;
        this->PropertyData_ = x.PropertyData_;
        this->Notes_ = x.Notes_;
      }

      return *this;
    }

    BulkDetails::
    ~BulkDetails ()
    {
    }

    // Characterization
    //

    Characterization::
    Characterization (const Formula_type& Formula)
    : ::xml_schema::type (),
      Formula_ (Formula, this),
      ChemicalComposition_ (this),
      PhaseComposition_ (this),
      DimensionalDetails_ (this),
      Notes_ (this)
    {
    }

    Characterization::
    Characterization (const Characterization& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Formula_ (x.Formula_, f, this),
      ChemicalComposition_ (x.ChemicalComposition_, f, this),
      PhaseComposition_ (x.PhaseComposition_, f, this),
      DimensionalDetails_ (x.DimensionalDetails_, f, this),
      Notes_ (x.Notes_, f, this)
    {
    }

    Characterization::
    Characterization (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Formula_ (this),
      ChemicalComposition_ (this),
      PhaseComposition_ (this),
      DimensionalDetails_ (this),
      Notes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Characterization::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Formula
        //
        if (n.name () == "Formula" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Formula_type > r (
            Formula_traits::create (i, f, this));

          if (!Formula_.present ())
          {
            this->Formula_.set (::std::move (r));
            continue;
          }
        }

        // ChemicalComposition
        //
        if (n.name () == "ChemicalComposition" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ChemicalComposition_type > r (
            ChemicalComposition_traits::create (i, f, this));

          if (!this->ChemicalComposition_)
          {
            this->ChemicalComposition_.set (::std::move (r));
            continue;
          }
        }

        // PhaseComposition
        //
        if (n.name () == "PhaseComposition" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< PhaseComposition_type > r (
            PhaseComposition_traits::create (i, f, this));

          this->PhaseComposition_.push_back (::std::move (r));
          continue;
        }

        // DimensionalDetails
        //
        if (n.name () == "DimensionalDetails" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< DimensionalDetails_type > r (
            DimensionalDetails_traits::create (i, f, this));

          this->DimensionalDetails_.push_back (::std::move (r));
          continue;
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Formula_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Formula",
          "");
      }
    }

    Characterization* Characterization::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Characterization (*this, f, c);
    }

    Characterization& Characterization::
    operator= (const Characterization& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Formula_ = x.Formula_;
        this->ChemicalComposition_ = x.ChemicalComposition_;
        this->PhaseComposition_ = x.PhaseComposition_;
        this->DimensionalDetails_ = x.DimensionalDetails_;
        this->Notes_ = x.Notes_;
      }

      return *this;
    }

    Characterization::
    ~Characterization ()
    {
    }

    // ChemicalComposition
    //

    ChemicalComposition::
    ChemicalComposition ()
    : ::xml_schema::type (),
      Compound_ (this),
      Element_ (this)
    {
    }

    ChemicalComposition::
    ChemicalComposition (const ChemicalComposition& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Compound_ (x.Compound_, f, this),
      Element_ (x.Element_, f, this)
    {
    }

    ChemicalComposition::
    ChemicalComposition (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Compound_ (this),
      Element_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ChemicalComposition::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Compound
        //
        if (n.name () == "Compound" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Compound_type > r (
            Compound_traits::create (i, f, this));

          this->Compound_.push_back (::std::move (r));
          continue;
        }

        // Element
        //
        if (n.name () == "Element" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Element_type > r (
            Element_traits::create (i, f, this));

          this->Element_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    ChemicalComposition* ChemicalComposition::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ChemicalComposition (*this, f, c);
    }

    ChemicalComposition& ChemicalComposition::
    operator= (const ChemicalComposition& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Compound_ = x.Compound_;
        this->Element_ = x.Element_;
      }

      return *this;
    }

    ChemicalComposition::
    ~ChemicalComposition ()
    {
    }

    // Class
    //

    Class::
    Class ()
    : ::xml_schema::type (),
      Name_ (this),
      ParentMaterial_ (this),
      ParentSubClass_ (this)
    {
    }

    Class::
    Class (const Class& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      ParentMaterial_ (x.ParentMaterial_, f, this),
      ParentSubClass_ (x.ParentSubClass_, f, this)
    {
    }

    Class::
    Class (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      ParentMaterial_ (this),
      ParentSubClass_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Class::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // ParentMaterial
        //
        if (n.name () == "ParentMaterial" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ParentMaterial_type > r (
            ParentMaterial_traits::create (i, f, this));

          this->ParentMaterial_.push_back (::std::move (r));
          continue;
        }

        // ParentSubClass
        //
        if (n.name () == "ParentSubClass" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ParentSubClass_type > r (
            ParentSubClass_traits::create (i, f, this));

          this->ParentSubClass_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    Class* Class::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Class (*this, f, c);
    }

    Class& Class::
    operator= (const Class& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->ParentMaterial_ = x.ParentMaterial_;
        this->ParentSubClass_ = x.ParentSubClass_;
      }

      return *this;
    }

    Class::
    ~Class ()
    {
    }

    // ComponentDetails
    //

    ComponentDetails::
    ComponentDetails (const Name_type& Name)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Class_ (this),
      Subclass_ (this),
      Specification_ (this),
      Source_ (this),
      Form_ (this),
      ProcessingDetails_ (this),
      Characterization_ (this),
      PropertyData_ (this),
      AssociationDetails_ (this),
      ComponentDetails1_ (this),
      id_ (this)
    {
    }

    ComponentDetails::
    ComponentDetails (::std::unique_ptr< Name_type > Name)
    : ::xml_schema::type (),
      Name_ (std::move (Name), this),
      Class_ (this),
      Subclass_ (this),
      Specification_ (this),
      Source_ (this),
      Form_ (this),
      ProcessingDetails_ (this),
      Characterization_ (this),
      PropertyData_ (this),
      AssociationDetails_ (this),
      ComponentDetails1_ (this),
      id_ (this)
    {
    }

    ComponentDetails::
    ComponentDetails (const ComponentDetails& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Class_ (x.Class_, f, this),
      Subclass_ (x.Subclass_, f, this),
      Specification_ (x.Specification_, f, this),
      Source_ (x.Source_, f, this),
      Form_ (x.Form_, f, this),
      ProcessingDetails_ (x.ProcessingDetails_, f, this),
      Characterization_ (x.Characterization_, f, this),
      PropertyData_ (x.PropertyData_, f, this),
      AssociationDetails_ (x.AssociationDetails_, f, this),
      ComponentDetails1_ (x.ComponentDetails1_, f, this),
      id_ (x.id_, f, this)
    {
    }

    ComponentDetails::
    ComponentDetails (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Class_ (this),
      Subclass_ (this),
      Specification_ (this),
      Source_ (this),
      Form_ (this),
      ProcessingDetails_ (this),
      Characterization_ (this),
      PropertyData_ (this),
      AssociationDetails_ (this),
      ComponentDetails1_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ComponentDetails::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Class
        //
        if (n.name () == "Class" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Class_type > r (
            Class_traits::create (i, f, this));

          this->Class_.push_back (::std::move (r));
          continue;
        }

        // Subclass
        //
        if (n.name () == "Subclass" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Subclass_type > r (
            Subclass_traits::create (i, f, this));

          this->Subclass_.push_back (::std::move (r));
          continue;
        }

        // Specification
        //
        if (n.name () == "Specification" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Specification_type > r (
            Specification_traits::create (i, f, this));

          this->Specification_.push_back (::std::move (r));
          continue;
        }

        // Source
        //
        if (n.name () == "Source" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Source_type > r (
            Source_traits::create (i, f, this));

          if (!this->Source_)
          {
            this->Source_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        // ProcessingDetails
        //
        if (n.name () == "ProcessingDetails" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ProcessingDetails_type > r (
            ProcessingDetails_traits::create (i, f, this));

          this->ProcessingDetails_.push_back (::std::move (r));
          continue;
        }

        // Characterization
        //
        if (n.name () == "Characterization" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Characterization_type > r (
            Characterization_traits::create (i, f, this));

          if (!this->Characterization_)
          {
            this->Characterization_.set (::std::move (r));
            continue;
          }
        }

        // PropertyData
        //
        if (n.name () == "PropertyData" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< PropertyData_type > r (
            PropertyData_traits::create (i, f, this));

          this->PropertyData_.push_back (::std::move (r));
          continue;
        }

        // AssociationDetails
        //
        if (n.name () == "AssociationDetails" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< AssociationDetails_type > r (
            AssociationDetails_traits::create (i, f, this));

          this->AssociationDetails_.push_back (::std::move (r));
          continue;
        }

        // ComponentDetails
        //
        if (n.name () == "ComponentDetails" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ComponentDetails1_type > r (
            ComponentDetails1_traits::create (i, f, this));

          this->ComponentDetails1_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }
    }

    ComponentDetails* ComponentDetails::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ComponentDetails (*this, f, c);
    }

    ComponentDetails& ComponentDetails::
    operator= (const ComponentDetails& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Class_ = x.Class_;
        this->Subclass_ = x.Subclass_;
        this->Specification_ = x.Specification_;
        this->Source_ = x.Source_;
        this->Form_ = x.Form_;
        this->ProcessingDetails_ = x.ProcessingDetails_;
        this->Characterization_ = x.Characterization_;
        this->PropertyData_ = x.PropertyData_;
        this->AssociationDetails_ = x.AssociationDetails_;
        this->ComponentDetails1_ = x.ComponentDetails1_;
        this->id_ = x.id_;
      }

      return *this;
    }

    ComponentDetails::
    ~ComponentDetails ()
    {
    }

    // Compound
    //

    Compound::
    Compound ()
    : ::xml_schema::type (),
      Element_ (this),
      Concentration_ (this),
      Notes_ (this)
    {
    }

    Compound::
    Compound (const Compound& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Element_ (x.Element_, f, this),
      Concentration_ (x.Concentration_, f, this),
      Notes_ (x.Notes_, f, this)
    {
    }

    Compound::
    Compound (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Element_ (this),
      Concentration_ (this),
      Notes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Compound::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Element
        //
        if (n.name () == "Element" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Element_type > r (
            Element_traits::create (i, f, this));

          this->Element_.push_back (::std::move (r));
          continue;
        }

        // Concentration
        //
        if (n.name () == "Concentration" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Concentration_type > r (
            Concentration_traits::create (i, f, this));

          if (!this->Concentration_)
          {
            this->Concentration_.set (::std::move (r));
            continue;
          }
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    Compound* Compound::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Compound (*this, f, c);
    }

    Compound& Compound::
    operator= (const Compound& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Element_ = x.Element_;
        this->Concentration_ = x.Concentration_;
        this->Notes_ = x.Notes_;
      }

      return *this;
    }

    Compound::
    ~Compound ()
    {
    }

    // Concentration
    //

    Concentration::
    Concentration (const Value_type& Value,
                   const Units_type& Units)
    : ::xml_schema::type (),
      Value_ (Value, this),
      Units_ (Units, this),
      Qualifier_ (this),
      Uncertainty_ (this),
      Notes_ (this)
    {
    }

    Concentration::
    Concentration (::std::unique_ptr< Value_type > Value,
                   ::std::unique_ptr< Units_type > Units)
    : ::xml_schema::type (),
      Value_ (std::move (Value), this),
      Units_ (std::move (Units), this),
      Qualifier_ (this),
      Uncertainty_ (this),
      Notes_ (this)
    {
    }

    Concentration::
    Concentration (const Concentration& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Value_ (x.Value_, f, this),
      Units_ (x.Units_, f, this),
      Qualifier_ (x.Qualifier_, f, this),
      Uncertainty_ (x.Uncertainty_, f, this),
      Notes_ (x.Notes_, f, this)
    {
    }

    Concentration::
    Concentration (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Value_ (this),
      Units_ (this),
      Qualifier_ (this),
      Uncertainty_ (this),
      Notes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Concentration::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Value
        //
        if (n.name () == "Value" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Value_type > r (
            Value_traits::create (i, f, this));

          if (!Value_.present ())
          {
            this->Value_.set (::std::move (r));
            continue;
          }
        }

        // Units
        //
        if (n.name () == "Units" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Units_type > r (
            Units_traits::create (i, f, this));

          if (!Units_.present ())
          {
            this->Units_.set (::std::move (r));
            continue;
          }
        }

        // Qualifier
        //
        if (n.name () == "Qualifier" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Qualifier_type > r (
            Qualifier_traits::create (i, f, this));

          this->Qualifier_.push_back (::std::move (r));
          continue;
        }

        // Uncertainty
        //
        if (n.name () == "Uncertainty" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Uncertainty_type > r (
            Uncertainty_traits::create (i, f, this));

          this->Uncertainty_.push_back (::std::move (r));
          continue;
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Value_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Value",
          "");
      }

      if (!Units_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Units",
          "");
      }
    }

    Concentration* Concentration::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Concentration (*this, f, c);
    }

    Concentration& Concentration::
    operator= (const Concentration& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Value_ = x.Value_;
        this->Units_ = x.Units_;
        this->Qualifier_ = x.Qualifier_;
        this->Uncertainty_ = x.Uncertainty_;
        this->Notes_ = x.Notes_;
      }

      return *this;
    }

    Concentration::
    ~Concentration ()
    {
    }

    // DataFormat
    //

    DataFormat::
    DataFormat (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_DataFormat_convert ();
    }

    DataFormat::
    DataFormat (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_DataFormat_convert ();
    }

    DataFormat::
    DataFormat (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_DataFormat_convert ();
    }

    DataFormat* DataFormat::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DataFormat (*this, f, c);
    }

    DataFormat::value DataFormat::
    _xsd_DataFormat_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_DataFormat_literals_);
      const value* i (::std::lower_bound (
                        _xsd_DataFormat_indexes_,
                        _xsd_DataFormat_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_DataFormat_indexes_ + 5 || _xsd_DataFormat_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const DataFormat::
    _xsd_DataFormat_literals_[5] =
    {
      "float",
      "integer",
      "string",
      "exponential",
      "mixed"
    };

    const DataFormat::value DataFormat::
    _xsd_DataFormat_indexes_[5] =
    {
      ::bellshire::lib::DataFormat::exponential,
      ::bellshire::lib::DataFormat::float_,
      ::bellshire::lib::DataFormat::integer,
      ::bellshire::lib::DataFormat::mixed,
      ::bellshire::lib::DataFormat::string
    };

    // DimensionalDetails
    //

    DimensionalDetails::
    DimensionalDetails (const Name_type& Name,
                        const Value_type& Value,
                        const Units_type& Units)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Value_ (Value, this),
      Units_ (Units, this),
      Qualifier_ (this),
      Uncertainty_ (this),
      Notes_ (this)
    {
    }

    DimensionalDetails::
    DimensionalDetails (::std::unique_ptr< Name_type > Name,
                        ::std::unique_ptr< Value_type > Value,
                        ::std::unique_ptr< Units_type > Units)
    : ::xml_schema::type (),
      Name_ (std::move (Name), this),
      Value_ (std::move (Value), this),
      Units_ (std::move (Units), this),
      Qualifier_ (this),
      Uncertainty_ (this),
      Notes_ (this)
    {
    }

    DimensionalDetails::
    DimensionalDetails (const DimensionalDetails& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Value_ (x.Value_, f, this),
      Units_ (x.Units_, f, this),
      Qualifier_ (x.Qualifier_, f, this),
      Uncertainty_ (x.Uncertainty_, f, this),
      Notes_ (x.Notes_, f, this)
    {
    }

    DimensionalDetails::
    DimensionalDetails (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Value_ (this),
      Units_ (this),
      Qualifier_ (this),
      Uncertainty_ (this),
      Notes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DimensionalDetails::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Value
        //
        if (n.name () == "Value" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Value_type > r (
            Value_traits::create (i, f, this));

          if (!Value_.present ())
          {
            this->Value_.set (::std::move (r));
            continue;
          }
        }

        // Units
        //
        if (n.name () == "Units" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Units_type > r (
            Units_traits::create (i, f, this));

          if (!Units_.present ())
          {
            this->Units_.set (::std::move (r));
            continue;
          }
        }

        // Qualifier
        //
        if (n.name () == "Qualifier" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Qualifier_type > r (
            Qualifier_traits::create (i, f, this));

          if (!this->Qualifier_)
          {
            this->Qualifier_.set (::std::move (r));
            continue;
          }
        }

        // Uncertainty
        //
        if (n.name () == "Uncertainty" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Uncertainty_type > r (
            Uncertainty_traits::create (i, f, this));

          this->Uncertainty_.push_back (::std::move (r));
          continue;
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "");
      }

      if (!Value_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Value",
          "");
      }

      if (!Units_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Units",
          "");
      }
    }

    DimensionalDetails* DimensionalDetails::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DimensionalDetails (*this, f, c);
    }

    DimensionalDetails& DimensionalDetails::
    operator= (const DimensionalDetails& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Value_ = x.Value_;
        this->Units_ = x.Units_;
        this->Qualifier_ = x.Qualifier_;
        this->Uncertainty_ = x.Uncertainty_;
        this->Notes_ = x.Notes_;
      }

      return *this;
    }

    DimensionalDetails::
    ~DimensionalDetails ()
    {
    }

    // Element
    //

    Element::
    Element (const Symbol_type& Symbol)
    : ::xml_schema::type (),
      Symbol_ (Symbol, this),
      Concentration_ (this),
      Notes_ (this)
    {
    }

    Element::
    Element (::std::unique_ptr< Symbol_type > Symbol)
    : ::xml_schema::type (),
      Symbol_ (std::move (Symbol), this),
      Concentration_ (this),
      Notes_ (this)
    {
    }

    Element::
    Element (const Element& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Symbol_ (x.Symbol_, f, this),
      Concentration_ (x.Concentration_, f, this),
      Notes_ (x.Notes_, f, this)
    {
    }

    Element::
    Element (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Symbol_ (this),
      Concentration_ (this),
      Notes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Element::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Symbol
        //
        if (n.name () == "Symbol" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Symbol_type > r (
            Symbol_traits::create (i, f, this));

          if (!Symbol_.present ())
          {
            this->Symbol_.set (::std::move (r));
            continue;
          }
        }

        // Concentration
        //
        if (n.name () == "Concentration" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Concentration_type > r (
            Concentration_traits::create (i, f, this));

          if (!this->Concentration_)
          {
            this->Concentration_.set (::std::move (r));
            continue;
          }
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Symbol_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Symbol",
          "");
      }
    }

    Element* Element::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Element (*this, f, c);
    }

    Element& Element::
    operator= (const Element& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Symbol_ = x.Symbol_;
        this->Concentration_ = x.Concentration_;
        this->Notes_ = x.Notes_;
      }

      return *this;
    }

    Element::
    ~Element ()
    {
    }

    // Form
    //

    Form::
    Form (const Description_type& Description)
    : ::xml_schema::type (),
      Description_ (Description, this),
      Geometry_ (this),
      Notes_ (this)
    {
    }

    Form::
    Form (::std::unique_ptr< Description_type > Description)
    : ::xml_schema::type (),
      Description_ (std::move (Description), this),
      Geometry_ (this),
      Notes_ (this)
    {
    }

    Form::
    Form (const Form& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Description_ (x.Description_, f, this),
      Geometry_ (x.Geometry_, f, this),
      Notes_ (x.Notes_, f, this)
    {
    }

    Form::
    Form (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Description_ (this),
      Geometry_ (this),
      Notes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Form::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Description
        //
        if (n.name () == "Description" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!Description_.present ())
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        // Geometry
        //
        if (n.name () == "Geometry" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Geometry_type > r (
            Geometry_traits::create (i, f, this));

          if (!this->Geometry_)
          {
            this->Geometry_.set (::std::move (r));
            continue;
          }
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Description",
          "");
      }
    }

    Form* Form::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Form (*this, f, c);
    }

    Form& Form::
    operator= (const Form& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Description_ = x.Description_;
        this->Geometry_ = x.Geometry_;
        this->Notes_ = x.Notes_;
      }

      return *this;
    }

    Form::
    ~Form ()
    {
    }

    // Formula
    //

    Formula::
    Formula ()
    : ::xml_schema::string ()
    {
    }

    Formula::
    Formula (const char* _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    Formula::
    Formula (const ::std::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    Formula::
    Formula (const ::xml_schema::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    Formula::
    Formula (const Formula& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    Formula::
    Formula (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    Formula::
    Formula (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    Formula::
    Formula (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    Formula* Formula::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Formula (*this, f, c);
    }

    Formula::
    ~Formula ()
    {
    }

    // Geometry
    //

    Geometry::
    Geometry (const Shape_type& Shape)
    : ::xml_schema::type (),
      Shape_ (Shape, this),
      Dimensions_ (this),
      Orientation_ (this),
      Notes_ (this)
    {
    }

    Geometry::
    Geometry (const Geometry& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Shape_ (x.Shape_, f, this),
      Dimensions_ (x.Dimensions_, f, this),
      Orientation_ (x.Orientation_, f, this),
      Notes_ (x.Notes_, f, this)
    {
    }

    Geometry::
    Geometry (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Shape_ (this),
      Dimensions_ (this),
      Orientation_ (this),
      Notes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Geometry::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Shape
        //
        if (n.name () == "Shape" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Shape_type > r (
            Shape_traits::create (i, f, this));

          if (!Shape_.present ())
          {
            this->Shape_.set (::std::move (r));
            continue;
          }
        }

        // Dimensions
        //
        if (n.name () == "Dimensions" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Dimensions_type > r (
            Dimensions_traits::create (i, f, this));

          if (!this->Dimensions_)
          {
            this->Dimensions_.set (::std::move (r));
            continue;
          }
        }

        // Orientation
        //
        if (n.name () == "Orientation" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Orientation_type > r (
            Orientation_traits::create (i, f, this));

          if (!this->Orientation_)
          {
            this->Orientation_.set (::std::move (r));
            continue;
          }
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Shape_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Shape",
          "");
      }
    }

    Geometry* Geometry::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Geometry (*this, f, c);
    }

    Geometry& Geometry::
    operator= (const Geometry& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Shape_ = x.Shape_;
        this->Dimensions_ = x.Dimensions_;
        this->Orientation_ = x.Orientation_;
        this->Notes_ = x.Notes_;
      }

      return *this;
    }

    Geometry::
    ~Geometry ()
    {
    }

    // Glossary
    //

    Glossary::
    Glossary ()
    : ::xml_schema::type (),
      Term_ (this)
    {
    }

    Glossary::
    Glossary (const Glossary& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Term_ (x.Term_, f, this)
    {
    }

    Glossary::
    Glossary (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Term_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Glossary::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Term
        //
        if (n.name () == "Term" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Term_type > r (
            Term_traits::create (i, f, this));

          this->Term_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    Glossary* Glossary::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Glossary (*this, f, c);
    }

    Glossary& Glossary::
    operator= (const Glossary& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Term_ = x.Term_;
      }

      return *this;
    }

    Glossary::
    ~Glossary ()
    {
    }

    // GlossaryTerm
    //

    GlossaryTerm::
    GlossaryTerm (const Name_type& Name,
                  const Definition_type& Definition)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Definition_ (Definition, this),
      Abbreviation_ (this),
      Synonym_ (this),
      Notes_ (this)
    {
    }

    GlossaryTerm::
    GlossaryTerm (::std::unique_ptr< Name_type > Name,
                  const Definition_type& Definition)
    : ::xml_schema::type (),
      Name_ (std::move (Name), this),
      Definition_ (Definition, this),
      Abbreviation_ (this),
      Synonym_ (this),
      Notes_ (this)
    {
    }

    GlossaryTerm::
    GlossaryTerm (const GlossaryTerm& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Definition_ (x.Definition_, f, this),
      Abbreviation_ (x.Abbreviation_, f, this),
      Synonym_ (x.Synonym_, f, this),
      Notes_ (x.Notes_, f, this)
    {
    }

    GlossaryTerm::
    GlossaryTerm (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Definition_ (this),
      Abbreviation_ (this),
      Synonym_ (this),
      Notes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void GlossaryTerm::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Definition
        //
        if (n.name () == "Definition" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Definition_type > r (
            Definition_traits::create (i, f, this));

          if (!Definition_.present ())
          {
            this->Definition_.set (::std::move (r));
            continue;
          }
        }

        // Abbreviation
        //
        if (n.name () == "Abbreviation" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Abbreviation_type > r (
            Abbreviation_traits::create (i, f, this));

          this->Abbreviation_.push_back (::std::move (r));
          continue;
        }

        // Synonym
        //
        if (n.name () == "Synonym" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Synonym_type > r (
            Synonym_traits::create (i, f, this));

          this->Synonym_.push_back (::std::move (r));
          continue;
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "");
      }

      if (!Definition_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Definition",
          "");
      }
    }

    GlossaryTerm* GlossaryTerm::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GlossaryTerm (*this, f, c);
    }

    GlossaryTerm& GlossaryTerm::
    operator= (const GlossaryTerm& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Definition_ = x.Definition_;
        this->Abbreviation_ = x.Abbreviation_;
        this->Synonym_ = x.Synonym_;
        this->Notes_ = x.Notes_;
      }

      return *this;
    }

    GlossaryTerm::
    ~GlossaryTerm ()
    {
    }

    // Graphs
    //

    Graphs::
    Graphs ()
    : ::xml_schema::type (),
      Graph_ (this)
    {
    }

    Graphs::
    Graphs (const Graphs& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Graph_ (x.Graph_, f, this)
    {
    }

    Graphs::
    Graphs (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Graph_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Graphs::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Graph
        //
        if (n.name () == "Graph" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Graph_type > r (
            Graph_traits::create (i, f, this));

          this->Graph_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    Graphs* Graphs::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Graphs (*this, f, c);
    }

    Graphs& Graphs::
    operator= (const Graphs& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Graph_ = x.Graph_;
      }

      return *this;
    }

    Graphs::
    ~Graphs ()
    {
    }

    // Material
    //

    Material::
    Material (const BulkDetails_type& BulkDetails)
    : ::xml_schema::type (),
      BulkDetails_ (BulkDetails, this),
      ComponentDetails_ (this),
      Graphs_ (this),
      Glossary_ (this),
      id_ (this),
      layers_ (this),
      local_frame_of_reference_ (this)
    {
    }

    Material::
    Material (::std::unique_ptr< BulkDetails_type > BulkDetails)
    : ::xml_schema::type (),
      BulkDetails_ (std::move (BulkDetails), this),
      ComponentDetails_ (this),
      Graphs_ (this),
      Glossary_ (this),
      id_ (this),
      layers_ (this),
      local_frame_of_reference_ (this)
    {
    }

    Material::
    Material (const Material& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BulkDetails_ (x.BulkDetails_, f, this),
      ComponentDetails_ (x.ComponentDetails_, f, this),
      Graphs_ (x.Graphs_, f, this),
      Glossary_ (x.Glossary_, f, this),
      id_ (x.id_, f, this),
      layers_ (x.layers_, f, this),
      local_frame_of_reference_ (x.local_frame_of_reference_, f, this)
    {
    }

    Material::
    Material (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BulkDetails_ (this),
      ComponentDetails_ (this),
      Graphs_ (this),
      Glossary_ (this),
      id_ (this),
      layers_ (this),
      local_frame_of_reference_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Material::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BulkDetails
        //
        if (n.name () == "BulkDetails" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< BulkDetails_type > r (
            BulkDetails_traits::create (i, f, this));

          if (!BulkDetails_.present ())
          {
            this->BulkDetails_.set (::std::move (r));
            continue;
          }
        }

        // ComponentDetails
        //
        if (n.name () == "ComponentDetails" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ComponentDetails_type > r (
            ComponentDetails_traits::create (i, f, this));

          this->ComponentDetails_.push_back (::std::move (r));
          continue;
        }

        // Graphs
        //
        if (n.name () == "Graphs" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Graphs_type > r (
            Graphs_traits::create (i, f, this));

          if (!this->Graphs_)
          {
            this->Graphs_.set (::std::move (r));
            continue;
          }
        }

        // Glossary
        //
        if (n.name () == "Glossary" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Glossary_type > r (
            Glossary_traits::create (i, f, this));

          if (!this->Glossary_)
          {
            this->Glossary_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BulkDetails_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BulkDetails",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "layers" && n.namespace_ ().empty ())
        {
          this->layers_.set (layers_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "local_frame_of_reference" && n.namespace_ ().empty ())
        {
          this->local_frame_of_reference_.set (local_frame_of_reference_traits::create (i, f, this));
          continue;
        }
      }
    }

    Material* Material::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Material (*this, f, c);
    }

    Material& Material::
    operator= (const Material& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BulkDetails_ = x.BulkDetails_;
        this->ComponentDetails_ = x.ComponentDetails_;
        this->Graphs_ = x.Graphs_;
        this->Glossary_ = x.Glossary_;
        this->id_ = x.id_;
        this->layers_ = x.layers_;
        this->local_frame_of_reference_ = x.local_frame_of_reference_;
      }

      return *this;
    }

    Material::
    ~Material ()
    {
    }

    // Metadata
    //

    Metadata::
    Metadata ()
    : ::xml_schema::type (),
      AuthorityDetails_ (this),
      DataSourceDetails_ (this),
      MeasurementTechniqueDetails_ (this),
      ParameterDetails_ (this),
      PropertyDetails_ (this),
      SourceDetails_ (this),
      SpecimenDetails_ (this),
      TestConditionDetails_ (this)
    {
    }

    Metadata::
    Metadata (const Metadata& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AuthorityDetails_ (x.AuthorityDetails_, f, this),
      DataSourceDetails_ (x.DataSourceDetails_, f, this),
      MeasurementTechniqueDetails_ (x.MeasurementTechniqueDetails_, f, this),
      ParameterDetails_ (x.ParameterDetails_, f, this),
      PropertyDetails_ (x.PropertyDetails_, f, this),
      SourceDetails_ (x.SourceDetails_, f, this),
      SpecimenDetails_ (x.SpecimenDetails_, f, this),
      TestConditionDetails_ (x.TestConditionDetails_, f, this)
    {
    }

    Metadata::
    Metadata (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AuthorityDetails_ (this),
      DataSourceDetails_ (this),
      MeasurementTechniqueDetails_ (this),
      ParameterDetails_ (this),
      PropertyDetails_ (this),
      SourceDetails_ (this),
      SpecimenDetails_ (this),
      TestConditionDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Metadata::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // AuthorityDetails
        //
        if (n.name () == "AuthorityDetails" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< AuthorityDetails_type > r (
            AuthorityDetails_traits::create (i, f, this));

          this->AuthorityDetails_.push_back (::std::move (r));
          continue;
        }

        // DataSourceDetails
        //
        if (n.name () == "DataSourceDetails" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< DataSourceDetails_type > r (
            DataSourceDetails_traits::create (i, f, this));

          this->DataSourceDetails_.push_back (::std::move (r));
          continue;
        }

        // MeasurementTechniqueDetails
        //
        if (n.name () == "MeasurementTechniqueDetails" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< MeasurementTechniqueDetails_type > r (
            MeasurementTechniqueDetails_traits::create (i, f, this));

          this->MeasurementTechniqueDetails_.push_back (::std::move (r));
          continue;
        }

        // ParameterDetails
        //
        if (n.name () == "ParameterDetails" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ParameterDetails_type > r (
            ParameterDetails_traits::create (i, f, this));

          this->ParameterDetails_.push_back (::std::move (r));
          continue;
        }

        // PropertyDetails
        //
        if (n.name () == "PropertyDetails" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< PropertyDetails_type > r (
            PropertyDetails_traits::create (i, f, this));

          this->PropertyDetails_.push_back (::std::move (r));
          continue;
        }

        // SourceDetails
        //
        if (n.name () == "SourceDetails" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< SourceDetails_type > r (
            SourceDetails_traits::create (i, f, this));

          this->SourceDetails_.push_back (::std::move (r));
          continue;
        }

        // SpecimenDetails
        //
        if (n.name () == "SpecimenDetails" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< SpecimenDetails_type > r (
            SpecimenDetails_traits::create (i, f, this));

          this->SpecimenDetails_.push_back (::std::move (r));
          continue;
        }

        // TestConditionDetails
        //
        if (n.name () == "TestConditionDetails" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< TestConditionDetails_type > r (
            TestConditionDetails_traits::create (i, f, this));

          this->TestConditionDetails_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    Metadata* Metadata::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Metadata (*this, f, c);
    }

    Metadata& Metadata::
    operator= (const Metadata& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AuthorityDetails_ = x.AuthorityDetails_;
        this->DataSourceDetails_ = x.DataSourceDetails_;
        this->MeasurementTechniqueDetails_ = x.MeasurementTechniqueDetails_;
        this->ParameterDetails_ = x.ParameterDetails_;
        this->PropertyDetails_ = x.PropertyDetails_;
        this->SourceDetails_ = x.SourceDetails_;
        this->SpecimenDetails_ = x.SpecimenDetails_;
        this->TestConditionDetails_ = x.TestConditionDetails_;
      }

      return *this;
    }

    Metadata::
    ~Metadata ()
    {
    }

    // Name
    //

    Name::
    Name ()
    : ::xml_schema::string (),
      authority_ (this)
    {
    }

    Name::
    Name (const char* _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base),
      authority_ (this)
    {
    }

    Name::
    Name (const ::std::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base),
      authority_ (this)
    {
    }

    Name::
    Name (const ::xml_schema::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base),
      authority_ (this)
    {
    }

    Name::
    Name (const Name& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c),
      authority_ (x.authority_, f, this)
    {
    }

    Name::
    Name (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
      authority_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Name::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "authority" && n.namespace_ ().empty ())
        {
          this->authority_.set (authority_traits::create (i, f, this));
          continue;
        }
      }
    }

    Name* Name::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Name (*this, f, c);
    }

    Name& Name::
    operator= (const Name& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::string& > (*this) = x;
        this->authority_ = x.authority_;
      }

      return *this;
    }

    Name::
    ~Name ()
    {
    }

    // Notes
    //

    Notes::
    Notes ()
    : ::xml_schema::string ()
    {
    }

    Notes::
    Notes (const char* _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    Notes::
    Notes (const ::std::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    Notes::
    Notes (const ::xml_schema::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    Notes::
    Notes (const Notes& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    Notes::
    Notes (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    Notes::
    Notes (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    Notes::
    Notes (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    Notes* Notes::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Notes (*this, f, c);
    }

    Notes::
    ~Notes ()
    {
    }

    // ParameterValue
    //

    ParameterValue::
    ParameterValue (const Data_type& Data,
                    const parameter_type& parameter,
                    const format_type& format)
    : ::xml_schema::type (),
      Data_ (Data, this),
      Uncertainty_ (this),
      Qualifier_ (this),
      Notes_ (this),
      parameter_ (parameter, this),
      format_ (format, this)
    {
    }

    ParameterValue::
    ParameterValue (::std::unique_ptr< Data_type > Data,
                    const parameter_type& parameter,
                    const format_type& format)
    : ::xml_schema::type (),
      Data_ (std::move (Data), this),
      Uncertainty_ (this),
      Qualifier_ (this),
      Notes_ (this),
      parameter_ (parameter, this),
      format_ (format, this)
    {
    }

    ParameterValue::
    ParameterValue (const ParameterValue& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Data_ (x.Data_, f, this),
      Uncertainty_ (x.Uncertainty_, f, this),
      Qualifier_ (x.Qualifier_, f, this),
      Notes_ (x.Notes_, f, this),
      parameter_ (x.parameter_, f, this),
      format_ (x.format_, f, this)
    {
    }

    ParameterValue::
    ParameterValue (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Data_ (this),
      Uncertainty_ (this),
      Qualifier_ (this),
      Notes_ (this),
      parameter_ (this),
      format_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ParameterValue::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Data
        //
        if (n.name () == "Data" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Data_type > r (
            Data_traits::create (i, f, this));

          if (!Data_.present ())
          {
            this->Data_.set (::std::move (r));
            continue;
          }
        }

        // Uncertainty
        //
        if (n.name () == "Uncertainty" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Uncertainty_type > r (
            Uncertainty_traits::create (i, f, this));

          this->Uncertainty_.push_back (::std::move (r));
          continue;
        }

        // Qualifier
        //
        if (n.name () == "Qualifier" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Qualifier_type > r (
            Qualifier_traits::create (i, f, this));

          this->Qualifier_.push_back (::std::move (r));
          continue;
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Data_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Data",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "parameter" && n.namespace_ ().empty ())
        {
          this->parameter_.set (parameter_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "format" && n.namespace_ ().empty ())
        {
          this->format_.set (format_traits::create (i, f, this));
          continue;
        }
      }

      if (!parameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "parameter",
          "");
      }

      if (!format_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "format",
          "");
      }
    }

    ParameterValue* ParameterValue::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ParameterValue (*this, f, c);
    }

    ParameterValue& ParameterValue::
    operator= (const ParameterValue& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Data_ = x.Data_;
        this->Uncertainty_ = x.Uncertainty_;
        this->Qualifier_ = x.Qualifier_;
        this->Notes_ = x.Notes_;
        this->parameter_ = x.parameter_;
        this->format_ = x.format_;
      }

      return *this;
    }

    ParameterValue::
    ~ParameterValue ()
    {
    }

    // PhaseComposition
    //

    PhaseComposition::
    PhaseComposition (const Name_type& Name)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Concentration_ (this),
      PropertyData_ (this),
      Notes_ (this)
    {
    }

    PhaseComposition::
    PhaseComposition (::std::unique_ptr< Name_type > Name)
    : ::xml_schema::type (),
      Name_ (std::move (Name), this),
      Concentration_ (this),
      PropertyData_ (this),
      Notes_ (this)
    {
    }

    PhaseComposition::
    PhaseComposition (const PhaseComposition& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Concentration_ (x.Concentration_, f, this),
      PropertyData_ (x.PropertyData_, f, this),
      Notes_ (x.Notes_, f, this)
    {
    }

    PhaseComposition::
    PhaseComposition (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Concentration_ (this),
      PropertyData_ (this),
      Notes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PhaseComposition::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Concentration
        //
        if (n.name () == "Concentration" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Concentration_type > r (
            Concentration_traits::create (i, f, this));

          if (!this->Concentration_)
          {
            this->Concentration_.set (::std::move (r));
            continue;
          }
        }

        // PropertyData
        //
        if (n.name () == "PropertyData" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< PropertyData_type > r (
            PropertyData_traits::create (i, f, this));

          this->PropertyData_.push_back (::std::move (r));
          continue;
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "");
      }
    }

    PhaseComposition* PhaseComposition::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PhaseComposition (*this, f, c);
    }

    PhaseComposition& PhaseComposition::
    operator= (const PhaseComposition& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Concentration_ = x.Concentration_;
        this->PropertyData_ = x.PropertyData_;
        this->Notes_ = x.Notes_;
      }

      return *this;
    }

    PhaseComposition::
    ~PhaseComposition ()
    {
    }

    // ProcessingDetails
    //

    ProcessingDetails::
    ProcessingDetails (const Name_type& Name)
    : ::xml_schema::type (),
      Name_ (Name, this),
      ParameterValue_ (this),
      Result_ (this),
      Notes_ (this)
    {
    }

    ProcessingDetails::
    ProcessingDetails (::std::unique_ptr< Name_type > Name)
    : ::xml_schema::type (),
      Name_ (std::move (Name), this),
      ParameterValue_ (this),
      Result_ (this),
      Notes_ (this)
    {
    }

    ProcessingDetails::
    ProcessingDetails (const ProcessingDetails& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      ParameterValue_ (x.ParameterValue_, f, this),
      Result_ (x.Result_, f, this),
      Notes_ (x.Notes_, f, this)
    {
    }

    ProcessingDetails::
    ProcessingDetails (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      ParameterValue_ (this),
      Result_ (this),
      Notes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ProcessingDetails::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // ParameterValue
        //
        if (n.name () == "ParameterValue" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ParameterValue_type > r (
            ParameterValue_traits::create (i, f, this));

          this->ParameterValue_.push_back (::std::move (r));
          continue;
        }

        // Result
        //
        if (n.name () == "Result" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Result_type > r (
            Result_traits::create (i, f, this));

          if (!this->Result_)
          {
            this->Result_.set (::std::move (r));
            continue;
          }
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "");
      }
    }

    ProcessingDetails* ProcessingDetails::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProcessingDetails (*this, f, c);
    }

    ProcessingDetails& ProcessingDetails::
    operator= (const ProcessingDetails& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->ParameterValue_ = x.ParameterValue_;
        this->Result_ = x.Result_;
        this->Notes_ = x.Notes_;
      }

      return *this;
    }

    ProcessingDetails::
    ~ProcessingDetails ()
    {
    }

    // PropertyData
    //

    const PropertyData::delimiter_type PropertyData::delimiter_default_value_ (
      ",");

    PropertyData::
    PropertyData (const Data_type& Data,
                  const property_type& property)
    : ::xml_schema::type (),
      Data_ (Data, this),
      Uncertainty_ (this),
      Qualifier_ (this),
      ParameterValue_ (this),
      Notes_ (this),
      property_ (property, this),
      technique_ (this),
      source_ (this),
      specimen_ (this),
      test_ (this),
      delimiter_ (delimiter_default_value (), this),
      quote_ (this)
    {
    }

    PropertyData::
    PropertyData (::std::unique_ptr< Data_type > Data,
                  const property_type& property)
    : ::xml_schema::type (),
      Data_ (std::move (Data), this),
      Uncertainty_ (this),
      Qualifier_ (this),
      ParameterValue_ (this),
      Notes_ (this),
      property_ (property, this),
      technique_ (this),
      source_ (this),
      specimen_ (this),
      test_ (this),
      delimiter_ (delimiter_default_value (), this),
      quote_ (this)
    {
    }

    PropertyData::
    PropertyData (const PropertyData& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Data_ (x.Data_, f, this),
      Uncertainty_ (x.Uncertainty_, f, this),
      Qualifier_ (x.Qualifier_, f, this),
      ParameterValue_ (x.ParameterValue_, f, this),
      Notes_ (x.Notes_, f, this),
      property_ (x.property_, f, this),
      technique_ (x.technique_, f, this),
      source_ (x.source_, f, this),
      specimen_ (x.specimen_, f, this),
      test_ (x.test_, f, this),
      delimiter_ (x.delimiter_, f, this),
      quote_ (x.quote_, f, this)
    {
    }

    PropertyData::
    PropertyData (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Data_ (this),
      Uncertainty_ (this),
      Qualifier_ (this),
      ParameterValue_ (this),
      Notes_ (this),
      property_ (this),
      technique_ (this),
      source_ (this),
      specimen_ (this),
      test_ (this),
      delimiter_ (this),
      quote_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PropertyData::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Data
        //
        if (n.name () == "Data" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Data_type > r (
            Data_traits::create (i, f, this));

          if (!Data_.present ())
          {
            this->Data_.set (::std::move (r));
            continue;
          }
        }

        // Uncertainty
        //
        if (n.name () == "Uncertainty" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Uncertainty_type > r (
            Uncertainty_traits::create (i, f, this));

          this->Uncertainty_.push_back (::std::move (r));
          continue;
        }

        // Qualifier
        //
        if (n.name () == "Qualifier" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Qualifier_type > r (
            Qualifier_traits::create (i, f, this));

          this->Qualifier_.push_back (::std::move (r));
          continue;
        }

        // ParameterValue
        //
        if (n.name () == "ParameterValue" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ParameterValue_type > r (
            ParameterValue_traits::create (i, f, this));

          this->ParameterValue_.push_back (::std::move (r));
          continue;
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Data_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Data",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "property" && n.namespace_ ().empty ())
        {
          this->property_.set (property_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "technique" && n.namespace_ ().empty ())
        {
          this->technique_.set (technique_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "source" && n.namespace_ ().empty ())
        {
          this->source_.set (source_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "specimen" && n.namespace_ ().empty ())
        {
          this->specimen_.set (specimen_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "test" && n.namespace_ ().empty ())
        {
          this->test_.set (test_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "delimiter" && n.namespace_ ().empty ())
        {
          this->delimiter_.set (delimiter_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "quote" && n.namespace_ ().empty ())
        {
          this->quote_.set (quote_traits::create (i, f, this));
          continue;
        }
      }

      if (!property_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "property",
          "");
      }

      if (!delimiter_.present ())
      {
        this->delimiter_.set (delimiter_default_value ());
      }
    }

    PropertyData* PropertyData::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PropertyData (*this, f, c);
    }

    PropertyData& PropertyData::
    operator= (const PropertyData& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Data_ = x.Data_;
        this->Uncertainty_ = x.Uncertainty_;
        this->Qualifier_ = x.Qualifier_;
        this->ParameterValue_ = x.ParameterValue_;
        this->Notes_ = x.Notes_;
        this->property_ = x.property_;
        this->technique_ = x.technique_;
        this->source_ = x.source_;
        this->specimen_ = x.specimen_;
        this->test_ = x.test_;
        this->delimiter_ = x.delimiter_;
        this->quote_ = x.quote_;
      }

      return *this;
    }

    PropertyData::
    ~PropertyData ()
    {
    }

    // Qualifier
    //

    Qualifier::
    Qualifier ()
    : ::xml_schema::string ()
    {
    }

    Qualifier::
    Qualifier (const char* _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    Qualifier::
    Qualifier (const ::std::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    Qualifier::
    Qualifier (const ::xml_schema::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    Qualifier::
    Qualifier (const Qualifier& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    Qualifier::
    Qualifier (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    Qualifier::
    Qualifier (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    Qualifier::
    Qualifier (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    Qualifier* Qualifier::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Qualifier (*this, f, c);
    }

    Qualifier::
    ~Qualifier ()
    {
    }

    // Relationship
    //

    Relationship::
    Relationship ()
    : ::xml_schema::string ()
    {
    }

    Relationship::
    Relationship (const char* _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    Relationship::
    Relationship (const ::std::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    Relationship::
    Relationship (const ::xml_schema::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    Relationship::
    Relationship (const Relationship& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    Relationship::
    Relationship (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    Relationship::
    Relationship (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    Relationship::
    Relationship (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    Relationship* Relationship::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Relationship (*this, f, c);
    }

    Relationship::
    ~Relationship ()
    {
    }

    // Source
    //

    Source::
    Source ()
    : ::xml_schema::type (),
      source_ (this)
    {
    }

    Source::
    Source (const Source& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      source_ (x.source_, f, this)
    {
    }

    Source::
    Source (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      source_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Source::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "source" && n.namespace_ ().empty ())
        {
          this->source_.set (source_traits::create (i, f, this));
          continue;
        }
      }
    }

    Source* Source::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Source (*this, f, c);
    }

    Source& Source::
    operator= (const Source& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->source_ = x.source_;
      }

      return *this;
    }

    Source::
    ~Source ()
    {
    }

    // Specification
    //

    Specification::
    Specification ()
    : ::xml_schema::string (),
      authority_ (this)
    {
    }

    Specification::
    Specification (const char* _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base),
      authority_ (this)
    {
    }

    Specification::
    Specification (const ::std::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base),
      authority_ (this)
    {
    }

    Specification::
    Specification (const ::xml_schema::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base),
      authority_ (this)
    {
    }

    Specification::
    Specification (const Specification& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c),
      authority_ (x.authority_, f, this)
    {
    }

    Specification::
    Specification (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
      authority_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Specification::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "authority" && n.namespace_ ().empty ())
        {
          this->authority_.set (authority_traits::create (i, f, this));
          continue;
        }
      }
    }

    Specification* Specification::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Specification (*this, f, c);
    }

    Specification& Specification::
    operator= (const Specification& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::string& > (*this) = x;
        this->authority_ = x.authority_;
      }

      return *this;
    }

    Specification::
    ~Specification ()
    {
    }

    // Uncertainty
    //

    const Uncertainty::Scale_type Uncertainty::Scale_default_value_ (
      "Linear");

    const Uncertainty::DistributionType_type Uncertainty::DistributionType_default_value_ (
      "Normal/Gaussian");

    Uncertainty::
    Uncertainty (const Value_type& Value)
    : ::xml_schema::type (),
      Value_ (Value, this),
      Units_ (this),
      Unitless_ (this),
      Notes_ (this),
      Scale_ (this),
      DistributionType_ (DistributionType_default_value (), this),
      Num_Std_Dev_ (Num_Std_Dev_default_value (), this),
      Percentile_ (this),
      ConfidenceLevel_ (this)
    {
    }

    Uncertainty::
    Uncertainty (::std::unique_ptr< Value_type > Value)
    : ::xml_schema::type (),
      Value_ (std::move (Value), this),
      Units_ (this),
      Unitless_ (this),
      Notes_ (this),
      Scale_ (this),
      DistributionType_ (DistributionType_default_value (), this),
      Num_Std_Dev_ (Num_Std_Dev_default_value (), this),
      Percentile_ (this),
      ConfidenceLevel_ (this)
    {
    }

    Uncertainty::
    Uncertainty (const Uncertainty& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Value_ (x.Value_, f, this),
      Units_ (x.Units_, f, this),
      Unitless_ (x.Unitless_, f, this),
      Notes_ (x.Notes_, f, this),
      Scale_ (x.Scale_, f, this),
      DistributionType_ (x.DistributionType_, f, this),
      Num_Std_Dev_ (x.Num_Std_Dev_, f, this),
      Percentile_ (x.Percentile_, f, this),
      ConfidenceLevel_ (x.ConfidenceLevel_, f, this)
    {
    }

    Uncertainty::
    Uncertainty (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Value_ (this),
      Units_ (this),
      Unitless_ (this),
      Notes_ (this),
      Scale_ (this),
      DistributionType_ (this),
      Num_Std_Dev_ (this),
      Percentile_ (this),
      ConfidenceLevel_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Uncertainty::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Value
        //
        if (n.name () == "Value" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Value_type > r (
            Value_traits::create (i, f, this));

          if (!Value_.present ())
          {
            this->Value_.set (::std::move (r));
            continue;
          }
        }

        // Units
        //
        if (n.name () == "Units" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Units_type > r (
            Units_traits::create (i, f, this));

          if (!this->Units_)
          {
            this->Units_.set (::std::move (r));
            continue;
          }
        }

        // Unitless
        //
        if (n.name () == "Unitless" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Unitless_type > r (
            Unitless_traits::create (i, f, this));

          if (!this->Unitless_)
          {
            this->Unitless_.set (::std::move (r));
            continue;
          }
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        // Scale
        //
        if (n.name () == "Scale" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Scale_type > r (
            Scale_traits::create (i, f, this));

          if (!this->Scale_)
          {
            this->Scale_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Value_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Value",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "DistributionType" && n.namespace_ ().empty ())
        {
          this->DistributionType_.set (DistributionType_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "Num_Std_Dev" && n.namespace_ ().empty ())
        {
          this->Num_Std_Dev_.set (Num_Std_Dev_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "Percentile" && n.namespace_ ().empty ())
        {
          this->Percentile_.set (Percentile_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "ConfidenceLevel" && n.namespace_ ().empty ())
        {
          this->ConfidenceLevel_.set (ConfidenceLevel_traits::create (i, f, this));
          continue;
        }
      }

      if (!DistributionType_.present ())
      {
        this->DistributionType_.set (DistributionType_default_value ());
      }

      if (!Num_Std_Dev_.present ())
      {
        this->Num_Std_Dev_.set (Num_Std_Dev_default_value ());
      }
    }

    Uncertainty* Uncertainty::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Uncertainty (*this, f, c);
    }

    Uncertainty& Uncertainty::
    operator= (const Uncertainty& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Value_ = x.Value_;
        this->Units_ = x.Units_;
        this->Unitless_ = x.Unitless_;
        this->Notes_ = x.Notes_;
        this->Scale_ = x.Scale_;
        this->DistributionType_ = x.DistributionType_;
        this->Num_Std_Dev_ = x.Num_Std_Dev_;
        this->Percentile_ = x.Percentile_;
        this->ConfidenceLevel_ = x.ConfidenceLevel_;
      }

      return *this;
    }

    Uncertainty::
    ~Uncertainty ()
    {
    }

    // Unit
    //

    Unit::
    Unit ()
    : ::xml_schema::type (),
      Name_ (this),
      Currency_ (this),
      power_ (this),
      description_ (this)
    {
    }

    Unit::
    Unit (const Unit& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Currency_ (x.Currency_, f, this),
      power_ (x.power_, f, this),
      description_ (x.description_, f, this)
    {
    }

    Unit::
    Unit (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Currency_ (this),
      power_ (this),
      description_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Unit::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Currency
        //
        if (n.name () == "Currency" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Currency_type > r (
            Currency_traits::create (i, f, this));

          if (!this->Currency_)
          {
            this->Currency_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "power" && n.namespace_ ().empty ())
        {
          this->power_.set (power_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "description" && n.namespace_ ().empty ())
        {
          this->description_.set (description_traits::create (i, f, this));
          continue;
        }
      }
    }

    Unit* Unit::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Unit (*this, f, c);
    }

    Unit& Unit::
    operator= (const Unit& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Currency_ = x.Currency_;
        this->power_ = x.power_;
        this->description_ = x.description_;
      }

      return *this;
    }

    Unit::
    ~Unit ()
    {
    }

    // Unitless
    //

    Unitless::
    Unitless ()
    : ::xml_schema::type ()
    {
    }

    Unitless::
    Unitless (const Unitless& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    Unitless::
    Unitless (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    Unitless::
    Unitless (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    Unitless::
    Unitless (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    Unitless* Unitless::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Unitless (*this, f, c);
    }

    Unitless::
    ~Unitless ()
    {
    }

    // Units
    //

    Units::
    Units ()
    : ::xml_schema::type (),
      Unit_ (this),
      system_ (this),
      factor_ (this),
      name_ (this),
      description_ (this)
    {
    }

    Units::
    Units (const Units& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Unit_ (x.Unit_, f, this),
      system_ (x.system_, f, this),
      factor_ (x.factor_, f, this),
      name_ (x.name_, f, this),
      description_ (x.description_, f, this)
    {
    }

    Units::
    Units (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Unit_ (this),
      system_ (this),
      factor_ (this),
      name_ (this),
      description_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Units::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Unit
        //
        if (n.name () == "Unit" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Unit_type > r (
            Unit_traits::create (i, f, this));

          this->Unit_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "system" && n.namespace_ ().empty ())
        {
          this->system_.set (system_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "factor" && n.namespace_ ().empty ())
        {
          this->factor_.set (factor_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "description" && n.namespace_ ().empty ())
        {
          this->description_.set (description_traits::create (i, f, this));
          continue;
        }
      }
    }

    Units* Units::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Units (*this, f, c);
    }

    Units& Units::
    operator= (const Units& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Unit_ = x.Unit_;
        this->system_ = x.system_;
        this->factor_ = x.factor_;
        this->name_ = x.name_;
        this->description_ = x.description_;
      }

      return *this;
    }

    Units::
    ~Units ()
    {
    }

    // Value
    //

    Value::
    Value (const format_type& format)
    : ::xml_schema::string (),
      format_ (format, this)
    {
    }

    Value::
    Value (const char* _xsd_string_base,
           const format_type& format)
    : ::xml_schema::string (_xsd_string_base),
      format_ (format, this)
    {
    }

    Value::
    Value (const ::std::string& _xsd_string_base,
           const format_type& format)
    : ::xml_schema::string (_xsd_string_base),
      format_ (format, this)
    {
    }

    Value::
    Value (const ::xml_schema::string& _xsd_string_base,
           const format_type& format)
    : ::xml_schema::string (_xsd_string_base),
      format_ (format, this)
    {
    }

    Value::
    Value (const Value& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c),
      format_ (x.format_, f, this)
    {
    }

    Value::
    Value (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
      format_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Value::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "format" && n.namespace_ ().empty ())
        {
          this->format_.set (format_traits::create (i, f, this));
          continue;
        }
      }

      if (!format_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "format",
          "");
      }
    }

    Value* Value::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Value (*this, f, c);
    }

    Value& Value::
    operator= (const Value& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::string& > (*this) = x;
        this->format_ = x.format_;
      }

      return *this;
    }

    Value::
    ~Value ()
    {
    }

    // AuthorityDetails
    //

    AuthorityDetails::
    AuthorityDetails (const Name_type& Name,
                      const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Notes_ (this),
      id_ (id, this)
    {
    }

    AuthorityDetails::
    AuthorityDetails (::std::unique_ptr< Name_type > Name,
                      const id_type& id)
    : ::xml_schema::type (),
      Name_ (std::move (Name), this),
      Notes_ (this),
      id_ (id, this)
    {
    }

    AuthorityDetails::
    AuthorityDetails (const AuthorityDetails& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Notes_ (x.Notes_, f, this),
      id_ (x.id_, f, this)
    {
    }

    AuthorityDetails::
    AuthorityDetails (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Notes_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AuthorityDetails::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    AuthorityDetails* AuthorityDetails::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AuthorityDetails (*this, f, c);
    }

    AuthorityDetails& AuthorityDetails::
    operator= (const AuthorityDetails& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Notes_ = x.Notes_;
        this->id_ = x.id_;
      }

      return *this;
    }

    AuthorityDetails::
    ~AuthorityDetails ()
    {
    }

    // DataSourceDetails
    //

    DataSourceDetails::
    DataSourceDetails (const Name_type& Name,
                       const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Notes_ (this),
      id_ (id, this),
      type_ (this)
    {
    }

    DataSourceDetails::
    DataSourceDetails (::std::unique_ptr< Name_type > Name,
                       const id_type& id)
    : ::xml_schema::type (),
      Name_ (std::move (Name), this),
      Notes_ (this),
      id_ (id, this),
      type_ (this)
    {
    }

    DataSourceDetails::
    DataSourceDetails (const DataSourceDetails& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Notes_ (x.Notes_, f, this),
      id_ (x.id_, f, this),
      type_ (x.type_, f, this)
    {
    }

    DataSourceDetails::
    DataSourceDetails (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Notes_ (this),
      id_ (this),
      type_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DataSourceDetails::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    DataSourceDetails* DataSourceDetails::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DataSourceDetails (*this, f, c);
    }

    DataSourceDetails& DataSourceDetails::
    operator= (const DataSourceDetails& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Notes_ = x.Notes_;
        this->id_ = x.id_;
        this->type_ = x.type_;
      }

      return *this;
    }

    DataSourceDetails::
    ~DataSourceDetails ()
    {
    }

    // MeasurementTechniqueDetails
    //

    MeasurementTechniqueDetails::
    MeasurementTechniqueDetails (const Name_type& Name,
                                 const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Notes_ (this),
      id_ (id, this)
    {
    }

    MeasurementTechniqueDetails::
    MeasurementTechniqueDetails (::std::unique_ptr< Name_type > Name,
                                 const id_type& id)
    : ::xml_schema::type (),
      Name_ (std::move (Name), this),
      Notes_ (this),
      id_ (id, this)
    {
    }

    MeasurementTechniqueDetails::
    MeasurementTechniqueDetails (const MeasurementTechniqueDetails& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Notes_ (x.Notes_, f, this),
      id_ (x.id_, f, this)
    {
    }

    MeasurementTechniqueDetails::
    MeasurementTechniqueDetails (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Notes_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MeasurementTechniqueDetails::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    MeasurementTechniqueDetails* MeasurementTechniqueDetails::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementTechniqueDetails (*this, f, c);
    }

    MeasurementTechniqueDetails& MeasurementTechniqueDetails::
    operator= (const MeasurementTechniqueDetails& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Notes_ = x.Notes_;
        this->id_ = x.id_;
      }

      return *this;
    }

    MeasurementTechniqueDetails::
    ~MeasurementTechniqueDetails ()
    {
    }

    // ParameterDetails
    //

    ParameterDetails::
    ParameterDetails (const Name_type& Name,
                      const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Units_ (this),
      Unitless_ (this),
      Notes_ (this),
      id_ (id, this)
    {
    }

    ParameterDetails::
    ParameterDetails (::std::unique_ptr< Name_type > Name,
                      const id_type& id)
    : ::xml_schema::type (),
      Name_ (std::move (Name), this),
      Units_ (this),
      Unitless_ (this),
      Notes_ (this),
      id_ (id, this)
    {
    }

    ParameterDetails::
    ParameterDetails (const ParameterDetails& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Units_ (x.Units_, f, this),
      Unitless_ (x.Unitless_, f, this),
      Notes_ (x.Notes_, f, this),
      id_ (x.id_, f, this)
    {
    }

    ParameterDetails::
    ParameterDetails (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Units_ (this),
      Unitless_ (this),
      Notes_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ParameterDetails::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Units
        //
        if (n.name () == "Units" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Units_type > r (
            Units_traits::create (i, f, this));

          if (!this->Units_)
          {
            this->Units_.set (::std::move (r));
            continue;
          }
        }

        // Unitless
        //
        if (n.name () == "Unitless" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Unitless_type > r (
            Unitless_traits::create (i, f, this));

          if (!this->Unitless_)
          {
            this->Unitless_.set (::std::move (r));
            continue;
          }
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    ParameterDetails* ParameterDetails::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ParameterDetails (*this, f, c);
    }

    ParameterDetails& ParameterDetails::
    operator= (const ParameterDetails& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Units_ = x.Units_;
        this->Unitless_ = x.Unitless_;
        this->Notes_ = x.Notes_;
        this->id_ = x.id_;
      }

      return *this;
    }

    ParameterDetails::
    ~ParameterDetails ()
    {
    }

    // PropertyDetails
    //

    PropertyDetails::
    PropertyDetails (const Name_type& Name,
                     const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Units_ (this),
      Unitless_ (this),
      Notes_ (this),
      id_ (id, this),
      type_ (this)
    {
    }

    PropertyDetails::
    PropertyDetails (::std::unique_ptr< Name_type > Name,
                     const id_type& id)
    : ::xml_schema::type (),
      Name_ (std::move (Name), this),
      Units_ (this),
      Unitless_ (this),
      Notes_ (this),
      id_ (id, this),
      type_ (this)
    {
    }

    PropertyDetails::
    PropertyDetails (const PropertyDetails& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Units_ (x.Units_, f, this),
      Unitless_ (x.Unitless_, f, this),
      Notes_ (x.Notes_, f, this),
      id_ (x.id_, f, this),
      type_ (x.type_, f, this)
    {
    }

    PropertyDetails::
    PropertyDetails (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Units_ (this),
      Unitless_ (this),
      Notes_ (this),
      id_ (this),
      type_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PropertyDetails::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Units
        //
        if (n.name () == "Units" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Units_type > r (
            Units_traits::create (i, f, this));

          if (!this->Units_)
          {
            this->Units_.set (::std::move (r));
            continue;
          }
        }

        // Unitless
        //
        if (n.name () == "Unitless" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Unitless_type > r (
            Unitless_traits::create (i, f, this));

          if (!this->Unitless_)
          {
            this->Unitless_.set (::std::move (r));
            continue;
          }
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    PropertyDetails* PropertyDetails::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PropertyDetails (*this, f, c);
    }

    PropertyDetails& PropertyDetails::
    operator= (const PropertyDetails& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Units_ = x.Units_;
        this->Unitless_ = x.Unitless_;
        this->Notes_ = x.Notes_;
        this->id_ = x.id_;
        this->type_ = x.type_;
      }

      return *this;
    }

    PropertyDetails::
    ~PropertyDetails ()
    {
    }

    // SourceDetails
    //

    SourceDetails::
    SourceDetails (const Name_type& Name,
                   const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Notes_ (this),
      id_ (id, this),
      type_ (this)
    {
    }

    SourceDetails::
    SourceDetails (::std::unique_ptr< Name_type > Name,
                   const id_type& id)
    : ::xml_schema::type (),
      Name_ (std::move (Name), this),
      Notes_ (this),
      id_ (id, this),
      type_ (this)
    {
    }

    SourceDetails::
    SourceDetails (const SourceDetails& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Notes_ (x.Notes_, f, this),
      id_ (x.id_, f, this),
      type_ (x.type_, f, this)
    {
    }

    SourceDetails::
    SourceDetails (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Notes_ (this),
      id_ (this),
      type_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SourceDetails::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    SourceDetails* SourceDetails::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SourceDetails (*this, f, c);
    }

    SourceDetails& SourceDetails::
    operator= (const SourceDetails& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Notes_ = x.Notes_;
        this->id_ = x.id_;
        this->type_ = x.type_;
      }

      return *this;
    }

    SourceDetails::
    ~SourceDetails ()
    {
    }

    // SpecimenDetails
    //

    SpecimenDetails::
    SpecimenDetails (const id_type& id)
    : ::xml_schema::type (),
      Name_ (this),
      Notes_ (this),
      Geometry_ (this),
      id_ (id, this),
      type_ (this)
    {
    }

    SpecimenDetails::
    SpecimenDetails (const SpecimenDetails& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Notes_ (x.Notes_, f, this),
      Geometry_ (x.Geometry_, f, this),
      id_ (x.id_, f, this),
      type_ (x.type_, f, this)
    {
    }

    SpecimenDetails::
    SpecimenDetails (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Notes_ (this),
      Geometry_ (this),
      id_ (this),
      type_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SpecimenDetails::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        // Geometry
        //
        if (n.name () == "Geometry" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Geometry_type > r (
            Geometry_traits::create (i, f, this));

          if (!this->Geometry_)
          {
            this->Geometry_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    SpecimenDetails* SpecimenDetails::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SpecimenDetails (*this, f, c);
    }

    SpecimenDetails& SpecimenDetails::
    operator= (const SpecimenDetails& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Notes_ = x.Notes_;
        this->Geometry_ = x.Geometry_;
        this->id_ = x.id_;
        this->type_ = x.type_;
      }

      return *this;
    }

    SpecimenDetails::
    ~SpecimenDetails ()
    {
    }

    // TestConditionDetails
    //

    TestConditionDetails::
    TestConditionDetails (const id_type& id)
    : ::xml_schema::type (),
      ParameterValue_ (this),
      Notes_ (this),
      id_ (id, this)
    {
    }

    TestConditionDetails::
    TestConditionDetails (const TestConditionDetails& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ParameterValue_ (x.ParameterValue_, f, this),
      Notes_ (x.Notes_, f, this),
      id_ (x.id_, f, this)
    {
    }

    TestConditionDetails::
    TestConditionDetails (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ParameterValue_ (this),
      Notes_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TestConditionDetails::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ParameterValue
        //
        if (n.name () == "ParameterValue" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ParameterValue_type > r (
            ParameterValue_traits::create (i, f, this));

          this->ParameterValue_.push_back (::std::move (r));
          continue;
        }

        // Notes
        //
        if (n.name () == "Notes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Notes_type > r (
            Notes_traits::create (i, f, this));

          if (!this->Notes_)
          {
            this->Notes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    TestConditionDetails* TestConditionDetails::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TestConditionDetails (*this, f, c);
    }

    TestConditionDetails& TestConditionDetails::
    operator= (const TestConditionDetails& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ParameterValue_ = x.ParameterValue_;
        this->Notes_ = x.Notes_;
        this->id_ = x.id_;
      }

      return *this;
    }

    TestConditionDetails::
    ~TestConditionDetails ()
    {
    }

    // ChemicalElementSymbol
    //

    ChemicalElementSymbol::
    ChemicalElementSymbol (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_ChemicalElementSymbol_convert ();
    }

    ChemicalElementSymbol::
    ChemicalElementSymbol (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_ChemicalElementSymbol_convert ();
    }

    ChemicalElementSymbol::
    ChemicalElementSymbol (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_ChemicalElementSymbol_convert ();
    }

    ChemicalElementSymbol* ChemicalElementSymbol::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ChemicalElementSymbol (*this, f, c);
    }

    ChemicalElementSymbol::value ChemicalElementSymbol::
    _xsd_ChemicalElementSymbol_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ChemicalElementSymbol_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ChemicalElementSymbol_indexes_,
                        _xsd_ChemicalElementSymbol_indexes_ + 115,
                        *this,
                        c));

      if (i == _xsd_ChemicalElementSymbol_indexes_ + 115 || _xsd_ChemicalElementSymbol_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ChemicalElementSymbol::
    _xsd_ChemicalElementSymbol_literals_[115] =
    {
      "H",
      "He",
      "Li",
      "Be",
      "B",
      "C",
      "N",
      "O",
      "F",
      "Ne",
      "Na",
      "Mg",
      "Al",
      "Si",
      "P",
      "S",
      "Cl",
      "Ar",
      "K",
      "Ca",
      "Sc",
      "Ti",
      "V",
      "Cr",
      "Mn",
      "Fe",
      "Co",
      "Ni",
      "Cu",
      "Zn",
      "Ga",
      "Ge",
      "As",
      "Se",
      "Br",
      "Kr",
      "Rb",
      "Sr",
      "Y",
      "Zr",
      "Nb",
      "Mo",
      "Tc",
      "Ru",
      "Rh",
      "Pd",
      "Ag",
      "Cd",
      "In",
      "Sn",
      "Sb",
      "Te",
      "I",
      "Xe",
      "Cs",
      "Ba",
      "La",
      "Ce",
      "Pr",
      "Nd",
      "Pm",
      "Sm",
      "Eu",
      "Gd",
      "Tb",
      "Dy",
      "Ho",
      "Er",
      "Tm",
      "Yb",
      "Lu",
      "Hf",
      "Ta",
      "W",
      "Re",
      "Os",
      "Ir",
      "Pt",
      "Au",
      "Hg",
      "Tl",
      "Pb",
      "Bi",
      "Po",
      "At",
      "Rn",
      "Fr",
      "Ra",
      "Ac",
      "Th",
      "Pa",
      "U",
      "Np",
      "Pu",
      "Am",
      "Cm",
      "Bk",
      "Cf",
      "Es",
      "Fm",
      "Md",
      "No",
      "Lr",
      "Rf",
      "Db",
      "Sg",
      "Bh",
      "Hs",
      "Mt",
      "Uun",
      "Uuu",
      "Uub",
      "Uuq",
      "Uuh",
      "Uuo"
    };

    const ChemicalElementSymbol::value ChemicalElementSymbol::
    _xsd_ChemicalElementSymbol_indexes_[115] =
    {
      ::bellshire::lib::ChemicalElementSymbol::Ac,
      ::bellshire::lib::ChemicalElementSymbol::Ag,
      ::bellshire::lib::ChemicalElementSymbol::Al,
      ::bellshire::lib::ChemicalElementSymbol::Am,
      ::bellshire::lib::ChemicalElementSymbol::Ar,
      ::bellshire::lib::ChemicalElementSymbol::As,
      ::bellshire::lib::ChemicalElementSymbol::At,
      ::bellshire::lib::ChemicalElementSymbol::Au,
      ::bellshire::lib::ChemicalElementSymbol::B,
      ::bellshire::lib::ChemicalElementSymbol::Ba,
      ::bellshire::lib::ChemicalElementSymbol::Be,
      ::bellshire::lib::ChemicalElementSymbol::Bh,
      ::bellshire::lib::ChemicalElementSymbol::Bi,
      ::bellshire::lib::ChemicalElementSymbol::Bk,
      ::bellshire::lib::ChemicalElementSymbol::Br,
      ::bellshire::lib::ChemicalElementSymbol::C,
      ::bellshire::lib::ChemicalElementSymbol::Ca,
      ::bellshire::lib::ChemicalElementSymbol::Cd,
      ::bellshire::lib::ChemicalElementSymbol::Ce,
      ::bellshire::lib::ChemicalElementSymbol::Cf,
      ::bellshire::lib::ChemicalElementSymbol::Cl,
      ::bellshire::lib::ChemicalElementSymbol::Cm,
      ::bellshire::lib::ChemicalElementSymbol::Co,
      ::bellshire::lib::ChemicalElementSymbol::Cr,
      ::bellshire::lib::ChemicalElementSymbol::Cs,
      ::bellshire::lib::ChemicalElementSymbol::Cu,
      ::bellshire::lib::ChemicalElementSymbol::Db,
      ::bellshire::lib::ChemicalElementSymbol::Dy,
      ::bellshire::lib::ChemicalElementSymbol::Er,
      ::bellshire::lib::ChemicalElementSymbol::Es,
      ::bellshire::lib::ChemicalElementSymbol::Eu,
      ::bellshire::lib::ChemicalElementSymbol::F,
      ::bellshire::lib::ChemicalElementSymbol::Fe,
      ::bellshire::lib::ChemicalElementSymbol::Fm,
      ::bellshire::lib::ChemicalElementSymbol::Fr,
      ::bellshire::lib::ChemicalElementSymbol::Ga,
      ::bellshire::lib::ChemicalElementSymbol::Gd,
      ::bellshire::lib::ChemicalElementSymbol::Ge,
      ::bellshire::lib::ChemicalElementSymbol::H,
      ::bellshire::lib::ChemicalElementSymbol::He,
      ::bellshire::lib::ChemicalElementSymbol::Hf,
      ::bellshire::lib::ChemicalElementSymbol::Hg,
      ::bellshire::lib::ChemicalElementSymbol::Ho,
      ::bellshire::lib::ChemicalElementSymbol::Hs,
      ::bellshire::lib::ChemicalElementSymbol::I,
      ::bellshire::lib::ChemicalElementSymbol::In,
      ::bellshire::lib::ChemicalElementSymbol::Ir,
      ::bellshire::lib::ChemicalElementSymbol::K,
      ::bellshire::lib::ChemicalElementSymbol::Kr,
      ::bellshire::lib::ChemicalElementSymbol::La,
      ::bellshire::lib::ChemicalElementSymbol::Li,
      ::bellshire::lib::ChemicalElementSymbol::Lr,
      ::bellshire::lib::ChemicalElementSymbol::Lu,
      ::bellshire::lib::ChemicalElementSymbol::Md,
      ::bellshire::lib::ChemicalElementSymbol::Mg,
      ::bellshire::lib::ChemicalElementSymbol::Mn,
      ::bellshire::lib::ChemicalElementSymbol::Mo,
      ::bellshire::lib::ChemicalElementSymbol::Mt,
      ::bellshire::lib::ChemicalElementSymbol::N,
      ::bellshire::lib::ChemicalElementSymbol::Na,
      ::bellshire::lib::ChemicalElementSymbol::Nb,
      ::bellshire::lib::ChemicalElementSymbol::Nd,
      ::bellshire::lib::ChemicalElementSymbol::Ne,
      ::bellshire::lib::ChemicalElementSymbol::Ni,
      ::bellshire::lib::ChemicalElementSymbol::No,
      ::bellshire::lib::ChemicalElementSymbol::Np,
      ::bellshire::lib::ChemicalElementSymbol::O,
      ::bellshire::lib::ChemicalElementSymbol::Os,
      ::bellshire::lib::ChemicalElementSymbol::P,
      ::bellshire::lib::ChemicalElementSymbol::Pa,
      ::bellshire::lib::ChemicalElementSymbol::Pb,
      ::bellshire::lib::ChemicalElementSymbol::Pd,
      ::bellshire::lib::ChemicalElementSymbol::Pm,
      ::bellshire::lib::ChemicalElementSymbol::Po,
      ::bellshire::lib::ChemicalElementSymbol::Pr,
      ::bellshire::lib::ChemicalElementSymbol::Pt,
      ::bellshire::lib::ChemicalElementSymbol::Pu,
      ::bellshire::lib::ChemicalElementSymbol::Ra,
      ::bellshire::lib::ChemicalElementSymbol::Rb,
      ::bellshire::lib::ChemicalElementSymbol::Re,
      ::bellshire::lib::ChemicalElementSymbol::Rf,
      ::bellshire::lib::ChemicalElementSymbol::Rh,
      ::bellshire::lib::ChemicalElementSymbol::Rn,
      ::bellshire::lib::ChemicalElementSymbol::Ru,
      ::bellshire::lib::ChemicalElementSymbol::S,
      ::bellshire::lib::ChemicalElementSymbol::Sb,
      ::bellshire::lib::ChemicalElementSymbol::Sc,
      ::bellshire::lib::ChemicalElementSymbol::Se,
      ::bellshire::lib::ChemicalElementSymbol::Sg,
      ::bellshire::lib::ChemicalElementSymbol::Si,
      ::bellshire::lib::ChemicalElementSymbol::Sm,
      ::bellshire::lib::ChemicalElementSymbol::Sn,
      ::bellshire::lib::ChemicalElementSymbol::Sr,
      ::bellshire::lib::ChemicalElementSymbol::Ta,
      ::bellshire::lib::ChemicalElementSymbol::Tb,
      ::bellshire::lib::ChemicalElementSymbol::Tc,
      ::bellshire::lib::ChemicalElementSymbol::Te,
      ::bellshire::lib::ChemicalElementSymbol::Th,
      ::bellshire::lib::ChemicalElementSymbol::Ti,
      ::bellshire::lib::ChemicalElementSymbol::Tl,
      ::bellshire::lib::ChemicalElementSymbol::Tm,
      ::bellshire::lib::ChemicalElementSymbol::U,
      ::bellshire::lib::ChemicalElementSymbol::Uub,
      ::bellshire::lib::ChemicalElementSymbol::Uuh,
      ::bellshire::lib::ChemicalElementSymbol::Uun,
      ::bellshire::lib::ChemicalElementSymbol::Uuo,
      ::bellshire::lib::ChemicalElementSymbol::Uuq,
      ::bellshire::lib::ChemicalElementSymbol::Uuu,
      ::bellshire::lib::ChemicalElementSymbol::V,
      ::bellshire::lib::ChemicalElementSymbol::W,
      ::bellshire::lib::ChemicalElementSymbol::Xe,
      ::bellshire::lib::ChemicalElementSymbol::Y,
      ::bellshire::lib::ChemicalElementSymbol::Yb,
      ::bellshire::lib::ChemicalElementSymbol::Zn,
      ::bellshire::lib::ChemicalElementSymbol::Zr
    };

    // CurrencyCode
    //

    CurrencyCode::
    CurrencyCode (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_CurrencyCode_convert ();
    }

    CurrencyCode::
    CurrencyCode (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_CurrencyCode_convert ();
    }

    CurrencyCode::
    CurrencyCode (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_CurrencyCode_convert ();
    }

    CurrencyCode* CurrencyCode::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CurrencyCode (*this, f, c);
    }

    CurrencyCode::value CurrencyCode::
    _xsd_CurrencyCode_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CurrencyCode_literals_);
      const value* i (::std::lower_bound (
                        _xsd_CurrencyCode_indexes_,
                        _xsd_CurrencyCode_indexes_ + 182,
                        *this,
                        c));

      if (i == _xsd_CurrencyCode_indexes_ + 182 || _xsd_CurrencyCode_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const CurrencyCode::
    _xsd_CurrencyCode_literals_[182] =
    {
      "AFA",
      "ALL",
      "AMD",
      "ANG",
      "AOA",
      "ARS",
      "ATS",
      "AUD",
      "AWG",
      "AZM",
      "BAM",
      "BBD",
      "BDT",
      "BEF",
      "BGL",
      "BGN",
      "BHD",
      "BIF",
      "BMD",
      "BND",
      "BOB",
      "BOV",
      "BRL",
      "BSD",
      "BTN",
      "BWP",
      "BYB",
      "BYR",
      "BZD",
      "CAD",
      "CDF",
      "CHF",
      "CLF",
      "CLP",
      "CNY",
      "COP",
      "CRC",
      "CUP",
      "CVE",
      "CYP",
      "CZK",
      "DEM",
      "DJF",
      "DKK",
      "DOP",
      "DZD",
      "EEK",
      "EGP",
      "ERN",
      "ESP",
      "ETB",
      "EUR",
      "FIM",
      "FJD",
      "FKP",
      "FRF",
      "GBP",
      "GEL",
      "GHC",
      "GIP",
      "GMD",
      "GNF",
      "GRD",
      "GTQ",
      "GWP",
      "GYD",
      "HKD",
      "HNL",
      "HRK",
      "HTG",
      "HUF",
      "IDR",
      "IEP",
      "ILS",
      "INR",
      "IQD",
      "IRR",
      "ISK",
      "ITL",
      "JMD",
      "JOD",
      "JPY",
      "KES",
      "KGS",
      "KHR",
      "KMF",
      "KPW",
      "KRW",
      "KWD",
      "KYD",
      "KZT",
      "LAK",
      "LBP",
      "LKR",
      "LRD",
      "LSL",
      "LTL",
      "LUF",
      "LVL",
      "LYD",
      "MAD",
      "MDL",
      "MGF",
      "MKD",
      "MMK",
      "MNT",
      "MOP",
      "MRO",
      "MTL",
      "MUR",
      "MVR",
      "MWK",
      "MXN",
      "MXV",
      "MYR",
      "MZM",
      "NAD",
      "NGN",
      "NIO",
      "NLG",
      "NOK",
      "NPR",
      "NZD",
      "OMR",
      "PAB",
      "PEN",
      "PGK",
      "PHP",
      "PKR",
      "PLN",
      "PTE",
      "PYG",
      "QAR",
      "ROL",
      "RUB",
      "RUR",
      "RWF",
      "SAR",
      "SBD",
      "SCR",
      "SDD",
      "SEK",
      "SGD",
      "SHP",
      "SIT",
      "SKK",
      "SLL",
      "SOS",
      "SRG",
      "STD",
      "SVC",
      "SYP",
      "SZL",
      "THB",
      "TJR",
      "TMM",
      "TND",
      "TOP",
      "TPE",
      "TRL",
      "TTD",
      "TWD",
      "TZS",
      "UAH",
      "UGX",
      "USD",
      "UYU",
      "UZS",
      "VEB",
      "VND",
      "VUV",
      "WST",
      "XAF",
      "XCD",
      "XDR",
      "XOF",
      "XPF",
      "YER",
      "YUM",
      "ZAR",
      "ZMK",
      "ZWD"
    };

    const CurrencyCode::value CurrencyCode::
    _xsd_CurrencyCode_indexes_[182] =
    {
      ::bellshire::lib::CurrencyCode::AFA,
      ::bellshire::lib::CurrencyCode::ALL,
      ::bellshire::lib::CurrencyCode::AMD,
      ::bellshire::lib::CurrencyCode::ANG,
      ::bellshire::lib::CurrencyCode::AOA,
      ::bellshire::lib::CurrencyCode::ARS,
      ::bellshire::lib::CurrencyCode::ATS,
      ::bellshire::lib::CurrencyCode::AUD,
      ::bellshire::lib::CurrencyCode::AWG,
      ::bellshire::lib::CurrencyCode::AZM,
      ::bellshire::lib::CurrencyCode::BAM,
      ::bellshire::lib::CurrencyCode::BBD,
      ::bellshire::lib::CurrencyCode::BDT,
      ::bellshire::lib::CurrencyCode::BEF,
      ::bellshire::lib::CurrencyCode::BGL,
      ::bellshire::lib::CurrencyCode::BGN,
      ::bellshire::lib::CurrencyCode::BHD,
      ::bellshire::lib::CurrencyCode::BIF,
      ::bellshire::lib::CurrencyCode::BMD,
      ::bellshire::lib::CurrencyCode::BND,
      ::bellshire::lib::CurrencyCode::BOB,
      ::bellshire::lib::CurrencyCode::BOV,
      ::bellshire::lib::CurrencyCode::BRL,
      ::bellshire::lib::CurrencyCode::BSD,
      ::bellshire::lib::CurrencyCode::BTN,
      ::bellshire::lib::CurrencyCode::BWP,
      ::bellshire::lib::CurrencyCode::BYB,
      ::bellshire::lib::CurrencyCode::BYR,
      ::bellshire::lib::CurrencyCode::BZD,
      ::bellshire::lib::CurrencyCode::CAD,
      ::bellshire::lib::CurrencyCode::CDF,
      ::bellshire::lib::CurrencyCode::CHF,
      ::bellshire::lib::CurrencyCode::CLF,
      ::bellshire::lib::CurrencyCode::CLP,
      ::bellshire::lib::CurrencyCode::CNY,
      ::bellshire::lib::CurrencyCode::COP,
      ::bellshire::lib::CurrencyCode::CRC,
      ::bellshire::lib::CurrencyCode::CUP,
      ::bellshire::lib::CurrencyCode::CVE,
      ::bellshire::lib::CurrencyCode::CYP,
      ::bellshire::lib::CurrencyCode::CZK,
      ::bellshire::lib::CurrencyCode::DEM,
      ::bellshire::lib::CurrencyCode::DJF,
      ::bellshire::lib::CurrencyCode::DKK,
      ::bellshire::lib::CurrencyCode::DOP,
      ::bellshire::lib::CurrencyCode::DZD,
      ::bellshire::lib::CurrencyCode::EEK,
      ::bellshire::lib::CurrencyCode::EGP,
      ::bellshire::lib::CurrencyCode::ERN,
      ::bellshire::lib::CurrencyCode::ESP,
      ::bellshire::lib::CurrencyCode::ETB,
      ::bellshire::lib::CurrencyCode::EUR,
      ::bellshire::lib::CurrencyCode::FIM,
      ::bellshire::lib::CurrencyCode::FJD,
      ::bellshire::lib::CurrencyCode::FKP,
      ::bellshire::lib::CurrencyCode::FRF,
      ::bellshire::lib::CurrencyCode::GBP,
      ::bellshire::lib::CurrencyCode::GEL,
      ::bellshire::lib::CurrencyCode::GHC,
      ::bellshire::lib::CurrencyCode::GIP,
      ::bellshire::lib::CurrencyCode::GMD,
      ::bellshire::lib::CurrencyCode::GNF,
      ::bellshire::lib::CurrencyCode::GRD,
      ::bellshire::lib::CurrencyCode::GTQ,
      ::bellshire::lib::CurrencyCode::GWP,
      ::bellshire::lib::CurrencyCode::GYD,
      ::bellshire::lib::CurrencyCode::HKD,
      ::bellshire::lib::CurrencyCode::HNL,
      ::bellshire::lib::CurrencyCode::HRK,
      ::bellshire::lib::CurrencyCode::HTG,
      ::bellshire::lib::CurrencyCode::HUF,
      ::bellshire::lib::CurrencyCode::IDR,
      ::bellshire::lib::CurrencyCode::IEP,
      ::bellshire::lib::CurrencyCode::ILS,
      ::bellshire::lib::CurrencyCode::INR,
      ::bellshire::lib::CurrencyCode::IQD,
      ::bellshire::lib::CurrencyCode::IRR,
      ::bellshire::lib::CurrencyCode::ISK,
      ::bellshire::lib::CurrencyCode::ITL,
      ::bellshire::lib::CurrencyCode::JMD,
      ::bellshire::lib::CurrencyCode::JOD,
      ::bellshire::lib::CurrencyCode::JPY,
      ::bellshire::lib::CurrencyCode::KES,
      ::bellshire::lib::CurrencyCode::KGS,
      ::bellshire::lib::CurrencyCode::KHR,
      ::bellshire::lib::CurrencyCode::KMF,
      ::bellshire::lib::CurrencyCode::KPW,
      ::bellshire::lib::CurrencyCode::KRW,
      ::bellshire::lib::CurrencyCode::KWD,
      ::bellshire::lib::CurrencyCode::KYD,
      ::bellshire::lib::CurrencyCode::KZT,
      ::bellshire::lib::CurrencyCode::LAK,
      ::bellshire::lib::CurrencyCode::LBP,
      ::bellshire::lib::CurrencyCode::LKR,
      ::bellshire::lib::CurrencyCode::LRD,
      ::bellshire::lib::CurrencyCode::LSL,
      ::bellshire::lib::CurrencyCode::LTL,
      ::bellshire::lib::CurrencyCode::LUF,
      ::bellshire::lib::CurrencyCode::LVL,
      ::bellshire::lib::CurrencyCode::LYD,
      ::bellshire::lib::CurrencyCode::MAD,
      ::bellshire::lib::CurrencyCode::MDL,
      ::bellshire::lib::CurrencyCode::MGF,
      ::bellshire::lib::CurrencyCode::MKD,
      ::bellshire::lib::CurrencyCode::MMK,
      ::bellshire::lib::CurrencyCode::MNT,
      ::bellshire::lib::CurrencyCode::MOP,
      ::bellshire::lib::CurrencyCode::MRO,
      ::bellshire::lib::CurrencyCode::MTL,
      ::bellshire::lib::CurrencyCode::MUR,
      ::bellshire::lib::CurrencyCode::MVR,
      ::bellshire::lib::CurrencyCode::MWK,
      ::bellshire::lib::CurrencyCode::MXN,
      ::bellshire::lib::CurrencyCode::MXV,
      ::bellshire::lib::CurrencyCode::MYR,
      ::bellshire::lib::CurrencyCode::MZM,
      ::bellshire::lib::CurrencyCode::NAD,
      ::bellshire::lib::CurrencyCode::NGN,
      ::bellshire::lib::CurrencyCode::NIO,
      ::bellshire::lib::CurrencyCode::NLG,
      ::bellshire::lib::CurrencyCode::NOK,
      ::bellshire::lib::CurrencyCode::NPR,
      ::bellshire::lib::CurrencyCode::NZD,
      ::bellshire::lib::CurrencyCode::OMR,
      ::bellshire::lib::CurrencyCode::PAB,
      ::bellshire::lib::CurrencyCode::PEN,
      ::bellshire::lib::CurrencyCode::PGK,
      ::bellshire::lib::CurrencyCode::PHP,
      ::bellshire::lib::CurrencyCode::PKR,
      ::bellshire::lib::CurrencyCode::PLN,
      ::bellshire::lib::CurrencyCode::PTE,
      ::bellshire::lib::CurrencyCode::PYG,
      ::bellshire::lib::CurrencyCode::QAR,
      ::bellshire::lib::CurrencyCode::ROL,
      ::bellshire::lib::CurrencyCode::RUB,
      ::bellshire::lib::CurrencyCode::RUR,
      ::bellshire::lib::CurrencyCode::RWF,
      ::bellshire::lib::CurrencyCode::SAR,
      ::bellshire::lib::CurrencyCode::SBD,
      ::bellshire::lib::CurrencyCode::SCR,
      ::bellshire::lib::CurrencyCode::SDD,
      ::bellshire::lib::CurrencyCode::SEK,
      ::bellshire::lib::CurrencyCode::SGD,
      ::bellshire::lib::CurrencyCode::SHP,
      ::bellshire::lib::CurrencyCode::SIT,
      ::bellshire::lib::CurrencyCode::SKK,
      ::bellshire::lib::CurrencyCode::SLL,
      ::bellshire::lib::CurrencyCode::SOS,
      ::bellshire::lib::CurrencyCode::SRG,
      ::bellshire::lib::CurrencyCode::STD,
      ::bellshire::lib::CurrencyCode::SVC,
      ::bellshire::lib::CurrencyCode::SYP,
      ::bellshire::lib::CurrencyCode::SZL,
      ::bellshire::lib::CurrencyCode::THB,
      ::bellshire::lib::CurrencyCode::TJR,
      ::bellshire::lib::CurrencyCode::TMM,
      ::bellshire::lib::CurrencyCode::TND,
      ::bellshire::lib::CurrencyCode::TOP,
      ::bellshire::lib::CurrencyCode::TPE,
      ::bellshire::lib::CurrencyCode::TRL,
      ::bellshire::lib::CurrencyCode::TTD,
      ::bellshire::lib::CurrencyCode::TWD,
      ::bellshire::lib::CurrencyCode::TZS,
      ::bellshire::lib::CurrencyCode::UAH,
      ::bellshire::lib::CurrencyCode::UGX,
      ::bellshire::lib::CurrencyCode::USD,
      ::bellshire::lib::CurrencyCode::UYU,
      ::bellshire::lib::CurrencyCode::UZS,
      ::bellshire::lib::CurrencyCode::VEB,
      ::bellshire::lib::CurrencyCode::VND,
      ::bellshire::lib::CurrencyCode::VUV,
      ::bellshire::lib::CurrencyCode::WST,
      ::bellshire::lib::CurrencyCode::XAF,
      ::bellshire::lib::CurrencyCode::XCD,
      ::bellshire::lib::CurrencyCode::XDR,
      ::bellshire::lib::CurrencyCode::XOF,
      ::bellshire::lib::CurrencyCode::XPF,
      ::bellshire::lib::CurrencyCode::YER,
      ::bellshire::lib::CurrencyCode::YUM,
      ::bellshire::lib::CurrencyCode::ZAR,
      ::bellshire::lib::CurrencyCode::ZMK,
      ::bellshire::lib::CurrencyCode::ZWD
    };

    // Associate_lib
    // 

    const ::xml_schema::type* Associate_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Associate_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Associate_lib::
    Associate_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Associate_lib::
    Associate_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Associate_lib::
    Associate_lib (const Associate_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Associate_lib* Associate_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Associate_lib (*this, f);
    }

    const ::std::string& Associate_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Associate_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Associate_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Associate_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Associate_lib::
    name_ ("Associate_lib");

    const ::std::string Associate_lib::
    namespace__ ("");

    Associate_lib::
    ~Associate_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Associate_lib, char, ::xml_schema::type >
    _xsd_Associate_lib_parser_init (Associate_lib::name (), Associate_lib::namespace_ ());

    // AssociationDetails_lib
    // 

    const ::xml_schema::type* AssociationDetails_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* AssociationDetails_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    AssociationDetails_lib::
    AssociationDetails_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    AssociationDetails_lib::
    AssociationDetails_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    AssociationDetails_lib::
    AssociationDetails_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    AssociationDetails_lib::
    AssociationDetails_lib (const AssociationDetails_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    AssociationDetails_lib* AssociationDetails_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class AssociationDetails_lib (*this, f);
    }

    const ::std::string& AssociationDetails_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& AssociationDetails_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& AssociationDetails_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& AssociationDetails_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string AssociationDetails_lib::
    name_ ("AssociationDetails_lib");

    const ::std::string AssociationDetails_lib::
    namespace__ ("");

    AssociationDetails_lib::
    ~AssociationDetails_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< AssociationDetails_lib, char, ::xml_schema::type >
    _xsd_AssociationDetails_lib_parser_init (AssociationDetails_lib::name (), AssociationDetails_lib::namespace_ ());

    // AuthorityDetails_lib
    // 

    const ::xml_schema::type* AuthorityDetails_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* AuthorityDetails_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    AuthorityDetails_lib::
    AuthorityDetails_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    AuthorityDetails_lib::
    AuthorityDetails_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    AuthorityDetails_lib::
    AuthorityDetails_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    AuthorityDetails_lib::
    AuthorityDetails_lib (const AuthorityDetails_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    AuthorityDetails_lib* AuthorityDetails_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class AuthorityDetails_lib (*this, f);
    }

    const ::std::string& AuthorityDetails_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& AuthorityDetails_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& AuthorityDetails_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& AuthorityDetails_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string AuthorityDetails_lib::
    name_ ("AuthorityDetails_lib");

    const ::std::string AuthorityDetails_lib::
    namespace__ ("");

    AuthorityDetails_lib::
    ~AuthorityDetails_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< AuthorityDetails_lib, char, ::xml_schema::type >
    _xsd_AuthorityDetails_lib_parser_init (AuthorityDetails_lib::name (), AuthorityDetails_lib::namespace_ ());

    // BulkDetails_lib
    // 

    const ::xml_schema::type* BulkDetails_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* BulkDetails_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    BulkDetails_lib::
    BulkDetails_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    BulkDetails_lib::
    BulkDetails_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    BulkDetails_lib::
    BulkDetails_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    BulkDetails_lib::
    BulkDetails_lib (const BulkDetails_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    BulkDetails_lib* BulkDetails_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class BulkDetails_lib (*this, f);
    }

    const ::std::string& BulkDetails_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& BulkDetails_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& BulkDetails_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& BulkDetails_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string BulkDetails_lib::
    name_ ("BulkDetails_lib");

    const ::std::string BulkDetails_lib::
    namespace__ ("");

    BulkDetails_lib::
    ~BulkDetails_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< BulkDetails_lib, char, ::xml_schema::type >
    _xsd_BulkDetails_lib_parser_init (BulkDetails_lib::name (), BulkDetails_lib::namespace_ ());

    // Characterization_lib
    // 

    const ::xml_schema::type* Characterization_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Characterization_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Characterization_lib::
    Characterization_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Characterization_lib::
    Characterization_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    Characterization_lib::
    Characterization_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Characterization_lib::
    Characterization_lib (const Characterization_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Characterization_lib* Characterization_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Characterization_lib (*this, f);
    }

    const ::std::string& Characterization_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Characterization_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Characterization_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Characterization_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Characterization_lib::
    name_ ("Characterization_lib");

    const ::std::string Characterization_lib::
    namespace__ ("");

    Characterization_lib::
    ~Characterization_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Characterization_lib, char, ::xml_schema::type >
    _xsd_Characterization_lib_parser_init (Characterization_lib::name (), Characterization_lib::namespace_ ());

    // ChemicalComposition_lib
    // 

    const ::xml_schema::type* ChemicalComposition_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* ChemicalComposition_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    ChemicalComposition_lib::
    ChemicalComposition_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    ChemicalComposition_lib::
    ChemicalComposition_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    ChemicalComposition_lib::
    ChemicalComposition_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    ChemicalComposition_lib::
    ChemicalComposition_lib (const ChemicalComposition_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    ChemicalComposition_lib* ChemicalComposition_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class ChemicalComposition_lib (*this, f);
    }

    const ::std::string& ChemicalComposition_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& ChemicalComposition_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& ChemicalComposition_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& ChemicalComposition_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string ChemicalComposition_lib::
    name_ ("ChemicalComposition_lib");

    const ::std::string ChemicalComposition_lib::
    namespace__ ("");

    ChemicalComposition_lib::
    ~ChemicalComposition_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< ChemicalComposition_lib, char, ::xml_schema::type >
    _xsd_ChemicalComposition_lib_parser_init (ChemicalComposition_lib::name (), ChemicalComposition_lib::namespace_ ());

    // ChemicalElementSymbol_lib
    // 

    const ::xml_schema::type* ChemicalElementSymbol_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* ChemicalElementSymbol_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    ChemicalElementSymbol_lib::
    ChemicalElementSymbol_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    ChemicalElementSymbol_lib::
    ChemicalElementSymbol_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    ChemicalElementSymbol_lib::
    ChemicalElementSymbol_lib (const ChemicalElementSymbol_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    ChemicalElementSymbol_lib* ChemicalElementSymbol_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class ChemicalElementSymbol_lib (*this, f);
    }

    const ::std::string& ChemicalElementSymbol_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& ChemicalElementSymbol_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& ChemicalElementSymbol_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& ChemicalElementSymbol_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string ChemicalElementSymbol_lib::
    name_ ("ChemicalElementSymbol_lib");

    const ::std::string ChemicalElementSymbol_lib::
    namespace__ ("");

    ChemicalElementSymbol_lib::
    ~ChemicalElementSymbol_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< ChemicalElementSymbol_lib, char, ::xml_schema::type >
    _xsd_ChemicalElementSymbol_lib_parser_init (ChemicalElementSymbol_lib::name (), ChemicalElementSymbol_lib::namespace_ ());

    // Class_lib
    // 

    const ::xml_schema::type* Class_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Class_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Class_lib::
    Class_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Class_lib::
    Class_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    Class_lib::
    Class_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Class_lib::
    Class_lib (const Class_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Class_lib* Class_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Class_lib (*this, f);
    }

    const ::std::string& Class_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Class_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Class_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Class_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Class_lib::
    name_ ("Class_lib");

    const ::std::string Class_lib::
    namespace__ ("");

    Class_lib::
    ~Class_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Class_lib, char, ::xml_schema::type >
    _xsd_Class_lib_parser_init (Class_lib::name (), Class_lib::namespace_ ());

    // ComponentDetails_lib
    // 

    const ::xml_schema::type* ComponentDetails_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* ComponentDetails_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    ComponentDetails_lib::
    ComponentDetails_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    ComponentDetails_lib::
    ComponentDetails_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    ComponentDetails_lib::
    ComponentDetails_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    ComponentDetails_lib::
    ComponentDetails_lib (const ComponentDetails_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    ComponentDetails_lib* ComponentDetails_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class ComponentDetails_lib (*this, f);
    }

    const ::std::string& ComponentDetails_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& ComponentDetails_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& ComponentDetails_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& ComponentDetails_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string ComponentDetails_lib::
    name_ ("ComponentDetails_lib");

    const ::std::string ComponentDetails_lib::
    namespace__ ("");

    ComponentDetails_lib::
    ~ComponentDetails_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< ComponentDetails_lib, char, ::xml_schema::type >
    _xsd_ComponentDetails_lib_parser_init (ComponentDetails_lib::name (), ComponentDetails_lib::namespace_ ());

    // Compound_lib
    // 

    const ::xml_schema::type* Compound_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Compound_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Compound_lib::
    Compound_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Compound_lib::
    Compound_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    Compound_lib::
    Compound_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Compound_lib::
    Compound_lib (const Compound_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Compound_lib* Compound_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Compound_lib (*this, f);
    }

    const ::std::string& Compound_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Compound_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Compound_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Compound_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Compound_lib::
    name_ ("Compound_lib");

    const ::std::string Compound_lib::
    namespace__ ("");

    Compound_lib::
    ~Compound_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Compound_lib, char, ::xml_schema::type >
    _xsd_Compound_lib_parser_init (Compound_lib::name (), Compound_lib::namespace_ ());

    // Concentration_lib
    // 

    const ::xml_schema::type* Concentration_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Concentration_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Concentration_lib::
    Concentration_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Concentration_lib::
    Concentration_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    Concentration_lib::
    Concentration_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Concentration_lib::
    Concentration_lib (const Concentration_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Concentration_lib* Concentration_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Concentration_lib (*this, f);
    }

    const ::std::string& Concentration_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Concentration_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Concentration_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Concentration_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Concentration_lib::
    name_ ("Concentration_lib");

    const ::std::string Concentration_lib::
    namespace__ ("");

    Concentration_lib::
    ~Concentration_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Concentration_lib, char, ::xml_schema::type >
    _xsd_Concentration_lib_parser_init (Concentration_lib::name (), Concentration_lib::namespace_ ());

    // CurrencyCode_lib
    // 

    const ::xml_schema::type* CurrencyCode_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* CurrencyCode_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    CurrencyCode_lib::
    CurrencyCode_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    CurrencyCode_lib::
    CurrencyCode_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    CurrencyCode_lib::
    CurrencyCode_lib (const CurrencyCode_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    CurrencyCode_lib* CurrencyCode_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class CurrencyCode_lib (*this, f);
    }

    const ::std::string& CurrencyCode_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& CurrencyCode_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& CurrencyCode_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& CurrencyCode_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string CurrencyCode_lib::
    name_ ("CurrencyCode_lib");

    const ::std::string CurrencyCode_lib::
    namespace__ ("");

    CurrencyCode_lib::
    ~CurrencyCode_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< CurrencyCode_lib, char, ::xml_schema::type >
    _xsd_CurrencyCode_lib_parser_init (CurrencyCode_lib::name (), CurrencyCode_lib::namespace_ ());

    // DataFormat_lib
    // 

    const ::xml_schema::type* DataFormat_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* DataFormat_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    DataFormat_lib::
    DataFormat_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    DataFormat_lib::
    DataFormat_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    DataFormat_lib::
    DataFormat_lib (const DataFormat_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    DataFormat_lib* DataFormat_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class DataFormat_lib (*this, f);
    }

    const ::std::string& DataFormat_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& DataFormat_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& DataFormat_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& DataFormat_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string DataFormat_lib::
    name_ ("DataFormat_lib");

    const ::std::string DataFormat_lib::
    namespace__ ("");

    DataFormat_lib::
    ~DataFormat_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< DataFormat_lib, char, ::xml_schema::type >
    _xsd_DataFormat_lib_parser_init (DataFormat_lib::name (), DataFormat_lib::namespace_ ());

    // DataSourceDetails_lib
    // 

    const ::xml_schema::type* DataSourceDetails_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* DataSourceDetails_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    DataSourceDetails_lib::
    DataSourceDetails_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    DataSourceDetails_lib::
    DataSourceDetails_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    DataSourceDetails_lib::
    DataSourceDetails_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    DataSourceDetails_lib::
    DataSourceDetails_lib (const DataSourceDetails_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    DataSourceDetails_lib* DataSourceDetails_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class DataSourceDetails_lib (*this, f);
    }

    const ::std::string& DataSourceDetails_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& DataSourceDetails_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& DataSourceDetails_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& DataSourceDetails_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string DataSourceDetails_lib::
    name_ ("DataSourceDetails_lib");

    const ::std::string DataSourceDetails_lib::
    namespace__ ("");

    DataSourceDetails_lib::
    ~DataSourceDetails_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< DataSourceDetails_lib, char, ::xml_schema::type >
    _xsd_DataSourceDetails_lib_parser_init (DataSourceDetails_lib::name (), DataSourceDetails_lib::namespace_ ());

    // DimensionalDetails_lib
    // 

    const ::xml_schema::type* DimensionalDetails_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* DimensionalDetails_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    DimensionalDetails_lib::
    DimensionalDetails_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    DimensionalDetails_lib::
    DimensionalDetails_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    DimensionalDetails_lib::
    DimensionalDetails_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    DimensionalDetails_lib::
    DimensionalDetails_lib (const DimensionalDetails_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    DimensionalDetails_lib* DimensionalDetails_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class DimensionalDetails_lib (*this, f);
    }

    const ::std::string& DimensionalDetails_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& DimensionalDetails_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& DimensionalDetails_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& DimensionalDetails_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string DimensionalDetails_lib::
    name_ ("DimensionalDetails_lib");

    const ::std::string DimensionalDetails_lib::
    namespace__ ("");

    DimensionalDetails_lib::
    ~DimensionalDetails_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< DimensionalDetails_lib, char, ::xml_schema::type >
    _xsd_DimensionalDetails_lib_parser_init (DimensionalDetails_lib::name (), DimensionalDetails_lib::namespace_ ());

    // Element_lib
    // 

    const ::xml_schema::type* Element_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Element_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Element_lib::
    Element_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Element_lib::
    Element_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    Element_lib::
    Element_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Element_lib::
    Element_lib (const Element_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Element_lib* Element_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Element_lib (*this, f);
    }

    const ::std::string& Element_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Element_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Element_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Element_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Element_lib::
    name_ ("Element_lib");

    const ::std::string Element_lib::
    namespace__ ("");

    Element_lib::
    ~Element_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Element_lib, char, ::xml_schema::type >
    _xsd_Element_lib_parser_init (Element_lib::name (), Element_lib::namespace_ ());

    // Form_lib
    // 

    const ::xml_schema::type* Form_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Form_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Form_lib::
    Form_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Form_lib::
    Form_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    Form_lib::
    Form_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Form_lib::
    Form_lib (const Form_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Form_lib* Form_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Form_lib (*this, f);
    }

    const ::std::string& Form_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Form_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Form_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Form_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Form_lib::
    name_ ("Form_lib");

    const ::std::string Form_lib::
    namespace__ ("");

    Form_lib::
    ~Form_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Form_lib, char, ::xml_schema::type >
    _xsd_Form_lib_parser_init (Form_lib::name (), Form_lib::namespace_ ());

    // Formula_lib
    // 

    const ::xml_schema::type* Formula_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Formula_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Formula_lib::
    Formula_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Formula_lib::
    Formula_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Formula_lib::
    Formula_lib (const Formula_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Formula_lib* Formula_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Formula_lib (*this, f);
    }

    const ::std::string& Formula_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Formula_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Formula_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Formula_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Formula_lib::
    name_ ("Formula_lib");

    const ::std::string Formula_lib::
    namespace__ ("");

    Formula_lib::
    ~Formula_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Formula_lib, char, ::xml_schema::type >
    _xsd_Formula_lib_parser_init (Formula_lib::name (), Formula_lib::namespace_ ());

    // Geometry_lib
    // 

    const ::xml_schema::type* Geometry_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Geometry_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Geometry_lib::
    Geometry_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Geometry_lib::
    Geometry_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    Geometry_lib::
    Geometry_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Geometry_lib::
    Geometry_lib (const Geometry_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Geometry_lib* Geometry_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Geometry_lib (*this, f);
    }

    const ::std::string& Geometry_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Geometry_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Geometry_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Geometry_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Geometry_lib::
    name_ ("Geometry_lib");

    const ::std::string Geometry_lib::
    namespace__ ("");

    Geometry_lib::
    ~Geometry_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Geometry_lib, char, ::xml_schema::type >
    _xsd_Geometry_lib_parser_init (Geometry_lib::name (), Geometry_lib::namespace_ ());

    // Glossary_lib
    // 

    const ::xml_schema::type* Glossary_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Glossary_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Glossary_lib::
    Glossary_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Glossary_lib::
    Glossary_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    Glossary_lib::
    Glossary_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Glossary_lib::
    Glossary_lib (const Glossary_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Glossary_lib* Glossary_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Glossary_lib (*this, f);
    }

    const ::std::string& Glossary_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Glossary_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Glossary_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Glossary_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Glossary_lib::
    name_ ("Glossary_lib");

    const ::std::string Glossary_lib::
    namespace__ ("");

    Glossary_lib::
    ~Glossary_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Glossary_lib, char, ::xml_schema::type >
    _xsd_Glossary_lib_parser_init (Glossary_lib::name (), Glossary_lib::namespace_ ());

    // GlossaryTerm_lib
    // 

    const ::xml_schema::type* GlossaryTerm_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* GlossaryTerm_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    GlossaryTerm_lib::
    GlossaryTerm_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    GlossaryTerm_lib::
    GlossaryTerm_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    GlossaryTerm_lib::
    GlossaryTerm_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    GlossaryTerm_lib::
    GlossaryTerm_lib (const GlossaryTerm_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    GlossaryTerm_lib* GlossaryTerm_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class GlossaryTerm_lib (*this, f);
    }

    const ::std::string& GlossaryTerm_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& GlossaryTerm_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& GlossaryTerm_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& GlossaryTerm_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string GlossaryTerm_lib::
    name_ ("GlossaryTerm_lib");

    const ::std::string GlossaryTerm_lib::
    namespace__ ("");

    GlossaryTerm_lib::
    ~GlossaryTerm_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< GlossaryTerm_lib, char, ::xml_schema::type >
    _xsd_GlossaryTerm_lib_parser_init (GlossaryTerm_lib::name (), GlossaryTerm_lib::namespace_ ());

    // Graphs_lib
    // 

    const ::xml_schema::type* Graphs_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Graphs_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Graphs_lib::
    Graphs_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Graphs_lib::
    Graphs_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    Graphs_lib::
    Graphs_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Graphs_lib::
    Graphs_lib (const Graphs_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Graphs_lib* Graphs_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Graphs_lib (*this, f);
    }

    const ::std::string& Graphs_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Graphs_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Graphs_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Graphs_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Graphs_lib::
    name_ ("Graphs_lib");

    const ::std::string Graphs_lib::
    namespace__ ("");

    Graphs_lib::
    ~Graphs_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Graphs_lib, char, ::xml_schema::type >
    _xsd_Graphs_lib_parser_init (Graphs_lib::name (), Graphs_lib::namespace_ ());

    // Material_lib
    // 

    const ::xml_schema::type* Material_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Material_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Material_lib::
    Material_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Material_lib::
    Material_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    Material_lib::
    Material_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Material_lib::
    Material_lib (const Material_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Material_lib* Material_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Material_lib (*this, f);
    }

    const ::std::string& Material_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Material_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Material_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Material_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Material_lib::
    name_ ("Material_lib");

    const ::std::string Material_lib::
    namespace__ ("");

    Material_lib::
    ~Material_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Material_lib, char, ::xml_schema::type >
    _xsd_Material_lib_parser_init (Material_lib::name (), Material_lib::namespace_ ());

    // MeasurementTechniqueDetails_lib
    // 

    const ::xml_schema::type* MeasurementTechniqueDetails_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* MeasurementTechniqueDetails_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    MeasurementTechniqueDetails_lib::
    MeasurementTechniqueDetails_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    MeasurementTechniqueDetails_lib::
    MeasurementTechniqueDetails_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    MeasurementTechniqueDetails_lib::
    MeasurementTechniqueDetails_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    MeasurementTechniqueDetails_lib::
    MeasurementTechniqueDetails_lib (const MeasurementTechniqueDetails_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    MeasurementTechniqueDetails_lib* MeasurementTechniqueDetails_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class MeasurementTechniqueDetails_lib (*this, f);
    }

    const ::std::string& MeasurementTechniqueDetails_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& MeasurementTechniqueDetails_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& MeasurementTechniqueDetails_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& MeasurementTechniqueDetails_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string MeasurementTechniqueDetails_lib::
    name_ ("MeasurementTechniqueDetails_lib");

    const ::std::string MeasurementTechniqueDetails_lib::
    namespace__ ("");

    MeasurementTechniqueDetails_lib::
    ~MeasurementTechniqueDetails_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< MeasurementTechniqueDetails_lib, char, ::xml_schema::type >
    _xsd_MeasurementTechniqueDetails_lib_parser_init (MeasurementTechniqueDetails_lib::name (), MeasurementTechniqueDetails_lib::namespace_ ());

    // Metadata_lib
    // 

    const ::xml_schema::type* Metadata_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Metadata_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Metadata_lib::
    Metadata_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Metadata_lib::
    Metadata_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    Metadata_lib::
    Metadata_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Metadata_lib::
    Metadata_lib (const Metadata_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Metadata_lib* Metadata_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Metadata_lib (*this, f);
    }

    const ::std::string& Metadata_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Metadata_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Metadata_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Metadata_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Metadata_lib::
    name_ ("Metadata_lib");

    const ::std::string Metadata_lib::
    namespace__ ("");

    Metadata_lib::
    ~Metadata_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Metadata_lib, char, ::xml_schema::type >
    _xsd_Metadata_lib_parser_init (Metadata_lib::name (), Metadata_lib::namespace_ ());

    // Name_lib
    // 

    const ::xml_schema::type* Name_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Name_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Name_lib::
    Name_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Name_lib::
    Name_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    Name_lib::
    Name_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Name_lib::
    Name_lib (const Name_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Name_lib* Name_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Name_lib (*this, f);
    }

    const ::std::string& Name_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Name_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Name_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Name_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Name_lib::
    name_ ("Name_lib");

    const ::std::string Name_lib::
    namespace__ ("");

    Name_lib::
    ~Name_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Name_lib, char, ::xml_schema::type >
    _xsd_Name_lib_parser_init (Name_lib::name (), Name_lib::namespace_ ());

    // Notes_lib
    // 

    const ::xml_schema::type* Notes_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Notes_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Notes_lib::
    Notes_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Notes_lib::
    Notes_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Notes_lib::
    Notes_lib (const Notes_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Notes_lib* Notes_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Notes_lib (*this, f);
    }

    const ::std::string& Notes_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Notes_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Notes_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Notes_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Notes_lib::
    name_ ("Notes_lib");

    const ::std::string Notes_lib::
    namespace__ ("");

    Notes_lib::
    ~Notes_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Notes_lib, char, ::xml_schema::type >
    _xsd_Notes_lib_parser_init (Notes_lib::name (), Notes_lib::namespace_ ());

    // ParameterDetails_lib
    // 

    const ::xml_schema::type* ParameterDetails_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* ParameterDetails_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    ParameterDetails_lib::
    ParameterDetails_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    ParameterDetails_lib::
    ParameterDetails_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    ParameterDetails_lib::
    ParameterDetails_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    ParameterDetails_lib::
    ParameterDetails_lib (const ParameterDetails_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    ParameterDetails_lib* ParameterDetails_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class ParameterDetails_lib (*this, f);
    }

    const ::std::string& ParameterDetails_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& ParameterDetails_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& ParameterDetails_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& ParameterDetails_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string ParameterDetails_lib::
    name_ ("ParameterDetails_lib");

    const ::std::string ParameterDetails_lib::
    namespace__ ("");

    ParameterDetails_lib::
    ~ParameterDetails_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< ParameterDetails_lib, char, ::xml_schema::type >
    _xsd_ParameterDetails_lib_parser_init (ParameterDetails_lib::name (), ParameterDetails_lib::namespace_ ());

    // ParameterValue_lib
    // 

    const ::xml_schema::type* ParameterValue_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* ParameterValue_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    ParameterValue_lib::
    ParameterValue_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    ParameterValue_lib::
    ParameterValue_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    ParameterValue_lib::
    ParameterValue_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    ParameterValue_lib::
    ParameterValue_lib (const ParameterValue_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    ParameterValue_lib* ParameterValue_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class ParameterValue_lib (*this, f);
    }

    const ::std::string& ParameterValue_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& ParameterValue_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& ParameterValue_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& ParameterValue_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string ParameterValue_lib::
    name_ ("ParameterValue_lib");

    const ::std::string ParameterValue_lib::
    namespace__ ("");

    ParameterValue_lib::
    ~ParameterValue_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< ParameterValue_lib, char, ::xml_schema::type >
    _xsd_ParameterValue_lib_parser_init (ParameterValue_lib::name (), ParameterValue_lib::namespace_ ());

    // PhaseComposition_lib
    // 

    const ::xml_schema::type* PhaseComposition_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* PhaseComposition_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    PhaseComposition_lib::
    PhaseComposition_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    PhaseComposition_lib::
    PhaseComposition_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    PhaseComposition_lib::
    PhaseComposition_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    PhaseComposition_lib::
    PhaseComposition_lib (const PhaseComposition_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    PhaseComposition_lib* PhaseComposition_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class PhaseComposition_lib (*this, f);
    }

    const ::std::string& PhaseComposition_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& PhaseComposition_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& PhaseComposition_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& PhaseComposition_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string PhaseComposition_lib::
    name_ ("PhaseComposition_lib");

    const ::std::string PhaseComposition_lib::
    namespace__ ("");

    PhaseComposition_lib::
    ~PhaseComposition_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< PhaseComposition_lib, char, ::xml_schema::type >
    _xsd_PhaseComposition_lib_parser_init (PhaseComposition_lib::name (), PhaseComposition_lib::namespace_ ());

    // ProcessingDetails_lib
    // 

    const ::xml_schema::type* ProcessingDetails_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* ProcessingDetails_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    ProcessingDetails_lib::
    ProcessingDetails_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    ProcessingDetails_lib::
    ProcessingDetails_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    ProcessingDetails_lib::
    ProcessingDetails_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    ProcessingDetails_lib::
    ProcessingDetails_lib (const ProcessingDetails_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    ProcessingDetails_lib* ProcessingDetails_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class ProcessingDetails_lib (*this, f);
    }

    const ::std::string& ProcessingDetails_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& ProcessingDetails_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& ProcessingDetails_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& ProcessingDetails_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string ProcessingDetails_lib::
    name_ ("ProcessingDetails_lib");

    const ::std::string ProcessingDetails_lib::
    namespace__ ("");

    ProcessingDetails_lib::
    ~ProcessingDetails_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< ProcessingDetails_lib, char, ::xml_schema::type >
    _xsd_ProcessingDetails_lib_parser_init (ProcessingDetails_lib::name (), ProcessingDetails_lib::namespace_ ());

    // PropertyData_lib
    // 

    const ::xml_schema::type* PropertyData_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* PropertyData_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    PropertyData_lib::
    PropertyData_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    PropertyData_lib::
    PropertyData_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    PropertyData_lib::
    PropertyData_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    PropertyData_lib::
    PropertyData_lib (const PropertyData_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    PropertyData_lib* PropertyData_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class PropertyData_lib (*this, f);
    }

    const ::std::string& PropertyData_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& PropertyData_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& PropertyData_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& PropertyData_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string PropertyData_lib::
    name_ ("PropertyData_lib");

    const ::std::string PropertyData_lib::
    namespace__ ("");

    PropertyData_lib::
    ~PropertyData_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< PropertyData_lib, char, ::xml_schema::type >
    _xsd_PropertyData_lib_parser_init (PropertyData_lib::name (), PropertyData_lib::namespace_ ());

    // PropertyDetails_lib
    // 

    const ::xml_schema::type* PropertyDetails_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* PropertyDetails_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    PropertyDetails_lib::
    PropertyDetails_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    PropertyDetails_lib::
    PropertyDetails_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    PropertyDetails_lib::
    PropertyDetails_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    PropertyDetails_lib::
    PropertyDetails_lib (const PropertyDetails_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    PropertyDetails_lib* PropertyDetails_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class PropertyDetails_lib (*this, f);
    }

    const ::std::string& PropertyDetails_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& PropertyDetails_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& PropertyDetails_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& PropertyDetails_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string PropertyDetails_lib::
    name_ ("PropertyDetails_lib");

    const ::std::string PropertyDetails_lib::
    namespace__ ("");

    PropertyDetails_lib::
    ~PropertyDetails_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< PropertyDetails_lib, char, ::xml_schema::type >
    _xsd_PropertyDetails_lib_parser_init (PropertyDetails_lib::name (), PropertyDetails_lib::namespace_ ());

    // Qualifier_lib
    // 

    const ::xml_schema::type* Qualifier_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Qualifier_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Qualifier_lib::
    Qualifier_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Qualifier_lib::
    Qualifier_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Qualifier_lib::
    Qualifier_lib (const Qualifier_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Qualifier_lib* Qualifier_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Qualifier_lib (*this, f);
    }

    const ::std::string& Qualifier_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Qualifier_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Qualifier_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Qualifier_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Qualifier_lib::
    name_ ("Qualifier_lib");

    const ::std::string Qualifier_lib::
    namespace__ ("");

    Qualifier_lib::
    ~Qualifier_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Qualifier_lib, char, ::xml_schema::type >
    _xsd_Qualifier_lib_parser_init (Qualifier_lib::name (), Qualifier_lib::namespace_ ());

    // Relationship_lib
    // 

    const ::xml_schema::type* Relationship_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Relationship_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Relationship_lib::
    Relationship_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Relationship_lib::
    Relationship_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Relationship_lib::
    Relationship_lib (const Relationship_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Relationship_lib* Relationship_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Relationship_lib (*this, f);
    }

    const ::std::string& Relationship_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Relationship_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Relationship_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Relationship_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Relationship_lib::
    name_ ("Relationship_lib");

    const ::std::string Relationship_lib::
    namespace__ ("");

    Relationship_lib::
    ~Relationship_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Relationship_lib, char, ::xml_schema::type >
    _xsd_Relationship_lib_parser_init (Relationship_lib::name (), Relationship_lib::namespace_ ());

    // Source_lib
    // 

    const ::xml_schema::type* Source_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Source_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Source_lib::
    Source_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Source_lib::
    Source_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    Source_lib::
    Source_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Source_lib::
    Source_lib (const Source_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Source_lib* Source_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Source_lib (*this, f);
    }

    const ::std::string& Source_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Source_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Source_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Source_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Source_lib::
    name_ ("Source_lib");

    const ::std::string Source_lib::
    namespace__ ("");

    Source_lib::
    ~Source_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Source_lib, char, ::xml_schema::type >
    _xsd_Source_lib_parser_init (Source_lib::name (), Source_lib::namespace_ ());

    // SourceDetails_lib
    // 

    const ::xml_schema::type* SourceDetails_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* SourceDetails_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    SourceDetails_lib::
    SourceDetails_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    SourceDetails_lib::
    SourceDetails_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    SourceDetails_lib::
    SourceDetails_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    SourceDetails_lib::
    SourceDetails_lib (const SourceDetails_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    SourceDetails_lib* SourceDetails_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class SourceDetails_lib (*this, f);
    }

    const ::std::string& SourceDetails_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& SourceDetails_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& SourceDetails_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& SourceDetails_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string SourceDetails_lib::
    name_ ("SourceDetails_lib");

    const ::std::string SourceDetails_lib::
    namespace__ ("");

    SourceDetails_lib::
    ~SourceDetails_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< SourceDetails_lib, char, ::xml_schema::type >
    _xsd_SourceDetails_lib_parser_init (SourceDetails_lib::name (), SourceDetails_lib::namespace_ ());

    // Specification_lib
    // 

    const ::xml_schema::type* Specification_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Specification_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Specification_lib::
    Specification_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Specification_lib::
    Specification_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    Specification_lib::
    Specification_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Specification_lib::
    Specification_lib (const Specification_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Specification_lib* Specification_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Specification_lib (*this, f);
    }

    const ::std::string& Specification_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Specification_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Specification_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Specification_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Specification_lib::
    name_ ("Specification_lib");

    const ::std::string Specification_lib::
    namespace__ ("");

    Specification_lib::
    ~Specification_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Specification_lib, char, ::xml_schema::type >
    _xsd_Specification_lib_parser_init (Specification_lib::name (), Specification_lib::namespace_ ());

    // SpecimenDetails_lib
    // 

    const ::xml_schema::type* SpecimenDetails_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* SpecimenDetails_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    SpecimenDetails_lib::
    SpecimenDetails_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    SpecimenDetails_lib::
    SpecimenDetails_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    SpecimenDetails_lib::
    SpecimenDetails_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    SpecimenDetails_lib::
    SpecimenDetails_lib (const SpecimenDetails_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    SpecimenDetails_lib* SpecimenDetails_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class SpecimenDetails_lib (*this, f);
    }

    const ::std::string& SpecimenDetails_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& SpecimenDetails_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& SpecimenDetails_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& SpecimenDetails_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string SpecimenDetails_lib::
    name_ ("SpecimenDetails_lib");

    const ::std::string SpecimenDetails_lib::
    namespace__ ("");

    SpecimenDetails_lib::
    ~SpecimenDetails_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< SpecimenDetails_lib, char, ::xml_schema::type >
    _xsd_SpecimenDetails_lib_parser_init (SpecimenDetails_lib::name (), SpecimenDetails_lib::namespace_ ());

    // TestConditionDetails_lib
    // 

    const ::xml_schema::type* TestConditionDetails_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* TestConditionDetails_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    TestConditionDetails_lib::
    TestConditionDetails_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    TestConditionDetails_lib::
    TestConditionDetails_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    TestConditionDetails_lib::
    TestConditionDetails_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    TestConditionDetails_lib::
    TestConditionDetails_lib (const TestConditionDetails_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    TestConditionDetails_lib* TestConditionDetails_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class TestConditionDetails_lib (*this, f);
    }

    const ::std::string& TestConditionDetails_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& TestConditionDetails_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& TestConditionDetails_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& TestConditionDetails_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string TestConditionDetails_lib::
    name_ ("TestConditionDetails_lib");

    const ::std::string TestConditionDetails_lib::
    namespace__ ("");

    TestConditionDetails_lib::
    ~TestConditionDetails_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< TestConditionDetails_lib, char, ::xml_schema::type >
    _xsd_TestConditionDetails_lib_parser_init (TestConditionDetails_lib::name (), TestConditionDetails_lib::namespace_ ());

    // Uncertainty_lib
    // 

    const ::xml_schema::type* Uncertainty_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Uncertainty_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Uncertainty_lib::
    Uncertainty_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Uncertainty_lib::
    Uncertainty_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    Uncertainty_lib::
    Uncertainty_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Uncertainty_lib::
    Uncertainty_lib (const Uncertainty_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Uncertainty_lib* Uncertainty_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Uncertainty_lib (*this, f);
    }

    const ::std::string& Uncertainty_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Uncertainty_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Uncertainty_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Uncertainty_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Uncertainty_lib::
    name_ ("Uncertainty_lib");

    const ::std::string Uncertainty_lib::
    namespace__ ("");

    Uncertainty_lib::
    ~Uncertainty_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Uncertainty_lib, char, ::xml_schema::type >
    _xsd_Uncertainty_lib_parser_init (Uncertainty_lib::name (), Uncertainty_lib::namespace_ ());

    // Unit_lib
    // 

    const ::xml_schema::type* Unit_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Unit_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Unit_lib::
    Unit_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Unit_lib::
    Unit_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    Unit_lib::
    Unit_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Unit_lib::
    Unit_lib (const Unit_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Unit_lib* Unit_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Unit_lib (*this, f);
    }

    const ::std::string& Unit_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Unit_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Unit_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Unit_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Unit_lib::
    name_ ("Unit_lib");

    const ::std::string Unit_lib::
    namespace__ ("");

    Unit_lib::
    ~Unit_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Unit_lib, char, ::xml_schema::type >
    _xsd_Unit_lib_parser_init (Unit_lib::name (), Unit_lib::namespace_ ());

    // Unitless_lib
    // 

    const ::xml_schema::type* Unitless_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Unitless_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Unitless_lib::
    Unitless_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Unitless_lib::
    Unitless_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Unitless_lib::
    Unitless_lib (const Unitless_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Unitless_lib* Unitless_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Unitless_lib (*this, f);
    }

    const ::std::string& Unitless_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Unitless_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Unitless_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Unitless_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Unitless_lib::
    name_ ("Unitless_lib");

    const ::std::string Unitless_lib::
    namespace__ ("");

    Unitless_lib::
    ~Unitless_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Unitless_lib, char, ::xml_schema::type >
    _xsd_Unitless_lib_parser_init (Unitless_lib::name (), Unitless_lib::namespace_ ());

    // Units_lib
    // 

    const ::xml_schema::type* Units_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Units_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Units_lib::
    Units_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Units_lib::
    Units_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    Units_lib::
    Units_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Units_lib::
    Units_lib (const Units_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Units_lib* Units_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Units_lib (*this, f);
    }

    const ::std::string& Units_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Units_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Units_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Units_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Units_lib::
    name_ ("Units_lib");

    const ::std::string Units_lib::
    namespace__ ("");

    Units_lib::
    ~Units_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Units_lib, char, ::xml_schema::type >
    _xsd_Units_lib_parser_init (Units_lib::name (), Units_lib::namespace_ ());

    // Value_lib
    // 

    const ::xml_schema::type* Value_lib::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::type* Value_lib::
    _value ()
    {
      return &this->value_.get ();
    }

    Value_lib::
    Value_lib (const value_type& x)
    : value_ (x, 0)
    {
    }

    Value_lib::
    Value_lib (::std::unique_ptr< value_type > p)
    : value_ (p, 0)
    {
    }

    Value_lib::
    Value_lib (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    : value_ (0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (value_traits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Value_lib::
    Value_lib (const Value_lib& x, ::xml_schema::flags f)
    : ::xml_schema::element_type (),
      value_ (x.value_, f, 0)
    {
    }

    Value_lib* Value_lib::
    _clone (::xml_schema::flags f) const
    {
      return new class Value_lib (*this, f);
    }

    const ::std::string& Value_lib::
    name ()
    {
      return name_;
    }

    const ::std::string& Value_lib::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Value_lib::
    _name () const
    {
      return name_;
    }

    const ::std::string& Value_lib::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Value_lib::
    name_ ("Value_lib");

    const ::std::string Value_lib::
    namespace__ ("");

    Value_lib::
    ~Value_lib ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Value_lib, char, ::xml_schema::type >
    _xsd_Value_lib_parser_init (Value_lib::name (), Value_lib::namespace_ ());

    // ParentMaterial
    //

    ParentMaterial::
    ParentMaterial (const id_type& id)
    : ::xml_schema::type (),
      id_ (id, this)
    {
    }

    ParentMaterial::
    ParentMaterial (const ParentMaterial& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this)
    {
    }

    ParentMaterial::
    ParentMaterial (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ParentMaterial::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    ParentMaterial* ParentMaterial::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ParentMaterial (*this, f, c);
    }

    ParentMaterial& ParentMaterial::
    operator= (const ParentMaterial& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
      }

      return *this;
    }

    ParentMaterial::
    ~ParentMaterial ()
    {
    }

    // Symbol
    //

    const Symbol::subscript_type Symbol::subscript_default_value_ (
      "1");

    Symbol::
    Symbol (::bellshire::lib::ChemicalElementSymbol::value _xsd_ChemicalElementSymbol_base)
    : ::bellshire::lib::ChemicalElementSymbol (_xsd_ChemicalElementSymbol_base),
      subscript_ (subscript_default_value (), this)
    {
    }

    Symbol::
    Symbol (const char* _xsd_string_base)
    : ::bellshire::lib::ChemicalElementSymbol (_xsd_string_base),
      subscript_ (subscript_default_value (), this)
    {
    }

    Symbol::
    Symbol (const ::std::string& _xsd_string_base)
    : ::bellshire::lib::ChemicalElementSymbol (_xsd_string_base),
      subscript_ (subscript_default_value (), this)
    {
    }

    Symbol::
    Symbol (const ::bellshire::lib::ChemicalElementSymbol& _xsd_ChemicalElementSymbol_base)
    : ::bellshire::lib::ChemicalElementSymbol (_xsd_ChemicalElementSymbol_base),
      subscript_ (subscript_default_value (), this)
    {
    }

    Symbol::
    Symbol (const Symbol& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::bellshire::lib::ChemicalElementSymbol (x, f, c),
      subscript_ (x.subscript_, f, this)
    {
    }

    Symbol::
    Symbol (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::bellshire::lib::ChemicalElementSymbol (e, f | ::xml_schema::flags::base, c),
      subscript_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Symbol::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "subscript" && n.namespace_ ().empty ())
        {
          this->subscript_.set (subscript_traits::create (i, f, this));
          continue;
        }
      }

      if (!subscript_.present ())
      {
        this->subscript_.set (subscript_default_value ());
      }
    }

    Symbol* Symbol::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Symbol (*this, f, c);
    }

    Symbol& Symbol::
    operator= (const Symbol& x)
    {
      if (this != &x)
      {
        static_cast< ::bellshire::lib::ChemicalElementSymbol& > (*this) = x;
        this->subscript_ = x.subscript_;
      }

      return *this;
    }

    Symbol::
    ~Symbol ()
    {
    }

    // Graph
    //

    Graph::
    Graph ()
    : ::xml_schema::type ()
    {
    }

    Graph::
    Graph (const Graph& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    Graph::
    Graph (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Graph::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        break;
      }
    }

    Graph* Graph::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Graph (*this, f, c);
    }

    Graph::
    ~Graph ()
    {
    }

    // Data
    //

    Data::
    Data ()
    : ::xml_schema::string (),
      format_ (this)
    {
    }

    Data::
    Data (const char* _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base),
      format_ (this)
    {
    }

    Data::
    Data (const ::std::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base),
      format_ (this)
    {
    }

    Data::
    Data (const ::xml_schema::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base),
      format_ (this)
    {
    }

    Data::
    Data (const Data& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c),
      format_ (x.format_, f, this)
    {
    }

    Data::
    Data (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
      format_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Data::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "format" && n.namespace_ ().empty ())
        {
          this->format_.set (format_traits::create (i, f, this));
          continue;
        }
      }
    }

    Data* Data::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Data (*this, f, c);
    }

    Data& Data::
    operator= (const Data& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::string& > (*this) = x;
        this->format_ = x.format_;
      }

      return *this;
    }

    Data::
    ~Data ()
    {
    }

    // Data1
    //

    Data1::
    Data1 (const format_type& format)
    : ::xml_schema::string (),
      format_ (format, this)
    {
    }

    Data1::
    Data1 (const char* _xsd_string_base,
           const format_type& format)
    : ::xml_schema::string (_xsd_string_base),
      format_ (format, this)
    {
    }

    Data1::
    Data1 (const ::std::string& _xsd_string_base,
           const format_type& format)
    : ::xml_schema::string (_xsd_string_base),
      format_ (format, this)
    {
    }

    Data1::
    Data1 (const ::xml_schema::string& _xsd_string_base,
           const format_type& format)
    : ::xml_schema::string (_xsd_string_base),
      format_ (format, this)
    {
    }

    Data1::
    Data1 (const Data1& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c),
      format_ (x.format_, f, this)
    {
    }

    Data1::
    Data1 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
      format_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Data1::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "format" && n.namespace_ ().empty ())
        {
          this->format_.set (format_traits::create (i, f, this));
          continue;
        }
      }

      if (!format_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "format",
          "");
      }
    }

    Data1* Data1::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Data1 (*this, f, c);
    }

    Data1& Data1::
    operator= (const Data1& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::string& > (*this) = x;
        this->format_ = x.format_;
      }

      return *this;
    }

    Data1::
    ~Data1 ()
    {
    }

    // delimiter
    //

    delimiter::
    delimiter ()
    : ::xml_schema::string ()
    {
    }

    delimiter::
    delimiter (const char* _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    delimiter::
    delimiter (const ::std::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    delimiter::
    delimiter (const ::xml_schema::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    delimiter::
    delimiter (const delimiter& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    delimiter::
    delimiter (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    delimiter::
    delimiter (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    delimiter::
    delimiter (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    delimiter* delimiter::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class delimiter (*this, f, c);
    }

    delimiter::
    ~delimiter ()
    {
    }

    // Scale
    //

    Scale::
    Scale (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_Scale_convert ();
    }

    Scale::
    Scale (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_Scale_convert ();
    }

    Scale::
    Scale (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_Scale_convert ();
    }

    Scale* Scale::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Scale (*this, f, c);
    }

    Scale::value Scale::
    _xsd_Scale_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Scale_literals_);
      const value* i (::std::lower_bound (
                        _xsd_Scale_indexes_,
                        _xsd_Scale_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_Scale_indexes_ + 2 || _xsd_Scale_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const Scale::
    _xsd_Scale_literals_[2] =
    {
      "Linear",
      "Logarithmic"
    };

    const Scale::value Scale::
    _xsd_Scale_indexes_[2] =
    {
      ::bellshire::lib::Scale::Linear,
      ::bellshire::lib::Scale::Logarithmic
    };
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

