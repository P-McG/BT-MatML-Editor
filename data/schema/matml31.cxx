// Copyright (c) 2005-2022 Code Synthesis Tools CC.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "matml31.hxx"

// Associate
// 


// AssociationDetails
// 

const AssociationDetails::Associate_optional& AssociationDetails::
Associate () const
{
  return this->Associate_;
}

AssociationDetails::Associate_optional& AssociationDetails::
Associate ()
{
  return this->Associate_;
}

void AssociationDetails::
Associate (const Associate_type& x)
{
  this->Associate_.set (x);
}

void AssociationDetails::
Associate (const Associate_optional& x)
{
  this->Associate_ = x;
}

void AssociationDetails::
Associate (::std::unique_ptr< Associate_type > x)
{
  this->Associate_.set (std::move (x));
}

const AssociationDetails::Relationship_optional& AssociationDetails::
Relationship () const
{
  return this->Relationship_;
}

AssociationDetails::Relationship_optional& AssociationDetails::
Relationship ()
{
  return this->Relationship_;
}

void AssociationDetails::
Relationship (const Relationship_type& x)
{
  this->Relationship_.set (x);
}

void AssociationDetails::
Relationship (const Relationship_optional& x)
{
  this->Relationship_ = x;
}

void AssociationDetails::
Relationship (::std::unique_ptr< Relationship_type > x)
{
  this->Relationship_.set (std::move (x));
}

const AssociationDetails::Notes_optional& AssociationDetails::
Notes () const
{
  return this->Notes_;
}

AssociationDetails::Notes_optional& AssociationDetails::
Notes ()
{
  return this->Notes_;
}

void AssociationDetails::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void AssociationDetails::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void AssociationDetails::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}


// BulkDetails
// 

const BulkDetails::Name_type& BulkDetails::
Name () const
{
  return this->Name_.get ();
}

BulkDetails::Name_type& BulkDetails::
Name ()
{
  return this->Name_.get ();
}

void BulkDetails::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void BulkDetails::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const BulkDetails::Class_sequence& BulkDetails::
Class () const
{
  return this->Class_;
}

BulkDetails::Class_sequence& BulkDetails::
Class ()
{
  return this->Class_;
}

void BulkDetails::
Class (const Class_sequence& s)
{
  this->Class_ = s;
}

const BulkDetails::Subclass_sequence& BulkDetails::
Subclass () const
{
  return this->Subclass_;
}

BulkDetails::Subclass_sequence& BulkDetails::
Subclass ()
{
  return this->Subclass_;
}

void BulkDetails::
Subclass (const Subclass_sequence& s)
{
  this->Subclass_ = s;
}

const BulkDetails::Specification_sequence& BulkDetails::
Specification () const
{
  return this->Specification_;
}

BulkDetails::Specification_sequence& BulkDetails::
Specification ()
{
  return this->Specification_;
}

void BulkDetails::
Specification (const Specification_sequence& s)
{
  this->Specification_ = s;
}

const BulkDetails::Source_optional& BulkDetails::
Source () const
{
  return this->Source_;
}

BulkDetails::Source_optional& BulkDetails::
Source ()
{
  return this->Source_;
}

void BulkDetails::
Source (const Source_type& x)
{
  this->Source_.set (x);
}

void BulkDetails::
Source (const Source_optional& x)
{
  this->Source_ = x;
}

void BulkDetails::
Source (::std::unique_ptr< Source_type > x)
{
  this->Source_.set (std::move (x));
}

const BulkDetails::Form_optional& BulkDetails::
Form () const
{
  return this->Form_;
}

BulkDetails::Form_optional& BulkDetails::
Form ()
{
  return this->Form_;
}

void BulkDetails::
Form (const Form_type& x)
{
  this->Form_.set (x);
}

void BulkDetails::
Form (const Form_optional& x)
{
  this->Form_ = x;
}

void BulkDetails::
Form (::std::unique_ptr< Form_type > x)
{
  this->Form_.set (std::move (x));
}

const BulkDetails::ProcessingDetails_sequence& BulkDetails::
ProcessingDetails () const
{
  return this->ProcessingDetails_;
}

BulkDetails::ProcessingDetails_sequence& BulkDetails::
ProcessingDetails ()
{
  return this->ProcessingDetails_;
}

void BulkDetails::
ProcessingDetails (const ProcessingDetails_sequence& s)
{
  this->ProcessingDetails_ = s;
}

const BulkDetails::Characterization_optional& BulkDetails::
Characterization () const
{
  return this->Characterization_;
}

BulkDetails::Characterization_optional& BulkDetails::
Characterization ()
{
  return this->Characterization_;
}

void BulkDetails::
Characterization (const Characterization_type& x)
{
  this->Characterization_.set (x);
}

void BulkDetails::
Characterization (const Characterization_optional& x)
{
  this->Characterization_ = x;
}

void BulkDetails::
Characterization (::std::unique_ptr< Characterization_type > x)
{
  this->Characterization_.set (std::move (x));
}

const BulkDetails::PropertyData_sequence& BulkDetails::
PropertyData () const
{
  return this->PropertyData_;
}

BulkDetails::PropertyData_sequence& BulkDetails::
PropertyData ()
{
  return this->PropertyData_;
}

void BulkDetails::
PropertyData (const PropertyData_sequence& s)
{
  this->PropertyData_ = s;
}

const BulkDetails::Notes_optional& BulkDetails::
Notes () const
{
  return this->Notes_;
}

BulkDetails::Notes_optional& BulkDetails::
Notes ()
{
  return this->Notes_;
}

void BulkDetails::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void BulkDetails::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void BulkDetails::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}


// Characterization
// 

const Characterization::Formula_type& Characterization::
Formula () const
{
  return this->Formula_.get ();
}

Characterization::Formula_type& Characterization::
Formula ()
{
  return this->Formula_.get ();
}

void Characterization::
Formula (const Formula_type& x)
{
  this->Formula_.set (x);
}

void Characterization::
Formula (::std::unique_ptr< Formula_type > x)
{
  this->Formula_.set (std::move (x));
}

const Characterization::ChemicalComposition_optional& Characterization::
ChemicalComposition () const
{
  return this->ChemicalComposition_;
}

Characterization::ChemicalComposition_optional& Characterization::
ChemicalComposition ()
{
  return this->ChemicalComposition_;
}

void Characterization::
ChemicalComposition (const ChemicalComposition_type& x)
{
  this->ChemicalComposition_.set (x);
}

void Characterization::
ChemicalComposition (const ChemicalComposition_optional& x)
{
  this->ChemicalComposition_ = x;
}

void Characterization::
ChemicalComposition (::std::unique_ptr< ChemicalComposition_type > x)
{
  this->ChemicalComposition_.set (std::move (x));
}

const Characterization::PhaseComposition_sequence& Characterization::
PhaseComposition () const
{
  return this->PhaseComposition_;
}

Characterization::PhaseComposition_sequence& Characterization::
PhaseComposition ()
{
  return this->PhaseComposition_;
}

void Characterization::
PhaseComposition (const PhaseComposition_sequence& s)
{
  this->PhaseComposition_ = s;
}

const Characterization::DimensionalDetails_sequence& Characterization::
DimensionalDetails () const
{
  return this->DimensionalDetails_;
}

Characterization::DimensionalDetails_sequence& Characterization::
DimensionalDetails ()
{
  return this->DimensionalDetails_;
}

void Characterization::
DimensionalDetails (const DimensionalDetails_sequence& s)
{
  this->DimensionalDetails_ = s;
}

const Characterization::Notes_optional& Characterization::
Notes () const
{
  return this->Notes_;
}

Characterization::Notes_optional& Characterization::
Notes ()
{
  return this->Notes_;
}

void Characterization::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void Characterization::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void Characterization::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}


// ChemicalComposition
// 

const ChemicalComposition::Compound_sequence& ChemicalComposition::
Compound () const
{
  return this->Compound_;
}

ChemicalComposition::Compound_sequence& ChemicalComposition::
Compound ()
{
  return this->Compound_;
}

void ChemicalComposition::
Compound (const Compound_sequence& s)
{
  this->Compound_ = s;
}

const ChemicalComposition::Element_sequence& ChemicalComposition::
Element () const
{
  return this->Element_;
}

ChemicalComposition::Element_sequence& ChemicalComposition::
Element ()
{
  return this->Element_;
}

void ChemicalComposition::
Element (const Element_sequence& s)
{
  this->Element_ = s;
}


// Class
// 

const Class::Name_optional& Class::
Name () const
{
  return this->Name_;
}

Class::Name_optional& Class::
Name ()
{
  return this->Name_;
}

void Class::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void Class::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void Class::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const Class::ParentMaterial_sequence& Class::
ParentMaterial () const
{
  return this->ParentMaterial_;
}

Class::ParentMaterial_sequence& Class::
ParentMaterial ()
{
  return this->ParentMaterial_;
}

void Class::
ParentMaterial (const ParentMaterial_sequence& s)
{
  this->ParentMaterial_ = s;
}

const Class::ParentSubClass_sequence& Class::
ParentSubClass () const
{
  return this->ParentSubClass_;
}

Class::ParentSubClass_sequence& Class::
ParentSubClass ()
{
  return this->ParentSubClass_;
}

void Class::
ParentSubClass (const ParentSubClass_sequence& s)
{
  this->ParentSubClass_ = s;
}


// ComponentDetails
// 

const ComponentDetails::Name_type& ComponentDetails::
Name () const
{
  return this->Name_.get ();
}

ComponentDetails::Name_type& ComponentDetails::
Name ()
{
  return this->Name_.get ();
}

void ComponentDetails::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void ComponentDetails::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const ComponentDetails::Class_sequence& ComponentDetails::
Class () const
{
  return this->Class_;
}

ComponentDetails::Class_sequence& ComponentDetails::
Class ()
{
  return this->Class_;
}

void ComponentDetails::
Class (const Class_sequence& s)
{
  this->Class_ = s;
}

const ComponentDetails::Subclass_sequence& ComponentDetails::
Subclass () const
{
  return this->Subclass_;
}

ComponentDetails::Subclass_sequence& ComponentDetails::
Subclass ()
{
  return this->Subclass_;
}

void ComponentDetails::
Subclass (const Subclass_sequence& s)
{
  this->Subclass_ = s;
}

const ComponentDetails::Specification_sequence& ComponentDetails::
Specification () const
{
  return this->Specification_;
}

ComponentDetails::Specification_sequence& ComponentDetails::
Specification ()
{
  return this->Specification_;
}

void ComponentDetails::
Specification (const Specification_sequence& s)
{
  this->Specification_ = s;
}

const ComponentDetails::Source_optional& ComponentDetails::
Source () const
{
  return this->Source_;
}

ComponentDetails::Source_optional& ComponentDetails::
Source ()
{
  return this->Source_;
}

void ComponentDetails::
Source (const Source_type& x)
{
  this->Source_.set (x);
}

void ComponentDetails::
Source (const Source_optional& x)
{
  this->Source_ = x;
}

void ComponentDetails::
Source (::std::unique_ptr< Source_type > x)
{
  this->Source_.set (std::move (x));
}

const ComponentDetails::Form_optional& ComponentDetails::
Form () const
{
  return this->Form_;
}

ComponentDetails::Form_optional& ComponentDetails::
Form ()
{
  return this->Form_;
}

void ComponentDetails::
Form (const Form_type& x)
{
  this->Form_.set (x);
}

void ComponentDetails::
Form (const Form_optional& x)
{
  this->Form_ = x;
}

void ComponentDetails::
Form (::std::unique_ptr< Form_type > x)
{
  this->Form_.set (std::move (x));
}

const ComponentDetails::ProcessingDetails_sequence& ComponentDetails::
ProcessingDetails () const
{
  return this->ProcessingDetails_;
}

ComponentDetails::ProcessingDetails_sequence& ComponentDetails::
ProcessingDetails ()
{
  return this->ProcessingDetails_;
}

void ComponentDetails::
ProcessingDetails (const ProcessingDetails_sequence& s)
{
  this->ProcessingDetails_ = s;
}

const ComponentDetails::Characterization_optional& ComponentDetails::
Characterization () const
{
  return this->Characterization_;
}

ComponentDetails::Characterization_optional& ComponentDetails::
Characterization ()
{
  return this->Characterization_;
}

void ComponentDetails::
Characterization (const Characterization_type& x)
{
  this->Characterization_.set (x);
}

void ComponentDetails::
Characterization (const Characterization_optional& x)
{
  this->Characterization_ = x;
}

void ComponentDetails::
Characterization (::std::unique_ptr< Characterization_type > x)
{
  this->Characterization_.set (std::move (x));
}

const ComponentDetails::PropertyData_sequence& ComponentDetails::
PropertyData () const
{
  return this->PropertyData_;
}

ComponentDetails::PropertyData_sequence& ComponentDetails::
PropertyData ()
{
  return this->PropertyData_;
}

void ComponentDetails::
PropertyData (const PropertyData_sequence& s)
{
  this->PropertyData_ = s;
}

const ComponentDetails::AssociationDetails_sequence& ComponentDetails::
AssociationDetails () const
{
  return this->AssociationDetails_;
}

ComponentDetails::AssociationDetails_sequence& ComponentDetails::
AssociationDetails ()
{
  return this->AssociationDetails_;
}

void ComponentDetails::
AssociationDetails (const AssociationDetails_sequence& s)
{
  this->AssociationDetails_ = s;
}

const ComponentDetails::ComponentDetails1_sequence& ComponentDetails::
ComponentDetails1 () const
{
  return this->ComponentDetails1_;
}

ComponentDetails::ComponentDetails1_sequence& ComponentDetails::
ComponentDetails1 ()
{
  return this->ComponentDetails1_;
}

void ComponentDetails::
ComponentDetails1 (const ComponentDetails1_sequence& s)
{
  this->ComponentDetails1_ = s;
}

const ComponentDetails::id_optional& ComponentDetails::
id () const
{
  return this->id_;
}

ComponentDetails::id_optional& ComponentDetails::
id ()
{
  return this->id_;
}

void ComponentDetails::
id (const id_type& x)
{
  this->id_.set (x);
}

void ComponentDetails::
id (const id_optional& x)
{
  this->id_ = x;
}

void ComponentDetails::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}


// Compound
// 

const Compound::Element_sequence& Compound::
Element () const
{
  return this->Element_;
}

Compound::Element_sequence& Compound::
Element ()
{
  return this->Element_;
}

void Compound::
Element (const Element_sequence& s)
{
  this->Element_ = s;
}

const Compound::Concentration_optional& Compound::
Concentration () const
{
  return this->Concentration_;
}

Compound::Concentration_optional& Compound::
Concentration ()
{
  return this->Concentration_;
}

void Compound::
Concentration (const Concentration_type& x)
{
  this->Concentration_.set (x);
}

void Compound::
Concentration (const Concentration_optional& x)
{
  this->Concentration_ = x;
}

void Compound::
Concentration (::std::unique_ptr< Concentration_type > x)
{
  this->Concentration_.set (std::move (x));
}

const Compound::Notes_optional& Compound::
Notes () const
{
  return this->Notes_;
}

Compound::Notes_optional& Compound::
Notes ()
{
  return this->Notes_;
}

void Compound::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void Compound::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void Compound::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}


// Concentration
// 

const Concentration::Value_type& Concentration::
Value () const
{
  return this->Value_.get ();
}

Concentration::Value_type& Concentration::
Value ()
{
  return this->Value_.get ();
}

void Concentration::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void Concentration::
Value (::std::unique_ptr< Value_type > x)
{
  this->Value_.set (std::move (x));
}

const Concentration::Units_type& Concentration::
Units () const
{
  return this->Units_.get ();
}

Concentration::Units_type& Concentration::
Units ()
{
  return this->Units_.get ();
}

void Concentration::
Units (const Units_type& x)
{
  this->Units_.set (x);
}

void Concentration::
Units (::std::unique_ptr< Units_type > x)
{
  this->Units_.set (std::move (x));
}

const Concentration::Qualifier_sequence& Concentration::
Qualifier () const
{
  return this->Qualifier_;
}

Concentration::Qualifier_sequence& Concentration::
Qualifier ()
{
  return this->Qualifier_;
}

void Concentration::
Qualifier (const Qualifier_sequence& s)
{
  this->Qualifier_ = s;
}

const Concentration::Uncertainty_sequence& Concentration::
Uncertainty () const
{
  return this->Uncertainty_;
}

Concentration::Uncertainty_sequence& Concentration::
Uncertainty ()
{
  return this->Uncertainty_;
}

void Concentration::
Uncertainty (const Uncertainty_sequence& s)
{
  this->Uncertainty_ = s;
}

const Concentration::Notes_optional& Concentration::
Notes () const
{
  return this->Notes_;
}

Concentration::Notes_optional& Concentration::
Notes ()
{
  return this->Notes_;
}

void Concentration::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void Concentration::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void Concentration::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}


// DataFormat
// 

DataFormat::
DataFormat (value v)
: ::xml_schema::string (_xsd_DataFormat_literals_[v])
{
}

DataFormat::
DataFormat (const char* v)
: ::xml_schema::string (v)
{
}

DataFormat::
DataFormat (const ::std::string& v)
: ::xml_schema::string (v)
{
}

DataFormat::
DataFormat (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

DataFormat::
DataFormat (const DataFormat& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

DataFormat& DataFormat::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_DataFormat_literals_[v]);

  return *this;
}


// DimensionalDetails
// 

const DimensionalDetails::Name_type& DimensionalDetails::
Name () const
{
  return this->Name_.get ();
}

DimensionalDetails::Name_type& DimensionalDetails::
Name ()
{
  return this->Name_.get ();
}

void DimensionalDetails::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void DimensionalDetails::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const DimensionalDetails::Value_type& DimensionalDetails::
Value () const
{
  return this->Value_.get ();
}

DimensionalDetails::Value_type& DimensionalDetails::
Value ()
{
  return this->Value_.get ();
}

void DimensionalDetails::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void DimensionalDetails::
Value (::std::unique_ptr< Value_type > x)
{
  this->Value_.set (std::move (x));
}

const DimensionalDetails::Units_type& DimensionalDetails::
Units () const
{
  return this->Units_.get ();
}

DimensionalDetails::Units_type& DimensionalDetails::
Units ()
{
  return this->Units_.get ();
}

void DimensionalDetails::
Units (const Units_type& x)
{
  this->Units_.set (x);
}

void DimensionalDetails::
Units (::std::unique_ptr< Units_type > x)
{
  this->Units_.set (std::move (x));
}

const DimensionalDetails::Qualifier_optional& DimensionalDetails::
Qualifier () const
{
  return this->Qualifier_;
}

DimensionalDetails::Qualifier_optional& DimensionalDetails::
Qualifier ()
{
  return this->Qualifier_;
}

void DimensionalDetails::
Qualifier (const Qualifier_type& x)
{
  this->Qualifier_.set (x);
}

void DimensionalDetails::
Qualifier (const Qualifier_optional& x)
{
  this->Qualifier_ = x;
}

void DimensionalDetails::
Qualifier (::std::unique_ptr< Qualifier_type > x)
{
  this->Qualifier_.set (std::move (x));
}

const DimensionalDetails::Uncertainty_sequence& DimensionalDetails::
Uncertainty () const
{
  return this->Uncertainty_;
}

DimensionalDetails::Uncertainty_sequence& DimensionalDetails::
Uncertainty ()
{
  return this->Uncertainty_;
}

void DimensionalDetails::
Uncertainty (const Uncertainty_sequence& s)
{
  this->Uncertainty_ = s;
}

const DimensionalDetails::Notes_optional& DimensionalDetails::
Notes () const
{
  return this->Notes_;
}

DimensionalDetails::Notes_optional& DimensionalDetails::
Notes ()
{
  return this->Notes_;
}

void DimensionalDetails::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void DimensionalDetails::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void DimensionalDetails::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}


// Element
// 

const Element::Symbol_type& Element::
Symbol () const
{
  return this->Symbol_.get ();
}

Element::Symbol_type& Element::
Symbol ()
{
  return this->Symbol_.get ();
}

void Element::
Symbol (const Symbol_type& x)
{
  this->Symbol_.set (x);
}

void Element::
Symbol (::std::unique_ptr< Symbol_type > x)
{
  this->Symbol_.set (std::move (x));
}

const Element::Concentration_optional& Element::
Concentration () const
{
  return this->Concentration_;
}

Element::Concentration_optional& Element::
Concentration ()
{
  return this->Concentration_;
}

void Element::
Concentration (const Concentration_type& x)
{
  this->Concentration_.set (x);
}

void Element::
Concentration (const Concentration_optional& x)
{
  this->Concentration_ = x;
}

void Element::
Concentration (::std::unique_ptr< Concentration_type > x)
{
  this->Concentration_.set (std::move (x));
}

const Element::Notes_optional& Element::
Notes () const
{
  return this->Notes_;
}

Element::Notes_optional& Element::
Notes ()
{
  return this->Notes_;
}

void Element::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void Element::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void Element::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}


// Form
// 

const Form::Description_type& Form::
Description () const
{
  return this->Description_.get ();
}

Form::Description_type& Form::
Description ()
{
  return this->Description_.get ();
}

void Form::
Description (const Description_type& x)
{
  this->Description_.set (x);
}

void Form::
Description (::std::unique_ptr< Description_type > x)
{
  this->Description_.set (std::move (x));
}

const Form::Geometry_optional& Form::
Geometry () const
{
  return this->Geometry_;
}

Form::Geometry_optional& Form::
Geometry ()
{
  return this->Geometry_;
}

void Form::
Geometry (const Geometry_type& x)
{
  this->Geometry_.set (x);
}

void Form::
Geometry (const Geometry_optional& x)
{
  this->Geometry_ = x;
}

void Form::
Geometry (::std::unique_ptr< Geometry_type > x)
{
  this->Geometry_.set (std::move (x));
}

const Form::Notes_optional& Form::
Notes () const
{
  return this->Notes_;
}

Form::Notes_optional& Form::
Notes ()
{
  return this->Notes_;
}

void Form::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void Form::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void Form::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}


// Formula
// 


// Geometry
// 

const Geometry::Shape_type& Geometry::
Shape () const
{
  return this->Shape_.get ();
}

Geometry::Shape_type& Geometry::
Shape ()
{
  return this->Shape_.get ();
}

void Geometry::
Shape (const Shape_type& x)
{
  this->Shape_.set (x);
}

void Geometry::
Shape (::std::unique_ptr< Shape_type > x)
{
  this->Shape_.set (std::move (x));
}

const Geometry::Dimensions_optional& Geometry::
Dimensions () const
{
  return this->Dimensions_;
}

Geometry::Dimensions_optional& Geometry::
Dimensions ()
{
  return this->Dimensions_;
}

void Geometry::
Dimensions (const Dimensions_type& x)
{
  this->Dimensions_.set (x);
}

void Geometry::
Dimensions (const Dimensions_optional& x)
{
  this->Dimensions_ = x;
}

void Geometry::
Dimensions (::std::unique_ptr< Dimensions_type > x)
{
  this->Dimensions_.set (std::move (x));
}

const Geometry::Orientation_optional& Geometry::
Orientation () const
{
  return this->Orientation_;
}

Geometry::Orientation_optional& Geometry::
Orientation ()
{
  return this->Orientation_;
}

void Geometry::
Orientation (const Orientation_type& x)
{
  this->Orientation_.set (x);
}

void Geometry::
Orientation (const Orientation_optional& x)
{
  this->Orientation_ = x;
}

void Geometry::
Orientation (::std::unique_ptr< Orientation_type > x)
{
  this->Orientation_.set (std::move (x));
}

const Geometry::Notes_optional& Geometry::
Notes () const
{
  return this->Notes_;
}

Geometry::Notes_optional& Geometry::
Notes ()
{
  return this->Notes_;
}

void Geometry::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void Geometry::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void Geometry::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}


// Glossary
// 

const Glossary::Term_sequence& Glossary::
Term () const
{
  return this->Term_;
}

Glossary::Term_sequence& Glossary::
Term ()
{
  return this->Term_;
}

void Glossary::
Term (const Term_sequence& s)
{
  this->Term_ = s;
}


// GlossaryTerm
// 

const GlossaryTerm::Name_type& GlossaryTerm::
Name () const
{
  return this->Name_.get ();
}

GlossaryTerm::Name_type& GlossaryTerm::
Name ()
{
  return this->Name_.get ();
}

void GlossaryTerm::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void GlossaryTerm::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const GlossaryTerm::Definition_type& GlossaryTerm::
Definition () const
{
  return this->Definition_.get ();
}

GlossaryTerm::Definition_type& GlossaryTerm::
Definition ()
{
  return this->Definition_.get ();
}

void GlossaryTerm::
Definition (const Definition_type& x)
{
  this->Definition_.set (x);
}

void GlossaryTerm::
Definition (::std::unique_ptr< Definition_type > x)
{
  this->Definition_.set (std::move (x));
}

const GlossaryTerm::Abbreviation_sequence& GlossaryTerm::
Abbreviation () const
{
  return this->Abbreviation_;
}

GlossaryTerm::Abbreviation_sequence& GlossaryTerm::
Abbreviation ()
{
  return this->Abbreviation_;
}

void GlossaryTerm::
Abbreviation (const Abbreviation_sequence& s)
{
  this->Abbreviation_ = s;
}

const GlossaryTerm::Synonym_sequence& GlossaryTerm::
Synonym () const
{
  return this->Synonym_;
}

GlossaryTerm::Synonym_sequence& GlossaryTerm::
Synonym ()
{
  return this->Synonym_;
}

void GlossaryTerm::
Synonym (const Synonym_sequence& s)
{
  this->Synonym_ = s;
}

const GlossaryTerm::Notes_optional& GlossaryTerm::
Notes () const
{
  return this->Notes_;
}

GlossaryTerm::Notes_optional& GlossaryTerm::
Notes ()
{
  return this->Notes_;
}

void GlossaryTerm::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void GlossaryTerm::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void GlossaryTerm::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}


// Graphs
// 

const Graphs::Graph_sequence& Graphs::
Graph () const
{
  return this->Graph_;
}

Graphs::Graph_sequence& Graphs::
Graph ()
{
  return this->Graph_;
}

void Graphs::
Graph (const Graph_sequence& s)
{
  this->Graph_ = s;
}


// Material
// 

const Material::BulkDetails_type& Material::
BulkDetails () const
{
  return this->BulkDetails_.get ();
}

Material::BulkDetails_type& Material::
BulkDetails ()
{
  return this->BulkDetails_.get ();
}

void Material::
BulkDetails (const BulkDetails_type& x)
{
  this->BulkDetails_.set (x);
}

void Material::
BulkDetails (::std::unique_ptr< BulkDetails_type > x)
{
  this->BulkDetails_.set (std::move (x));
}

const Material::ComponentDetails_sequence& Material::
ComponentDetails () const
{
  return this->ComponentDetails_;
}

Material::ComponentDetails_sequence& Material::
ComponentDetails ()
{
  return this->ComponentDetails_;
}

void Material::
ComponentDetails (const ComponentDetails_sequence& s)
{
  this->ComponentDetails_ = s;
}

const Material::Graphs_optional& Material::
Graphs () const
{
  return this->Graphs_;
}

Material::Graphs_optional& Material::
Graphs ()
{
  return this->Graphs_;
}

void Material::
Graphs (const Graphs_type& x)
{
  this->Graphs_.set (x);
}

void Material::
Graphs (const Graphs_optional& x)
{
  this->Graphs_ = x;
}

void Material::
Graphs (::std::unique_ptr< Graphs_type > x)
{
  this->Graphs_.set (std::move (x));
}

const Material::Glossary_optional& Material::
Glossary () const
{
  return this->Glossary_;
}

Material::Glossary_optional& Material::
Glossary ()
{
  return this->Glossary_;
}

void Material::
Glossary (const Glossary_type& x)
{
  this->Glossary_.set (x);
}

void Material::
Glossary (const Glossary_optional& x)
{
  this->Glossary_ = x;
}

void Material::
Glossary (::std::unique_ptr< Glossary_type > x)
{
  this->Glossary_.set (std::move (x));
}

const Material::id_optional& Material::
id () const
{
  return this->id_;
}

Material::id_optional& Material::
id ()
{
  return this->id_;
}

void Material::
id (const id_type& x)
{
  this->id_.set (x);
}

void Material::
id (const id_optional& x)
{
  this->id_ = x;
}

void Material::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const Material::layers_optional& Material::
layers () const
{
  return this->layers_;
}

Material::layers_optional& Material::
layers ()
{
  return this->layers_;
}

void Material::
layers (const layers_type& x)
{
  this->layers_.set (x);
}

void Material::
layers (const layers_optional& x)
{
  this->layers_ = x;
}

const Material::local_frame_of_reference_optional& Material::
local_frame_of_reference () const
{
  return this->local_frame_of_reference_;
}

Material::local_frame_of_reference_optional& Material::
local_frame_of_reference ()
{
  return this->local_frame_of_reference_;
}

void Material::
local_frame_of_reference (const local_frame_of_reference_type& x)
{
  this->local_frame_of_reference_.set (x);
}

void Material::
local_frame_of_reference (const local_frame_of_reference_optional& x)
{
  this->local_frame_of_reference_ = x;
}

void Material::
local_frame_of_reference (::std::unique_ptr< local_frame_of_reference_type > x)
{
  this->local_frame_of_reference_.set (std::move (x));
}


// Metadata
// 

const Metadata::AuthorityDetails_sequence& Metadata::
AuthorityDetails () const
{
  return this->AuthorityDetails_;
}

Metadata::AuthorityDetails_sequence& Metadata::
AuthorityDetails ()
{
  return this->AuthorityDetails_;
}

void Metadata::
AuthorityDetails (const AuthorityDetails_sequence& s)
{
  this->AuthorityDetails_ = s;
}

const Metadata::DataSourceDetails_sequence& Metadata::
DataSourceDetails () const
{
  return this->DataSourceDetails_;
}

Metadata::DataSourceDetails_sequence& Metadata::
DataSourceDetails ()
{
  return this->DataSourceDetails_;
}

void Metadata::
DataSourceDetails (const DataSourceDetails_sequence& s)
{
  this->DataSourceDetails_ = s;
}

const Metadata::MeasurementTechniqueDetails_sequence& Metadata::
MeasurementTechniqueDetails () const
{
  return this->MeasurementTechniqueDetails_;
}

Metadata::MeasurementTechniqueDetails_sequence& Metadata::
MeasurementTechniqueDetails ()
{
  return this->MeasurementTechniqueDetails_;
}

void Metadata::
MeasurementTechniqueDetails (const MeasurementTechniqueDetails_sequence& s)
{
  this->MeasurementTechniqueDetails_ = s;
}

const Metadata::ParameterDetails_sequence& Metadata::
ParameterDetails () const
{
  return this->ParameterDetails_;
}

Metadata::ParameterDetails_sequence& Metadata::
ParameterDetails ()
{
  return this->ParameterDetails_;
}

void Metadata::
ParameterDetails (const ParameterDetails_sequence& s)
{
  this->ParameterDetails_ = s;
}

const Metadata::PropertyDetails_sequence& Metadata::
PropertyDetails () const
{
  return this->PropertyDetails_;
}

Metadata::PropertyDetails_sequence& Metadata::
PropertyDetails ()
{
  return this->PropertyDetails_;
}

void Metadata::
PropertyDetails (const PropertyDetails_sequence& s)
{
  this->PropertyDetails_ = s;
}

const Metadata::SourceDetails_sequence& Metadata::
SourceDetails () const
{
  return this->SourceDetails_;
}

Metadata::SourceDetails_sequence& Metadata::
SourceDetails ()
{
  return this->SourceDetails_;
}

void Metadata::
SourceDetails (const SourceDetails_sequence& s)
{
  this->SourceDetails_ = s;
}

const Metadata::SpecimenDetails_sequence& Metadata::
SpecimenDetails () const
{
  return this->SpecimenDetails_;
}

Metadata::SpecimenDetails_sequence& Metadata::
SpecimenDetails ()
{
  return this->SpecimenDetails_;
}

void Metadata::
SpecimenDetails (const SpecimenDetails_sequence& s)
{
  this->SpecimenDetails_ = s;
}

const Metadata::TestConditionDetails_sequence& Metadata::
TestConditionDetails () const
{
  return this->TestConditionDetails_;
}

Metadata::TestConditionDetails_sequence& Metadata::
TestConditionDetails ()
{
  return this->TestConditionDetails_;
}

void Metadata::
TestConditionDetails (const TestConditionDetails_sequence& s)
{
  this->TestConditionDetails_ = s;
}


// Name
// 

const Name::authority_optional& Name::
authority () const
{
  return this->authority_;
}

Name::authority_optional& Name::
authority ()
{
  return this->authority_;
}

void Name::
authority (const authority_type& x)
{
  this->authority_.set (x);
}

void Name::
authority (const authority_optional& x)
{
  this->authority_ = x;
}

void Name::
authority (::std::unique_ptr< authority_type > x)
{
  this->authority_.set (std::move (x));
}


// Notes
// 


// ParameterValue
// 

const ParameterValue::Data_type& ParameterValue::
Data () const
{
  return this->Data_.get ();
}

ParameterValue::Data_type& ParameterValue::
Data ()
{
  return this->Data_.get ();
}

void ParameterValue::
Data (const Data_type& x)
{
  this->Data_.set (x);
}

void ParameterValue::
Data (::std::unique_ptr< Data_type > x)
{
  this->Data_.set (std::move (x));
}

const ParameterValue::Uncertainty_sequence& ParameterValue::
Uncertainty () const
{
  return this->Uncertainty_;
}

ParameterValue::Uncertainty_sequence& ParameterValue::
Uncertainty ()
{
  return this->Uncertainty_;
}

void ParameterValue::
Uncertainty (const Uncertainty_sequence& s)
{
  this->Uncertainty_ = s;
}

const ParameterValue::Qualifier_sequence& ParameterValue::
Qualifier () const
{
  return this->Qualifier_;
}

ParameterValue::Qualifier_sequence& ParameterValue::
Qualifier ()
{
  return this->Qualifier_;
}

void ParameterValue::
Qualifier (const Qualifier_sequence& s)
{
  this->Qualifier_ = s;
}

const ParameterValue::Notes_optional& ParameterValue::
Notes () const
{
  return this->Notes_;
}

ParameterValue::Notes_optional& ParameterValue::
Notes ()
{
  return this->Notes_;
}

void ParameterValue::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void ParameterValue::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void ParameterValue::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}

const ParameterValue::parameter_type& ParameterValue::
parameter () const
{
  return this->parameter_.get ();
}

ParameterValue::parameter_type& ParameterValue::
parameter ()
{
  return this->parameter_.get ();
}

void ParameterValue::
parameter (const parameter_type& x)
{
  this->parameter_.set (x);
}

void ParameterValue::
parameter (::std::unique_ptr< parameter_type > x)
{
  this->parameter_.set (std::move (x));
}

const ParameterValue::format_type& ParameterValue::
format () const
{
  return this->format_.get ();
}

ParameterValue::format_type& ParameterValue::
format ()
{
  return this->format_.get ();
}

void ParameterValue::
format (const format_type& x)
{
  this->format_.set (x);
}

void ParameterValue::
format (::std::unique_ptr< format_type > x)
{
  this->format_.set (std::move (x));
}


// PhaseComposition
// 

const PhaseComposition::Name_type& PhaseComposition::
Name () const
{
  return this->Name_.get ();
}

PhaseComposition::Name_type& PhaseComposition::
Name ()
{
  return this->Name_.get ();
}

void PhaseComposition::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void PhaseComposition::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const PhaseComposition::Concentration_optional& PhaseComposition::
Concentration () const
{
  return this->Concentration_;
}

PhaseComposition::Concentration_optional& PhaseComposition::
Concentration ()
{
  return this->Concentration_;
}

void PhaseComposition::
Concentration (const Concentration_type& x)
{
  this->Concentration_.set (x);
}

void PhaseComposition::
Concentration (const Concentration_optional& x)
{
  this->Concentration_ = x;
}

void PhaseComposition::
Concentration (::std::unique_ptr< Concentration_type > x)
{
  this->Concentration_.set (std::move (x));
}

const PhaseComposition::PropertyData_sequence& PhaseComposition::
PropertyData () const
{
  return this->PropertyData_;
}

PhaseComposition::PropertyData_sequence& PhaseComposition::
PropertyData ()
{
  return this->PropertyData_;
}

void PhaseComposition::
PropertyData (const PropertyData_sequence& s)
{
  this->PropertyData_ = s;
}

const PhaseComposition::Notes_optional& PhaseComposition::
Notes () const
{
  return this->Notes_;
}

PhaseComposition::Notes_optional& PhaseComposition::
Notes ()
{
  return this->Notes_;
}

void PhaseComposition::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void PhaseComposition::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void PhaseComposition::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}


// ProcessingDetails
// 

const ProcessingDetails::Name_type& ProcessingDetails::
Name () const
{
  return this->Name_.get ();
}

ProcessingDetails::Name_type& ProcessingDetails::
Name ()
{
  return this->Name_.get ();
}

void ProcessingDetails::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void ProcessingDetails::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const ProcessingDetails::ParameterValue_sequence& ProcessingDetails::
ParameterValue () const
{
  return this->ParameterValue_;
}

ProcessingDetails::ParameterValue_sequence& ProcessingDetails::
ParameterValue ()
{
  return this->ParameterValue_;
}

void ProcessingDetails::
ParameterValue (const ParameterValue_sequence& s)
{
  this->ParameterValue_ = s;
}

const ProcessingDetails::Result_optional& ProcessingDetails::
Result () const
{
  return this->Result_;
}

ProcessingDetails::Result_optional& ProcessingDetails::
Result ()
{
  return this->Result_;
}

void ProcessingDetails::
Result (const Result_type& x)
{
  this->Result_.set (x);
}

void ProcessingDetails::
Result (const Result_optional& x)
{
  this->Result_ = x;
}

void ProcessingDetails::
Result (::std::unique_ptr< Result_type > x)
{
  this->Result_.set (std::move (x));
}

const ProcessingDetails::Notes_optional& ProcessingDetails::
Notes () const
{
  return this->Notes_;
}

ProcessingDetails::Notes_optional& ProcessingDetails::
Notes ()
{
  return this->Notes_;
}

void ProcessingDetails::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void ProcessingDetails::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void ProcessingDetails::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}


// PropertyData
// 

const PropertyData::Data_type& PropertyData::
Data () const
{
  return this->Data_.get ();
}

PropertyData::Data_type& PropertyData::
Data ()
{
  return this->Data_.get ();
}

void PropertyData::
Data (const Data_type& x)
{
  this->Data_.set (x);
}

void PropertyData::
Data (::std::unique_ptr< Data_type > x)
{
  this->Data_.set (std::move (x));
}

const PropertyData::Uncertainty_sequence& PropertyData::
Uncertainty () const
{
  return this->Uncertainty_;
}

PropertyData::Uncertainty_sequence& PropertyData::
Uncertainty ()
{
  return this->Uncertainty_;
}

void PropertyData::
Uncertainty (const Uncertainty_sequence& s)
{
  this->Uncertainty_ = s;
}

const PropertyData::Qualifier_sequence& PropertyData::
Qualifier () const
{
  return this->Qualifier_;
}

PropertyData::Qualifier_sequence& PropertyData::
Qualifier ()
{
  return this->Qualifier_;
}

void PropertyData::
Qualifier (const Qualifier_sequence& s)
{
  this->Qualifier_ = s;
}

const PropertyData::ParameterValue_sequence& PropertyData::
ParameterValue () const
{
  return this->ParameterValue_;
}

PropertyData::ParameterValue_sequence& PropertyData::
ParameterValue ()
{
  return this->ParameterValue_;
}

void PropertyData::
ParameterValue (const ParameterValue_sequence& s)
{
  this->ParameterValue_ = s;
}

const PropertyData::Notes_optional& PropertyData::
Notes () const
{
  return this->Notes_;
}

PropertyData::Notes_optional& PropertyData::
Notes ()
{
  return this->Notes_;
}

void PropertyData::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void PropertyData::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void PropertyData::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}

const PropertyData::property_type& PropertyData::
property () const
{
  return this->property_.get ();
}

PropertyData::property_type& PropertyData::
property ()
{
  return this->property_.get ();
}

void PropertyData::
property (const property_type& x)
{
  this->property_.set (x);
}

void PropertyData::
property (::std::unique_ptr< property_type > x)
{
  this->property_.set (std::move (x));
}

const PropertyData::technique_optional& PropertyData::
technique () const
{
  return this->technique_;
}

PropertyData::technique_optional& PropertyData::
technique ()
{
  return this->technique_;
}

void PropertyData::
technique (const technique_type& x)
{
  this->technique_.set (x);
}

void PropertyData::
technique (const technique_optional& x)
{
  this->technique_ = x;
}

void PropertyData::
technique (::std::unique_ptr< technique_type > x)
{
  this->technique_.set (std::move (x));
}

const PropertyData::source_optional& PropertyData::
source () const
{
  return this->source_;
}

PropertyData::source_optional& PropertyData::
source ()
{
  return this->source_;
}

void PropertyData::
source (const source_type& x)
{
  this->source_.set (x);
}

void PropertyData::
source (const source_optional& x)
{
  this->source_ = x;
}

void PropertyData::
source (::std::unique_ptr< source_type > x)
{
  this->source_.set (std::move (x));
}

const PropertyData::specimen_optional& PropertyData::
specimen () const
{
  return this->specimen_;
}

PropertyData::specimen_optional& PropertyData::
specimen ()
{
  return this->specimen_;
}

void PropertyData::
specimen (const specimen_type& x)
{
  this->specimen_.set (x);
}

void PropertyData::
specimen (const specimen_optional& x)
{
  this->specimen_ = x;
}

void PropertyData::
specimen (::std::unique_ptr< specimen_type > x)
{
  this->specimen_.set (std::move (x));
}

const PropertyData::test_optional& PropertyData::
test () const
{
  return this->test_;
}

PropertyData::test_optional& PropertyData::
test ()
{
  return this->test_;
}

void PropertyData::
test (const test_type& x)
{
  this->test_.set (x);
}

void PropertyData::
test (const test_optional& x)
{
  this->test_ = x;
}

void PropertyData::
test (::std::unique_ptr< test_type > x)
{
  this->test_.set (std::move (x));
}

const PropertyData::delimiter_type& PropertyData::
delimiter () const
{
  return this->delimiter_.get ();
}

PropertyData::delimiter_type& PropertyData::
delimiter ()
{
  return this->delimiter_.get ();
}

void PropertyData::
delimiter (const delimiter_type& x)
{
  this->delimiter_.set (x);
}

void PropertyData::
delimiter (::std::unique_ptr< delimiter_type > x)
{
  this->delimiter_.set (std::move (x));
}

const PropertyData::delimiter_type& PropertyData::
delimiter_default_value ()
{
  return delimiter_default_value_;
}

const PropertyData::quote_optional& PropertyData::
quote () const
{
  return this->quote_;
}

PropertyData::quote_optional& PropertyData::
quote ()
{
  return this->quote_;
}

void PropertyData::
quote (const quote_type& x)
{
  this->quote_.set (x);
}

void PropertyData::
quote (const quote_optional& x)
{
  this->quote_ = x;
}

void PropertyData::
quote (::std::unique_ptr< quote_type > x)
{
  this->quote_.set (std::move (x));
}


// Qualifier
// 


// Relationship
// 


// Source
// 

const Source::source_optional& Source::
source () const
{
  return this->source_;
}

Source::source_optional& Source::
source ()
{
  return this->source_;
}

void Source::
source (const source_type& x)
{
  this->source_.set (x);
}

void Source::
source (const source_optional& x)
{
  this->source_ = x;
}

void Source::
source (::std::unique_ptr< source_type > x)
{
  this->source_.set (std::move (x));
}


// Specification
// 

const Specification::authority_optional& Specification::
authority () const
{
  return this->authority_;
}

Specification::authority_optional& Specification::
authority ()
{
  return this->authority_;
}

void Specification::
authority (const authority_type& x)
{
  this->authority_.set (x);
}

void Specification::
authority (const authority_optional& x)
{
  this->authority_ = x;
}

void Specification::
authority (::std::unique_ptr< authority_type > x)
{
  this->authority_.set (std::move (x));
}


// Uncertainty
// 

const Uncertainty::Value_type& Uncertainty::
Value () const
{
  return this->Value_.get ();
}

Uncertainty::Value_type& Uncertainty::
Value ()
{
  return this->Value_.get ();
}

void Uncertainty::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void Uncertainty::
Value (::std::unique_ptr< Value_type > x)
{
  this->Value_.set (std::move (x));
}

const Uncertainty::Units_optional& Uncertainty::
Units () const
{
  return this->Units_;
}

Uncertainty::Units_optional& Uncertainty::
Units ()
{
  return this->Units_;
}

void Uncertainty::
Units (const Units_type& x)
{
  this->Units_.set (x);
}

void Uncertainty::
Units (const Units_optional& x)
{
  this->Units_ = x;
}

void Uncertainty::
Units (::std::unique_ptr< Units_type > x)
{
  this->Units_.set (std::move (x));
}

const Uncertainty::Unitless_optional& Uncertainty::
Unitless () const
{
  return this->Unitless_;
}

Uncertainty::Unitless_optional& Uncertainty::
Unitless ()
{
  return this->Unitless_;
}

void Uncertainty::
Unitless (const Unitless_type& x)
{
  this->Unitless_.set (x);
}

void Uncertainty::
Unitless (const Unitless_optional& x)
{
  this->Unitless_ = x;
}

void Uncertainty::
Unitless (::std::unique_ptr< Unitless_type > x)
{
  this->Unitless_.set (std::move (x));
}

const Uncertainty::Notes_optional& Uncertainty::
Notes () const
{
  return this->Notes_;
}

Uncertainty::Notes_optional& Uncertainty::
Notes ()
{
  return this->Notes_;
}

void Uncertainty::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void Uncertainty::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void Uncertainty::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}

const Uncertainty::Scale_optional& Uncertainty::
Scale () const
{
  return this->Scale_;
}

Uncertainty::Scale_optional& Uncertainty::
Scale ()
{
  return this->Scale_;
}

void Uncertainty::
Scale (const Scale_type& x)
{
  this->Scale_.set (x);
}

void Uncertainty::
Scale (const Scale_optional& x)
{
  this->Scale_ = x;
}

void Uncertainty::
Scale (::std::unique_ptr< Scale_type > x)
{
  this->Scale_.set (std::move (x));
}

const Uncertainty::Scale_type& Uncertainty::
Scale_default_value ()
{
  return Scale_default_value_;
}

const Uncertainty::DistributionType_type& Uncertainty::
DistributionType () const
{
  return this->DistributionType_.get ();
}

Uncertainty::DistributionType_type& Uncertainty::
DistributionType ()
{
  return this->DistributionType_.get ();
}

void Uncertainty::
DistributionType (const DistributionType_type& x)
{
  this->DistributionType_.set (x);
}

void Uncertainty::
DistributionType (::std::unique_ptr< DistributionType_type > x)
{
  this->DistributionType_.set (std::move (x));
}

const Uncertainty::DistributionType_type& Uncertainty::
DistributionType_default_value ()
{
  return DistributionType_default_value_;
}

const Uncertainty::Num_Std_Dev_type& Uncertainty::
Num_Std_Dev () const
{
  return this->Num_Std_Dev_.get ();
}

Uncertainty::Num_Std_Dev_type& Uncertainty::
Num_Std_Dev ()
{
  return this->Num_Std_Dev_.get ();
}

void Uncertainty::
Num_Std_Dev (const Num_Std_Dev_type& x)
{
  this->Num_Std_Dev_.set (x);
}

Uncertainty::Num_Std_Dev_type Uncertainty::
Num_Std_Dev_default_value ()
{
  return Num_Std_Dev_type (2.0F);
}

const Uncertainty::Percentile_optional& Uncertainty::
Percentile () const
{
  return this->Percentile_;
}

Uncertainty::Percentile_optional& Uncertainty::
Percentile ()
{
  return this->Percentile_;
}

void Uncertainty::
Percentile (const Percentile_type& x)
{
  this->Percentile_.set (x);
}

void Uncertainty::
Percentile (const Percentile_optional& x)
{
  this->Percentile_ = x;
}

const Uncertainty::ConfidenceLevel_optional& Uncertainty::
ConfidenceLevel () const
{
  return this->ConfidenceLevel_;
}

Uncertainty::ConfidenceLevel_optional& Uncertainty::
ConfidenceLevel ()
{
  return this->ConfidenceLevel_;
}

void Uncertainty::
ConfidenceLevel (const ConfidenceLevel_type& x)
{
  this->ConfidenceLevel_.set (x);
}

void Uncertainty::
ConfidenceLevel (const ConfidenceLevel_optional& x)
{
  this->ConfidenceLevel_ = x;
}


// Unit
// 

const Unit::Name_optional& Unit::
Name () const
{
  return this->Name_;
}

Unit::Name_optional& Unit::
Name ()
{
  return this->Name_;
}

void Unit::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void Unit::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void Unit::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const Unit::Currency_optional& Unit::
Currency () const
{
  return this->Currency_;
}

Unit::Currency_optional& Unit::
Currency ()
{
  return this->Currency_;
}

void Unit::
Currency (const Currency_type& x)
{
  this->Currency_.set (x);
}

void Unit::
Currency (const Currency_optional& x)
{
  this->Currency_ = x;
}

void Unit::
Currency (::std::unique_ptr< Currency_type > x)
{
  this->Currency_.set (std::move (x));
}

const Unit::power_optional& Unit::
power () const
{
  return this->power_;
}

Unit::power_optional& Unit::
power ()
{
  return this->power_;
}

void Unit::
power (const power_type& x)
{
  this->power_.set (x);
}

void Unit::
power (const power_optional& x)
{
  this->power_ = x;
}

const Unit::description_optional& Unit::
description () const
{
  return this->description_;
}

Unit::description_optional& Unit::
description ()
{
  return this->description_;
}

void Unit::
description (const description_type& x)
{
  this->description_.set (x);
}

void Unit::
description (const description_optional& x)
{
  this->description_ = x;
}

void Unit::
description (::std::unique_ptr< description_type > x)
{
  this->description_.set (std::move (x));
}


// Unitless
// 


// Units
// 

const Units::Unit_sequence& Units::
Unit () const
{
  return this->Unit_;
}

Units::Unit_sequence& Units::
Unit ()
{
  return this->Unit_;
}

void Units::
Unit (const Unit_sequence& s)
{
  this->Unit_ = s;
}

const Units::system_optional& Units::
system () const
{
  return this->system_;
}

Units::system_optional& Units::
system ()
{
  return this->system_;
}

void Units::
system (const system_type& x)
{
  this->system_.set (x);
}

void Units::
system (const system_optional& x)
{
  this->system_ = x;
}

void Units::
system (::std::unique_ptr< system_type > x)
{
  this->system_.set (std::move (x));
}

const Units::factor_optional& Units::
factor () const
{
  return this->factor_;
}

Units::factor_optional& Units::
factor ()
{
  return this->factor_;
}

void Units::
factor (const factor_type& x)
{
  this->factor_.set (x);
}

void Units::
factor (const factor_optional& x)
{
  this->factor_ = x;
}

const Units::name_optional& Units::
name () const
{
  return this->name_;
}

Units::name_optional& Units::
name ()
{
  return this->name_;
}

void Units::
name (const name_type& x)
{
  this->name_.set (x);
}

void Units::
name (const name_optional& x)
{
  this->name_ = x;
}

void Units::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const Units::description_optional& Units::
description () const
{
  return this->description_;
}

Units::description_optional& Units::
description ()
{
  return this->description_;
}

void Units::
description (const description_type& x)
{
  this->description_.set (x);
}

void Units::
description (const description_optional& x)
{
  this->description_ = x;
}

void Units::
description (::std::unique_ptr< description_type > x)
{
  this->description_.set (std::move (x));
}


// Value
// 

const Value::format_type& Value::
format () const
{
  return this->format_.get ();
}

Value::format_type& Value::
format ()
{
  return this->format_.get ();
}

void Value::
format (const format_type& x)
{
  this->format_.set (x);
}

void Value::
format (::std::unique_ptr< format_type > x)
{
  this->format_.set (std::move (x));
}


// AuthorityDetails
// 

const AuthorityDetails::Name_type& AuthorityDetails::
Name () const
{
  return this->Name_.get ();
}

AuthorityDetails::Name_type& AuthorityDetails::
Name ()
{
  return this->Name_.get ();
}

void AuthorityDetails::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void AuthorityDetails::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const AuthorityDetails::Notes_optional& AuthorityDetails::
Notes () const
{
  return this->Notes_;
}

AuthorityDetails::Notes_optional& AuthorityDetails::
Notes ()
{
  return this->Notes_;
}

void AuthorityDetails::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void AuthorityDetails::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void AuthorityDetails::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}

const AuthorityDetails::id_type& AuthorityDetails::
id () const
{
  return this->id_.get ();
}

AuthorityDetails::id_type& AuthorityDetails::
id ()
{
  return this->id_.get ();
}

void AuthorityDetails::
id (const id_type& x)
{
  this->id_.set (x);
}

void AuthorityDetails::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}


// DataSourceDetails
// 

const DataSourceDetails::Name_type& DataSourceDetails::
Name () const
{
  return this->Name_.get ();
}

DataSourceDetails::Name_type& DataSourceDetails::
Name ()
{
  return this->Name_.get ();
}

void DataSourceDetails::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void DataSourceDetails::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const DataSourceDetails::Notes_optional& DataSourceDetails::
Notes () const
{
  return this->Notes_;
}

DataSourceDetails::Notes_optional& DataSourceDetails::
Notes ()
{
  return this->Notes_;
}

void DataSourceDetails::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void DataSourceDetails::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void DataSourceDetails::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}

const DataSourceDetails::id_type& DataSourceDetails::
id () const
{
  return this->id_.get ();
}

DataSourceDetails::id_type& DataSourceDetails::
id ()
{
  return this->id_.get ();
}

void DataSourceDetails::
id (const id_type& x)
{
  this->id_.set (x);
}

void DataSourceDetails::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const DataSourceDetails::type_optional& DataSourceDetails::
type () const
{
  return this->type_;
}

DataSourceDetails::type_optional& DataSourceDetails::
type ()
{
  return this->type_;
}

void DataSourceDetails::
type (const type_type& x)
{
  this->type_.set (x);
}

void DataSourceDetails::
type (const type_optional& x)
{
  this->type_ = x;
}

void DataSourceDetails::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


// MeasurementTechniqueDetails
// 

const MeasurementTechniqueDetails::Name_type& MeasurementTechniqueDetails::
Name () const
{
  return this->Name_.get ();
}

MeasurementTechniqueDetails::Name_type& MeasurementTechniqueDetails::
Name ()
{
  return this->Name_.get ();
}

void MeasurementTechniqueDetails::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void MeasurementTechniqueDetails::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const MeasurementTechniqueDetails::Notes_optional& MeasurementTechniqueDetails::
Notes () const
{
  return this->Notes_;
}

MeasurementTechniqueDetails::Notes_optional& MeasurementTechniqueDetails::
Notes ()
{
  return this->Notes_;
}

void MeasurementTechniqueDetails::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void MeasurementTechniqueDetails::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void MeasurementTechniqueDetails::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}

const MeasurementTechniqueDetails::id_type& MeasurementTechniqueDetails::
id () const
{
  return this->id_.get ();
}

MeasurementTechniqueDetails::id_type& MeasurementTechniqueDetails::
id ()
{
  return this->id_.get ();
}

void MeasurementTechniqueDetails::
id (const id_type& x)
{
  this->id_.set (x);
}

void MeasurementTechniqueDetails::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}


// ParameterDetails
// 

const ParameterDetails::Name_type& ParameterDetails::
Name () const
{
  return this->Name_.get ();
}

ParameterDetails::Name_type& ParameterDetails::
Name ()
{
  return this->Name_.get ();
}

void ParameterDetails::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void ParameterDetails::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const ParameterDetails::Units_optional& ParameterDetails::
Units () const
{
  return this->Units_;
}

ParameterDetails::Units_optional& ParameterDetails::
Units ()
{
  return this->Units_;
}

void ParameterDetails::
Units (const Units_type& x)
{
  this->Units_.set (x);
}

void ParameterDetails::
Units (const Units_optional& x)
{
  this->Units_ = x;
}

void ParameterDetails::
Units (::std::unique_ptr< Units_type > x)
{
  this->Units_.set (std::move (x));
}

const ParameterDetails::Unitless_optional& ParameterDetails::
Unitless () const
{
  return this->Unitless_;
}

ParameterDetails::Unitless_optional& ParameterDetails::
Unitless ()
{
  return this->Unitless_;
}

void ParameterDetails::
Unitless (const Unitless_type& x)
{
  this->Unitless_.set (x);
}

void ParameterDetails::
Unitless (const Unitless_optional& x)
{
  this->Unitless_ = x;
}

void ParameterDetails::
Unitless (::std::unique_ptr< Unitless_type > x)
{
  this->Unitless_.set (std::move (x));
}

const ParameterDetails::Notes_optional& ParameterDetails::
Notes () const
{
  return this->Notes_;
}

ParameterDetails::Notes_optional& ParameterDetails::
Notes ()
{
  return this->Notes_;
}

void ParameterDetails::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void ParameterDetails::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void ParameterDetails::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}

const ParameterDetails::id_type& ParameterDetails::
id () const
{
  return this->id_.get ();
}

ParameterDetails::id_type& ParameterDetails::
id ()
{
  return this->id_.get ();
}

void ParameterDetails::
id (const id_type& x)
{
  this->id_.set (x);
}

void ParameterDetails::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}


// PropertyDetails
// 

const PropertyDetails::Name_type& PropertyDetails::
Name () const
{
  return this->Name_.get ();
}

PropertyDetails::Name_type& PropertyDetails::
Name ()
{
  return this->Name_.get ();
}

void PropertyDetails::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void PropertyDetails::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const PropertyDetails::Units_optional& PropertyDetails::
Units () const
{
  return this->Units_;
}

PropertyDetails::Units_optional& PropertyDetails::
Units ()
{
  return this->Units_;
}

void PropertyDetails::
Units (const Units_type& x)
{
  this->Units_.set (x);
}

void PropertyDetails::
Units (const Units_optional& x)
{
  this->Units_ = x;
}

void PropertyDetails::
Units (::std::unique_ptr< Units_type > x)
{
  this->Units_.set (std::move (x));
}

const PropertyDetails::Unitless_optional& PropertyDetails::
Unitless () const
{
  return this->Unitless_;
}

PropertyDetails::Unitless_optional& PropertyDetails::
Unitless ()
{
  return this->Unitless_;
}

void PropertyDetails::
Unitless (const Unitless_type& x)
{
  this->Unitless_.set (x);
}

void PropertyDetails::
Unitless (const Unitless_optional& x)
{
  this->Unitless_ = x;
}

void PropertyDetails::
Unitless (::std::unique_ptr< Unitless_type > x)
{
  this->Unitless_.set (std::move (x));
}

const PropertyDetails::Notes_optional& PropertyDetails::
Notes () const
{
  return this->Notes_;
}

PropertyDetails::Notes_optional& PropertyDetails::
Notes ()
{
  return this->Notes_;
}

void PropertyDetails::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void PropertyDetails::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void PropertyDetails::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}

const PropertyDetails::id_type& PropertyDetails::
id () const
{
  return this->id_.get ();
}

PropertyDetails::id_type& PropertyDetails::
id ()
{
  return this->id_.get ();
}

void PropertyDetails::
id (const id_type& x)
{
  this->id_.set (x);
}

void PropertyDetails::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const PropertyDetails::type_optional& PropertyDetails::
type () const
{
  return this->type_;
}

PropertyDetails::type_optional& PropertyDetails::
type ()
{
  return this->type_;
}

void PropertyDetails::
type (const type_type& x)
{
  this->type_.set (x);
}

void PropertyDetails::
type (const type_optional& x)
{
  this->type_ = x;
}

void PropertyDetails::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


// SourceDetails
// 

const SourceDetails::Name_type& SourceDetails::
Name () const
{
  return this->Name_.get ();
}

SourceDetails::Name_type& SourceDetails::
Name ()
{
  return this->Name_.get ();
}

void SourceDetails::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void SourceDetails::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const SourceDetails::Notes_optional& SourceDetails::
Notes () const
{
  return this->Notes_;
}

SourceDetails::Notes_optional& SourceDetails::
Notes ()
{
  return this->Notes_;
}

void SourceDetails::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void SourceDetails::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void SourceDetails::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}

const SourceDetails::id_type& SourceDetails::
id () const
{
  return this->id_.get ();
}

SourceDetails::id_type& SourceDetails::
id ()
{
  return this->id_.get ();
}

void SourceDetails::
id (const id_type& x)
{
  this->id_.set (x);
}

void SourceDetails::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const SourceDetails::type_optional& SourceDetails::
type () const
{
  return this->type_;
}

SourceDetails::type_optional& SourceDetails::
type ()
{
  return this->type_;
}

void SourceDetails::
type (const type_type& x)
{
  this->type_.set (x);
}

void SourceDetails::
type (const type_optional& x)
{
  this->type_ = x;
}

void SourceDetails::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


// SpecimenDetails
// 

const SpecimenDetails::Name_optional& SpecimenDetails::
Name () const
{
  return this->Name_;
}

SpecimenDetails::Name_optional& SpecimenDetails::
Name ()
{
  return this->Name_;
}

void SpecimenDetails::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void SpecimenDetails::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void SpecimenDetails::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const SpecimenDetails::Notes_optional& SpecimenDetails::
Notes () const
{
  return this->Notes_;
}

SpecimenDetails::Notes_optional& SpecimenDetails::
Notes ()
{
  return this->Notes_;
}

void SpecimenDetails::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void SpecimenDetails::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void SpecimenDetails::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}

const SpecimenDetails::Geometry_optional& SpecimenDetails::
Geometry () const
{
  return this->Geometry_;
}

SpecimenDetails::Geometry_optional& SpecimenDetails::
Geometry ()
{
  return this->Geometry_;
}

void SpecimenDetails::
Geometry (const Geometry_type& x)
{
  this->Geometry_.set (x);
}

void SpecimenDetails::
Geometry (const Geometry_optional& x)
{
  this->Geometry_ = x;
}

void SpecimenDetails::
Geometry (::std::unique_ptr< Geometry_type > x)
{
  this->Geometry_.set (std::move (x));
}

const SpecimenDetails::id_type& SpecimenDetails::
id () const
{
  return this->id_.get ();
}

SpecimenDetails::id_type& SpecimenDetails::
id ()
{
  return this->id_.get ();
}

void SpecimenDetails::
id (const id_type& x)
{
  this->id_.set (x);
}

void SpecimenDetails::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const SpecimenDetails::type_optional& SpecimenDetails::
type () const
{
  return this->type_;
}

SpecimenDetails::type_optional& SpecimenDetails::
type ()
{
  return this->type_;
}

void SpecimenDetails::
type (const type_type& x)
{
  this->type_.set (x);
}

void SpecimenDetails::
type (const type_optional& x)
{
  this->type_ = x;
}

void SpecimenDetails::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


// TestConditionDetails
// 

const TestConditionDetails::ParameterValue_sequence& TestConditionDetails::
ParameterValue () const
{
  return this->ParameterValue_;
}

TestConditionDetails::ParameterValue_sequence& TestConditionDetails::
ParameterValue ()
{
  return this->ParameterValue_;
}

void TestConditionDetails::
ParameterValue (const ParameterValue_sequence& s)
{
  this->ParameterValue_ = s;
}

const TestConditionDetails::Notes_optional& TestConditionDetails::
Notes () const
{
  return this->Notes_;
}

TestConditionDetails::Notes_optional& TestConditionDetails::
Notes ()
{
  return this->Notes_;
}

void TestConditionDetails::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void TestConditionDetails::
Notes (const Notes_optional& x)
{
  this->Notes_ = x;
}

void TestConditionDetails::
Notes (::std::unique_ptr< Notes_type > x)
{
  this->Notes_.set (std::move (x));
}

const TestConditionDetails::id_type& TestConditionDetails::
id () const
{
  return this->id_.get ();
}

TestConditionDetails::id_type& TestConditionDetails::
id ()
{
  return this->id_.get ();
}

void TestConditionDetails::
id (const id_type& x)
{
  this->id_.set (x);
}

void TestConditionDetails::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}


// ChemicalElementSymbol
// 

ChemicalElementSymbol::
ChemicalElementSymbol (value v)
: ::xml_schema::string (_xsd_ChemicalElementSymbol_literals_[v])
{
}

ChemicalElementSymbol::
ChemicalElementSymbol (const char* v)
: ::xml_schema::string (v)
{
}

ChemicalElementSymbol::
ChemicalElementSymbol (const ::std::string& v)
: ::xml_schema::string (v)
{
}

ChemicalElementSymbol::
ChemicalElementSymbol (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

ChemicalElementSymbol::
ChemicalElementSymbol (const ChemicalElementSymbol& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

ChemicalElementSymbol& ChemicalElementSymbol::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_ChemicalElementSymbol_literals_[v]);

  return *this;
}


// CurrencyCode
// 

CurrencyCode::
CurrencyCode (value v)
: ::xml_schema::string (_xsd_CurrencyCode_literals_[v])
{
}

CurrencyCode::
CurrencyCode (const char* v)
: ::xml_schema::string (v)
{
}

CurrencyCode::
CurrencyCode (const ::std::string& v)
: ::xml_schema::string (v)
{
}

CurrencyCode::
CurrencyCode (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

CurrencyCode::
CurrencyCode (const CurrencyCode& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

CurrencyCode& CurrencyCode::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_CurrencyCode_literals_[v]);

  return *this;
}


// MatML_Doc
// 

const MatML_Doc::Material_sequence& MatML_Doc::
Material () const
{
  return this->Material_;
}

MatML_Doc::Material_sequence& MatML_Doc::
Material ()
{
  return this->Material_;
}

void MatML_Doc::
Material (const Material_sequence& s)
{
  this->Material_ = s;
}

const MatML_Doc::Metadata_optional& MatML_Doc::
Metadata () const
{
  return this->Metadata_;
}

MatML_Doc::Metadata_optional& MatML_Doc::
Metadata ()
{
  return this->Metadata_;
}

void MatML_Doc::
Metadata (const Metadata_type& x)
{
  this->Metadata_.set (x);
}

void MatML_Doc::
Metadata (const Metadata_optional& x)
{
  this->Metadata_ = x;
}

void MatML_Doc::
Metadata (::std::unique_ptr< Metadata_type > x)
{
  this->Metadata_.set (std::move (x));
}


// ParentMaterial
// 

const ParentMaterial::id_type& ParentMaterial::
id () const
{
  return this->id_.get ();
}

ParentMaterial::id_type& ParentMaterial::
id ()
{
  return this->id_.get ();
}

void ParentMaterial::
id (const id_type& x)
{
  this->id_.set (x);
}

void ParentMaterial::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}


// Symbol
// 

const Symbol::subscript_type& Symbol::
subscript () const
{
  return this->subscript_.get ();
}

Symbol::subscript_type& Symbol::
subscript ()
{
  return this->subscript_.get ();
}

void Symbol::
subscript (const subscript_type& x)
{
  this->subscript_.set (x);
}

void Symbol::
subscript (::std::unique_ptr< subscript_type > x)
{
  this->subscript_.set (std::move (x));
}

const Symbol::subscript_type& Symbol::
subscript_default_value ()
{
  return subscript_default_value_;
}


// Graph
// 


// Data
// 

const Data::format_optional& Data::
format () const
{
  return this->format_;
}

Data::format_optional& Data::
format ()
{
  return this->format_;
}

void Data::
format (const format_type& x)
{
  this->format_.set (x);
}

void Data::
format (const format_optional& x)
{
  this->format_ = x;
}

void Data::
format (::std::unique_ptr< format_type > x)
{
  this->format_.set (std::move (x));
}


// Data1
// 

const Data1::format_type& Data1::
format () const
{
  return this->format_.get ();
}

Data1::format_type& Data1::
format ()
{
  return this->format_.get ();
}

void Data1::
format (const format_type& x)
{
  this->format_.set (x);
}

void Data1::
format (::std::unique_ptr< format_type > x)
{
  this->format_.set (std::move (x));
}


// delimiter
// 


// Scale
// 

Scale::
Scale (value v)
: ::xml_schema::string (_xsd_Scale_literals_[v])
{
}

Scale::
Scale (const char* v)
: ::xml_schema::string (v)
{
}

Scale::
Scale (const ::std::string& v)
: ::xml_schema::string (v)
{
}

Scale::
Scale (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

Scale::
Scale (const Scale& v,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

Scale& Scale::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_Scale_literals_[v]);

  return *this;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// Associate
//

Associate::
Associate ()
: ::xml_schema::string ()
{
}

Associate::
Associate (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

Associate::
Associate (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

Associate::
Associate (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

Associate::
Associate (const Associate& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

Associate::
Associate (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

Associate::
Associate (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

Associate::
Associate (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

Associate* Associate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Associate (*this, f, c);
}

Associate::
~Associate ()
{
}

// AssociationDetails
//

AssociationDetails::
AssociationDetails ()
: ::xml_schema::type (),
  Associate_ (this),
  Relationship_ (this),
  Notes_ (this)
{
}

AssociationDetails::
AssociationDetails (const AssociationDetails& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Associate_ (x.Associate_, f, this),
  Relationship_ (x.Relationship_, f, this),
  Notes_ (x.Notes_, f, this)
{
}

AssociationDetails::
AssociationDetails (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Associate_ (this),
  Relationship_ (this),
  Notes_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void AssociationDetails::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Associate
    //
    if (n.name () == "Associate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Associate_type > r (
        Associate_traits::create (i, f, this));

      if (!this->Associate_)
      {
        this->Associate_.set (::std::move (r));
        continue;
      }
    }

    // Relationship
    //
    if (n.name () == "Relationship" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Relationship_type > r (
        Relationship_traits::create (i, f, this));

      if (!this->Relationship_)
      {
        this->Relationship_.set (::std::move (r));
        continue;
      }
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

AssociationDetails* AssociationDetails::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AssociationDetails (*this, f, c);
}

AssociationDetails& AssociationDetails::
operator= (const AssociationDetails& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Associate_ = x.Associate_;
    this->Relationship_ = x.Relationship_;
    this->Notes_ = x.Notes_;
  }

  return *this;
}

AssociationDetails::
~AssociationDetails ()
{
}

// BulkDetails
//

BulkDetails::
BulkDetails (const Name_type& Name)
: ::xml_schema::type (),
  Name_ (Name, this),
  Class_ (this),
  Subclass_ (this),
  Specification_ (this),
  Source_ (this),
  Form_ (this),
  ProcessingDetails_ (this),
  Characterization_ (this),
  PropertyData_ (this),
  Notes_ (this)
{
}

BulkDetails::
BulkDetails (::std::unique_ptr< Name_type > Name)
: ::xml_schema::type (),
  Name_ (std::move (Name), this),
  Class_ (this),
  Subclass_ (this),
  Specification_ (this),
  Source_ (this),
  Form_ (this),
  ProcessingDetails_ (this),
  Characterization_ (this),
  PropertyData_ (this),
  Notes_ (this)
{
}

BulkDetails::
BulkDetails (const BulkDetails& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this),
  Class_ (x.Class_, f, this),
  Subclass_ (x.Subclass_, f, this),
  Specification_ (x.Specification_, f, this),
  Source_ (x.Source_, f, this),
  Form_ (x.Form_, f, this),
  ProcessingDetails_ (x.ProcessingDetails_, f, this),
  Characterization_ (x.Characterization_, f, this),
  PropertyData_ (x.PropertyData_, f, this),
  Notes_ (x.Notes_, f, this)
{
}

BulkDetails::
BulkDetails (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this),
  Class_ (this),
  Subclass_ (this),
  Specification_ (this),
  Source_ (this),
  Form_ (this),
  ProcessingDetails_ (this),
  Characterization_ (this),
  PropertyData_ (this),
  Notes_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void BulkDetails::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!Name_.present ())
      {
        this->Name_.set (::std::move (r));
        continue;
      }
    }

    // Class
    //
    if (n.name () == "Class" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Class_type > r (
        Class_traits::create (i, f, this));

      this->Class_.push_back (::std::move (r));
      continue;
    }

    // Subclass
    //
    if (n.name () == "Subclass" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Subclass_type > r (
        Subclass_traits::create (i, f, this));

      this->Subclass_.push_back (::std::move (r));
      continue;
    }

    // Specification
    //
    if (n.name () == "Specification" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Specification_type > r (
        Specification_traits::create (i, f, this));

      this->Specification_.push_back (::std::move (r));
      continue;
    }

    // Source
    //
    if (n.name () == "Source" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Source_type > r (
        Source_traits::create (i, f, this));

      if (!this->Source_)
      {
        this->Source_.set (::std::move (r));
        continue;
      }
    }

    // Form
    //
    if (n.name () == "Form" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Form_type > r (
        Form_traits::create (i, f, this));

      if (!this->Form_)
      {
        this->Form_.set (::std::move (r));
        continue;
      }
    }

    // ProcessingDetails
    //
    if (n.name () == "ProcessingDetails" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ProcessingDetails_type > r (
        ProcessingDetails_traits::create (i, f, this));

      this->ProcessingDetails_.push_back (::std::move (r));
      continue;
    }

    // Characterization
    //
    if (n.name () == "Characterization" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Characterization_type > r (
        Characterization_traits::create (i, f, this));

      if (!this->Characterization_)
      {
        this->Characterization_.set (::std::move (r));
        continue;
      }
    }

    // PropertyData
    //
    if (n.name () == "PropertyData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< PropertyData_type > r (
        PropertyData_traits::create (i, f, this));

      this->PropertyData_.push_back (::std::move (r));
      continue;
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Name",
      "");
  }
}

BulkDetails* BulkDetails::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BulkDetails (*this, f, c);
}

BulkDetails& BulkDetails::
operator= (const BulkDetails& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
    this->Class_ = x.Class_;
    this->Subclass_ = x.Subclass_;
    this->Specification_ = x.Specification_;
    this->Source_ = x.Source_;
    this->Form_ = x.Form_;
    this->ProcessingDetails_ = x.ProcessingDetails_;
    this->Characterization_ = x.Characterization_;
    this->PropertyData_ = x.PropertyData_;
    this->Notes_ = x.Notes_;
  }

  return *this;
}

BulkDetails::
~BulkDetails ()
{
}

// Characterization
//

Characterization::
Characterization (const Formula_type& Formula)
: ::xml_schema::type (),
  Formula_ (Formula, this),
  ChemicalComposition_ (this),
  PhaseComposition_ (this),
  DimensionalDetails_ (this),
  Notes_ (this)
{
}

Characterization::
Characterization (const Characterization& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Formula_ (x.Formula_, f, this),
  ChemicalComposition_ (x.ChemicalComposition_, f, this),
  PhaseComposition_ (x.PhaseComposition_, f, this),
  DimensionalDetails_ (x.DimensionalDetails_, f, this),
  Notes_ (x.Notes_, f, this)
{
}

Characterization::
Characterization (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Formula_ (this),
  ChemicalComposition_ (this),
  PhaseComposition_ (this),
  DimensionalDetails_ (this),
  Notes_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Characterization::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Formula
    //
    if (n.name () == "Formula" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Formula_type > r (
        Formula_traits::create (i, f, this));

      if (!Formula_.present ())
      {
        this->Formula_.set (::std::move (r));
        continue;
      }
    }

    // ChemicalComposition
    //
    if (n.name () == "ChemicalComposition" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ChemicalComposition_type > r (
        ChemicalComposition_traits::create (i, f, this));

      if (!this->ChemicalComposition_)
      {
        this->ChemicalComposition_.set (::std::move (r));
        continue;
      }
    }

    // PhaseComposition
    //
    if (n.name () == "PhaseComposition" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< PhaseComposition_type > r (
        PhaseComposition_traits::create (i, f, this));

      this->PhaseComposition_.push_back (::std::move (r));
      continue;
    }

    // DimensionalDetails
    //
    if (n.name () == "DimensionalDetails" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< DimensionalDetails_type > r (
        DimensionalDetails_traits::create (i, f, this));

      this->DimensionalDetails_.push_back (::std::move (r));
      continue;
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Formula_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Formula",
      "");
  }
}

Characterization* Characterization::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Characterization (*this, f, c);
}

Characterization& Characterization::
operator= (const Characterization& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Formula_ = x.Formula_;
    this->ChemicalComposition_ = x.ChemicalComposition_;
    this->PhaseComposition_ = x.PhaseComposition_;
    this->DimensionalDetails_ = x.DimensionalDetails_;
    this->Notes_ = x.Notes_;
  }

  return *this;
}

Characterization::
~Characterization ()
{
}

// ChemicalComposition
//

ChemicalComposition::
ChemicalComposition ()
: ::xml_schema::type (),
  Compound_ (this),
  Element_ (this)
{
}

ChemicalComposition::
ChemicalComposition (const ChemicalComposition& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Compound_ (x.Compound_, f, this),
  Element_ (x.Element_, f, this)
{
}

ChemicalComposition::
ChemicalComposition (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Compound_ (this),
  Element_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ChemicalComposition::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Compound
    //
    if (n.name () == "Compound" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Compound_type > r (
        Compound_traits::create (i, f, this));

      this->Compound_.push_back (::std::move (r));
      continue;
    }

    // Element
    //
    if (n.name () == "Element" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Element_type > r (
        Element_traits::create (i, f, this));

      this->Element_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

ChemicalComposition* ChemicalComposition::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ChemicalComposition (*this, f, c);
}

ChemicalComposition& ChemicalComposition::
operator= (const ChemicalComposition& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Compound_ = x.Compound_;
    this->Element_ = x.Element_;
  }

  return *this;
}

ChemicalComposition::
~ChemicalComposition ()
{
}

// Class
//

Class::
Class ()
: ::xml_schema::type (),
  Name_ (this),
  ParentMaterial_ (this),
  ParentSubClass_ (this)
{
}

Class::
Class (const Class& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this),
  ParentMaterial_ (x.ParentMaterial_, f, this),
  ParentSubClass_ (x.ParentSubClass_, f, this)
{
}

Class::
Class (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this),
  ParentMaterial_ (this),
  ParentSubClass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Class::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!this->Name_)
      {
        this->Name_.set (::std::move (r));
        continue;
      }
    }

    // ParentMaterial
    //
    if (n.name () == "ParentMaterial" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ParentMaterial_type > r (
        ParentMaterial_traits::create (i, f, this));

      this->ParentMaterial_.push_back (::std::move (r));
      continue;
    }

    // ParentSubClass
    //
    if (n.name () == "ParentSubClass" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ParentSubClass_type > r (
        ParentSubClass_traits::create (i, f, this));

      this->ParentSubClass_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

Class* Class::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Class (*this, f, c);
}

Class& Class::
operator= (const Class& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
    this->ParentMaterial_ = x.ParentMaterial_;
    this->ParentSubClass_ = x.ParentSubClass_;
  }

  return *this;
}

Class::
~Class ()
{
}

// ComponentDetails
//

ComponentDetails::
ComponentDetails (const Name_type& Name)
: ::xml_schema::type (),
  Name_ (Name, this),
  Class_ (this),
  Subclass_ (this),
  Specification_ (this),
  Source_ (this),
  Form_ (this),
  ProcessingDetails_ (this),
  Characterization_ (this),
  PropertyData_ (this),
  AssociationDetails_ (this),
  ComponentDetails1_ (this),
  id_ (this)
{
}

ComponentDetails::
ComponentDetails (::std::unique_ptr< Name_type > Name)
: ::xml_schema::type (),
  Name_ (std::move (Name), this),
  Class_ (this),
  Subclass_ (this),
  Specification_ (this),
  Source_ (this),
  Form_ (this),
  ProcessingDetails_ (this),
  Characterization_ (this),
  PropertyData_ (this),
  AssociationDetails_ (this),
  ComponentDetails1_ (this),
  id_ (this)
{
}

ComponentDetails::
ComponentDetails (const ComponentDetails& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this),
  Class_ (x.Class_, f, this),
  Subclass_ (x.Subclass_, f, this),
  Specification_ (x.Specification_, f, this),
  Source_ (x.Source_, f, this),
  Form_ (x.Form_, f, this),
  ProcessingDetails_ (x.ProcessingDetails_, f, this),
  Characterization_ (x.Characterization_, f, this),
  PropertyData_ (x.PropertyData_, f, this),
  AssociationDetails_ (x.AssociationDetails_, f, this),
  ComponentDetails1_ (x.ComponentDetails1_, f, this),
  id_ (x.id_, f, this)
{
}

ComponentDetails::
ComponentDetails (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this),
  Class_ (this),
  Subclass_ (this),
  Specification_ (this),
  Source_ (this),
  Form_ (this),
  ProcessingDetails_ (this),
  Characterization_ (this),
  PropertyData_ (this),
  AssociationDetails_ (this),
  ComponentDetails1_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void ComponentDetails::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!Name_.present ())
      {
        this->Name_.set (::std::move (r));
        continue;
      }
    }

    // Class
    //
    if (n.name () == "Class" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Class_type > r (
        Class_traits::create (i, f, this));

      this->Class_.push_back (::std::move (r));
      continue;
    }

    // Subclass
    //
    if (n.name () == "Subclass" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Subclass_type > r (
        Subclass_traits::create (i, f, this));

      this->Subclass_.push_back (::std::move (r));
      continue;
    }

    // Specification
    //
    if (n.name () == "Specification" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Specification_type > r (
        Specification_traits::create (i, f, this));

      this->Specification_.push_back (::std::move (r));
      continue;
    }

    // Source
    //
    if (n.name () == "Source" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Source_type > r (
        Source_traits::create (i, f, this));

      if (!this->Source_)
      {
        this->Source_.set (::std::move (r));
        continue;
      }
    }

    // Form
    //
    if (n.name () == "Form" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Form_type > r (
        Form_traits::create (i, f, this));

      if (!this->Form_)
      {
        this->Form_.set (::std::move (r));
        continue;
      }
    }

    // ProcessingDetails
    //
    if (n.name () == "ProcessingDetails" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ProcessingDetails_type > r (
        ProcessingDetails_traits::create (i, f, this));

      this->ProcessingDetails_.push_back (::std::move (r));
      continue;
    }

    // Characterization
    //
    if (n.name () == "Characterization" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Characterization_type > r (
        Characterization_traits::create (i, f, this));

      if (!this->Characterization_)
      {
        this->Characterization_.set (::std::move (r));
        continue;
      }
    }

    // PropertyData
    //
    if (n.name () == "PropertyData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< PropertyData_type > r (
        PropertyData_traits::create (i, f, this));

      this->PropertyData_.push_back (::std::move (r));
      continue;
    }

    // AssociationDetails
    //
    if (n.name () == "AssociationDetails" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< AssociationDetails_type > r (
        AssociationDetails_traits::create (i, f, this));

      this->AssociationDetails_.push_back (::std::move (r));
      continue;
    }

    // ComponentDetails
    //
    if (n.name () == "ComponentDetails" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ComponentDetails1_type > r (
        ComponentDetails1_traits::create (i, f, this));

      this->ComponentDetails1_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  if (!Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Name",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }
}

ComponentDetails* ComponentDetails::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ComponentDetails (*this, f, c);
}

ComponentDetails& ComponentDetails::
operator= (const ComponentDetails& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
    this->Class_ = x.Class_;
    this->Subclass_ = x.Subclass_;
    this->Specification_ = x.Specification_;
    this->Source_ = x.Source_;
    this->Form_ = x.Form_;
    this->ProcessingDetails_ = x.ProcessingDetails_;
    this->Characterization_ = x.Characterization_;
    this->PropertyData_ = x.PropertyData_;
    this->AssociationDetails_ = x.AssociationDetails_;
    this->ComponentDetails1_ = x.ComponentDetails1_;
    this->id_ = x.id_;
  }

  return *this;
}

ComponentDetails::
~ComponentDetails ()
{
}

// Compound
//

Compound::
Compound ()
: ::xml_schema::type (),
  Element_ (this),
  Concentration_ (this),
  Notes_ (this)
{
}

Compound::
Compound (const Compound& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Element_ (x.Element_, f, this),
  Concentration_ (x.Concentration_, f, this),
  Notes_ (x.Notes_, f, this)
{
}

Compound::
Compound (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Element_ (this),
  Concentration_ (this),
  Notes_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Compound::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Element
    //
    if (n.name () == "Element" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Element_type > r (
        Element_traits::create (i, f, this));

      this->Element_.push_back (::std::move (r));
      continue;
    }

    // Concentration
    //
    if (n.name () == "Concentration" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Concentration_type > r (
        Concentration_traits::create (i, f, this));

      if (!this->Concentration_)
      {
        this->Concentration_.set (::std::move (r));
        continue;
      }
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

Compound* Compound::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Compound (*this, f, c);
}

Compound& Compound::
operator= (const Compound& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Element_ = x.Element_;
    this->Concentration_ = x.Concentration_;
    this->Notes_ = x.Notes_;
  }

  return *this;
}

Compound::
~Compound ()
{
}

// Concentration
//

Concentration::
Concentration (const Value_type& Value,
               const Units_type& Units)
: ::xml_schema::type (),
  Value_ (Value, this),
  Units_ (Units, this),
  Qualifier_ (this),
  Uncertainty_ (this),
  Notes_ (this)
{
}

Concentration::
Concentration (::std::unique_ptr< Value_type > Value,
               ::std::unique_ptr< Units_type > Units)
: ::xml_schema::type (),
  Value_ (std::move (Value), this),
  Units_ (std::move (Units), this),
  Qualifier_ (this),
  Uncertainty_ (this),
  Notes_ (this)
{
}

Concentration::
Concentration (const Concentration& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Value_ (x.Value_, f, this),
  Units_ (x.Units_, f, this),
  Qualifier_ (x.Qualifier_, f, this),
  Uncertainty_ (x.Uncertainty_, f, this),
  Notes_ (x.Notes_, f, this)
{
}

Concentration::
Concentration (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Value_ (this),
  Units_ (this),
  Qualifier_ (this),
  Uncertainty_ (this),
  Notes_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Concentration::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Value
    //
    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Value_type > r (
        Value_traits::create (i, f, this));

      if (!Value_.present ())
      {
        this->Value_.set (::std::move (r));
        continue;
      }
    }

    // Units
    //
    if (n.name () == "Units" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Units_type > r (
        Units_traits::create (i, f, this));

      if (!Units_.present ())
      {
        this->Units_.set (::std::move (r));
        continue;
      }
    }

    // Qualifier
    //
    if (n.name () == "Qualifier" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Qualifier_type > r (
        Qualifier_traits::create (i, f, this));

      this->Qualifier_.push_back (::std::move (r));
      continue;
    }

    // Uncertainty
    //
    if (n.name () == "Uncertainty" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Uncertainty_type > r (
        Uncertainty_traits::create (i, f, this));

      this->Uncertainty_.push_back (::std::move (r));
      continue;
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Value",
      "");
  }

  if (!Units_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Units",
      "");
  }
}

Concentration* Concentration::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Concentration (*this, f, c);
}

Concentration& Concentration::
operator= (const Concentration& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Value_ = x.Value_;
    this->Units_ = x.Units_;
    this->Qualifier_ = x.Qualifier_;
    this->Uncertainty_ = x.Uncertainty_;
    this->Notes_ = x.Notes_;
  }

  return *this;
}

Concentration::
~Concentration ()
{
}

// DataFormat
//

DataFormat::
DataFormat (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_DataFormat_convert ();
}

DataFormat::
DataFormat (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_DataFormat_convert ();
}

DataFormat::
DataFormat (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_DataFormat_convert ();
}

DataFormat* DataFormat::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DataFormat (*this, f, c);
}

DataFormat::value DataFormat::
_xsd_DataFormat_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_DataFormat_literals_);
  const value* i (::std::lower_bound (
                    _xsd_DataFormat_indexes_,
                    _xsd_DataFormat_indexes_ + 5,
                    *this,
                    c));

  if (i == _xsd_DataFormat_indexes_ + 5 || _xsd_DataFormat_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const DataFormat::
_xsd_DataFormat_literals_[5] =
{
  "float",
  "integer",
  "string",
  "exponential",
  "mixed"
};

const DataFormat::value DataFormat::
_xsd_DataFormat_indexes_[5] =
{
  ::DataFormat::exponential,
  ::DataFormat::float_,
  ::DataFormat::integer,
  ::DataFormat::mixed,
  ::DataFormat::string
};

// DimensionalDetails
//

DimensionalDetails::
DimensionalDetails (const Name_type& Name,
                    const Value_type& Value,
                    const Units_type& Units)
: ::xml_schema::type (),
  Name_ (Name, this),
  Value_ (Value, this),
  Units_ (Units, this),
  Qualifier_ (this),
  Uncertainty_ (this),
  Notes_ (this)
{
}

DimensionalDetails::
DimensionalDetails (::std::unique_ptr< Name_type > Name,
                    ::std::unique_ptr< Value_type > Value,
                    ::std::unique_ptr< Units_type > Units)
: ::xml_schema::type (),
  Name_ (std::move (Name), this),
  Value_ (std::move (Value), this),
  Units_ (std::move (Units), this),
  Qualifier_ (this),
  Uncertainty_ (this),
  Notes_ (this)
{
}

DimensionalDetails::
DimensionalDetails (const DimensionalDetails& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this),
  Value_ (x.Value_, f, this),
  Units_ (x.Units_, f, this),
  Qualifier_ (x.Qualifier_, f, this),
  Uncertainty_ (x.Uncertainty_, f, this),
  Notes_ (x.Notes_, f, this)
{
}

DimensionalDetails::
DimensionalDetails (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this),
  Value_ (this),
  Units_ (this),
  Qualifier_ (this),
  Uncertainty_ (this),
  Notes_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DimensionalDetails::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!Name_.present ())
      {
        this->Name_.set (::std::move (r));
        continue;
      }
    }

    // Value
    //
    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Value_type > r (
        Value_traits::create (i, f, this));

      if (!Value_.present ())
      {
        this->Value_.set (::std::move (r));
        continue;
      }
    }

    // Units
    //
    if (n.name () == "Units" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Units_type > r (
        Units_traits::create (i, f, this));

      if (!Units_.present ())
      {
        this->Units_.set (::std::move (r));
        continue;
      }
    }

    // Qualifier
    //
    if (n.name () == "Qualifier" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Qualifier_type > r (
        Qualifier_traits::create (i, f, this));

      if (!this->Qualifier_)
      {
        this->Qualifier_.set (::std::move (r));
        continue;
      }
    }

    // Uncertainty
    //
    if (n.name () == "Uncertainty" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Uncertainty_type > r (
        Uncertainty_traits::create (i, f, this));

      this->Uncertainty_.push_back (::std::move (r));
      continue;
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Name",
      "");
  }

  if (!Value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Value",
      "");
  }

  if (!Units_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Units",
      "");
  }
}

DimensionalDetails* DimensionalDetails::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DimensionalDetails (*this, f, c);
}

DimensionalDetails& DimensionalDetails::
operator= (const DimensionalDetails& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
    this->Value_ = x.Value_;
    this->Units_ = x.Units_;
    this->Qualifier_ = x.Qualifier_;
    this->Uncertainty_ = x.Uncertainty_;
    this->Notes_ = x.Notes_;
  }

  return *this;
}

DimensionalDetails::
~DimensionalDetails ()
{
}

// Element
//

Element::
Element (const Symbol_type& Symbol)
: ::xml_schema::type (),
  Symbol_ (Symbol, this),
  Concentration_ (this),
  Notes_ (this)
{
}

Element::
Element (::std::unique_ptr< Symbol_type > Symbol)
: ::xml_schema::type (),
  Symbol_ (std::move (Symbol), this),
  Concentration_ (this),
  Notes_ (this)
{
}

Element::
Element (const Element& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Symbol_ (x.Symbol_, f, this),
  Concentration_ (x.Concentration_, f, this),
  Notes_ (x.Notes_, f, this)
{
}

Element::
Element (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Symbol_ (this),
  Concentration_ (this),
  Notes_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Element::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Symbol
    //
    if (n.name () == "Symbol" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Symbol_type > r (
        Symbol_traits::create (i, f, this));

      if (!Symbol_.present ())
      {
        this->Symbol_.set (::std::move (r));
        continue;
      }
    }

    // Concentration
    //
    if (n.name () == "Concentration" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Concentration_type > r (
        Concentration_traits::create (i, f, this));

      if (!this->Concentration_)
      {
        this->Concentration_.set (::std::move (r));
        continue;
      }
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Symbol_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Symbol",
      "");
  }
}

Element* Element::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Element (*this, f, c);
}

Element& Element::
operator= (const Element& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Symbol_ = x.Symbol_;
    this->Concentration_ = x.Concentration_;
    this->Notes_ = x.Notes_;
  }

  return *this;
}

Element::
~Element ()
{
}

// Form
//

Form::
Form (const Description_type& Description)
: ::xml_schema::type (),
  Description_ (Description, this),
  Geometry_ (this),
  Notes_ (this)
{
}

Form::
Form (::std::unique_ptr< Description_type > Description)
: ::xml_schema::type (),
  Description_ (std::move (Description), this),
  Geometry_ (this),
  Notes_ (this)
{
}

Form::
Form (const Form& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Description_ (x.Description_, f, this),
  Geometry_ (x.Geometry_, f, this),
  Notes_ (x.Notes_, f, this)
{
}

Form::
Form (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Description_ (this),
  Geometry_ (this),
  Notes_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Form::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Description
    //
    if (n.name () == "Description" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Description_type > r (
        Description_traits::create (i, f, this));

      if (!Description_.present ())
      {
        this->Description_.set (::std::move (r));
        continue;
      }
    }

    // Geometry
    //
    if (n.name () == "Geometry" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Geometry_type > r (
        Geometry_traits::create (i, f, this));

      if (!this->Geometry_)
      {
        this->Geometry_.set (::std::move (r));
        continue;
      }
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Description_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Description",
      "");
  }
}

Form* Form::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Form (*this, f, c);
}

Form& Form::
operator= (const Form& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Description_ = x.Description_;
    this->Geometry_ = x.Geometry_;
    this->Notes_ = x.Notes_;
  }

  return *this;
}

Form::
~Form ()
{
}

// Formula
//

Formula::
Formula ()
: ::xml_schema::string ()
{
}

Formula::
Formula (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

Formula::
Formula (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

Formula::
Formula (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

Formula::
Formula (const Formula& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

Formula::
Formula (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

Formula::
Formula (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

Formula::
Formula (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

Formula* Formula::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Formula (*this, f, c);
}

Formula::
~Formula ()
{
}

// Geometry
//

Geometry::
Geometry (const Shape_type& Shape)
: ::xml_schema::type (),
  Shape_ (Shape, this),
  Dimensions_ (this),
  Orientation_ (this),
  Notes_ (this)
{
}

Geometry::
Geometry (const Geometry& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Shape_ (x.Shape_, f, this),
  Dimensions_ (x.Dimensions_, f, this),
  Orientation_ (x.Orientation_, f, this),
  Notes_ (x.Notes_, f, this)
{
}

Geometry::
Geometry (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Shape_ (this),
  Dimensions_ (this),
  Orientation_ (this),
  Notes_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Geometry::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Shape
    //
    if (n.name () == "Shape" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Shape_type > r (
        Shape_traits::create (i, f, this));

      if (!Shape_.present ())
      {
        this->Shape_.set (::std::move (r));
        continue;
      }
    }

    // Dimensions
    //
    if (n.name () == "Dimensions" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Dimensions_type > r (
        Dimensions_traits::create (i, f, this));

      if (!this->Dimensions_)
      {
        this->Dimensions_.set (::std::move (r));
        continue;
      }
    }

    // Orientation
    //
    if (n.name () == "Orientation" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Orientation_type > r (
        Orientation_traits::create (i, f, this));

      if (!this->Orientation_)
      {
        this->Orientation_.set (::std::move (r));
        continue;
      }
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Shape_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Shape",
      "");
  }
}

Geometry* Geometry::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Geometry (*this, f, c);
}

Geometry& Geometry::
operator= (const Geometry& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Shape_ = x.Shape_;
    this->Dimensions_ = x.Dimensions_;
    this->Orientation_ = x.Orientation_;
    this->Notes_ = x.Notes_;
  }

  return *this;
}

Geometry::
~Geometry ()
{
}

// Glossary
//

Glossary::
Glossary ()
: ::xml_schema::type (),
  Term_ (this)
{
}

Glossary::
Glossary (const Glossary& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Term_ (x.Term_, f, this)
{
}

Glossary::
Glossary (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Term_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Glossary::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Term
    //
    if (n.name () == "Term" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Term_type > r (
        Term_traits::create (i, f, this));

      this->Term_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

Glossary* Glossary::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Glossary (*this, f, c);
}

Glossary& Glossary::
operator= (const Glossary& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Term_ = x.Term_;
  }

  return *this;
}

Glossary::
~Glossary ()
{
}

// GlossaryTerm
//

GlossaryTerm::
GlossaryTerm (const Name_type& Name,
              const Definition_type& Definition)
: ::xml_schema::type (),
  Name_ (Name, this),
  Definition_ (Definition, this),
  Abbreviation_ (this),
  Synonym_ (this),
  Notes_ (this)
{
}

GlossaryTerm::
GlossaryTerm (::std::unique_ptr< Name_type > Name,
              const Definition_type& Definition)
: ::xml_schema::type (),
  Name_ (std::move (Name), this),
  Definition_ (Definition, this),
  Abbreviation_ (this),
  Synonym_ (this),
  Notes_ (this)
{
}

GlossaryTerm::
GlossaryTerm (const GlossaryTerm& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this),
  Definition_ (x.Definition_, f, this),
  Abbreviation_ (x.Abbreviation_, f, this),
  Synonym_ (x.Synonym_, f, this),
  Notes_ (x.Notes_, f, this)
{
}

GlossaryTerm::
GlossaryTerm (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this),
  Definition_ (this),
  Abbreviation_ (this),
  Synonym_ (this),
  Notes_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void GlossaryTerm::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!Name_.present ())
      {
        this->Name_.set (::std::move (r));
        continue;
      }
    }

    // Definition
    //
    if (n.name () == "Definition" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Definition_type > r (
        Definition_traits::create (i, f, this));

      if (!Definition_.present ())
      {
        this->Definition_.set (::std::move (r));
        continue;
      }
    }

    // Abbreviation
    //
    if (n.name () == "Abbreviation" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Abbreviation_type > r (
        Abbreviation_traits::create (i, f, this));

      this->Abbreviation_.push_back (::std::move (r));
      continue;
    }

    // Synonym
    //
    if (n.name () == "Synonym" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Synonym_type > r (
        Synonym_traits::create (i, f, this));

      this->Synonym_.push_back (::std::move (r));
      continue;
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Name",
      "");
  }

  if (!Definition_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Definition",
      "");
  }
}

GlossaryTerm* GlossaryTerm::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GlossaryTerm (*this, f, c);
}

GlossaryTerm& GlossaryTerm::
operator= (const GlossaryTerm& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
    this->Definition_ = x.Definition_;
    this->Abbreviation_ = x.Abbreviation_;
    this->Synonym_ = x.Synonym_;
    this->Notes_ = x.Notes_;
  }

  return *this;
}

GlossaryTerm::
~GlossaryTerm ()
{
}

// Graphs
//

Graphs::
Graphs ()
: ::xml_schema::type (),
  Graph_ (this)
{
}

Graphs::
Graphs (const Graphs& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Graph_ (x.Graph_, f, this)
{
}

Graphs::
Graphs (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Graph_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Graphs::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Graph
    //
    if (n.name () == "Graph" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Graph_type > r (
        Graph_traits::create (i, f, this));

      this->Graph_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

Graphs* Graphs::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Graphs (*this, f, c);
}

Graphs& Graphs::
operator= (const Graphs& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Graph_ = x.Graph_;
  }

  return *this;
}

Graphs::
~Graphs ()
{
}

// Material
//

Material::
Material (const BulkDetails_type& BulkDetails)
: ::xml_schema::type (),
  BulkDetails_ (BulkDetails, this),
  ComponentDetails_ (this),
  Graphs_ (this),
  Glossary_ (this),
  id_ (this),
  layers_ (this),
  local_frame_of_reference_ (this)
{
}

Material::
Material (::std::unique_ptr< BulkDetails_type > BulkDetails)
: ::xml_schema::type (),
  BulkDetails_ (std::move (BulkDetails), this),
  ComponentDetails_ (this),
  Graphs_ (this),
  Glossary_ (this),
  id_ (this),
  layers_ (this),
  local_frame_of_reference_ (this)
{
}

Material::
Material (const Material& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  BulkDetails_ (x.BulkDetails_, f, this),
  ComponentDetails_ (x.ComponentDetails_, f, this),
  Graphs_ (x.Graphs_, f, this),
  Glossary_ (x.Glossary_, f, this),
  id_ (x.id_, f, this),
  layers_ (x.layers_, f, this),
  local_frame_of_reference_ (x.local_frame_of_reference_, f, this)
{
}

Material::
Material (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  BulkDetails_ (this),
  ComponentDetails_ (this),
  Graphs_ (this),
  Glossary_ (this),
  id_ (this),
  layers_ (this),
  local_frame_of_reference_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Material::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // BulkDetails
    //
    if (n.name () == "BulkDetails" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< BulkDetails_type > r (
        BulkDetails_traits::create (i, f, this));

      if (!BulkDetails_.present ())
      {
        this->BulkDetails_.set (::std::move (r));
        continue;
      }
    }

    // ComponentDetails
    //
    if (n.name () == "ComponentDetails" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ComponentDetails_type > r (
        ComponentDetails_traits::create (i, f, this));

      this->ComponentDetails_.push_back (::std::move (r));
      continue;
    }

    // Graphs
    //
    if (n.name () == "Graphs" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Graphs_type > r (
        Graphs_traits::create (i, f, this));

      if (!this->Graphs_)
      {
        this->Graphs_.set (::std::move (r));
        continue;
      }
    }

    // Glossary
    //
    if (n.name () == "Glossary" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Glossary_type > r (
        Glossary_traits::create (i, f, this));

      if (!this->Glossary_)
      {
        this->Glossary_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!BulkDetails_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "BulkDetails",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "layers" && n.namespace_ ().empty ())
    {
      this->layers_.set (layers_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "local_frame_of_reference" && n.namespace_ ().empty ())
    {
      this->local_frame_of_reference_.set (local_frame_of_reference_traits::create (i, f, this));
      continue;
    }
  }
}

Material* Material::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Material (*this, f, c);
}

Material& Material::
operator= (const Material& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->BulkDetails_ = x.BulkDetails_;
    this->ComponentDetails_ = x.ComponentDetails_;
    this->Graphs_ = x.Graphs_;
    this->Glossary_ = x.Glossary_;
    this->id_ = x.id_;
    this->layers_ = x.layers_;
    this->local_frame_of_reference_ = x.local_frame_of_reference_;
  }

  return *this;
}

Material::
~Material ()
{
}

// Metadata
//

Metadata::
Metadata ()
: ::xml_schema::type (),
  AuthorityDetails_ (this),
  DataSourceDetails_ (this),
  MeasurementTechniqueDetails_ (this),
  ParameterDetails_ (this),
  PropertyDetails_ (this),
  SourceDetails_ (this),
  SpecimenDetails_ (this),
  TestConditionDetails_ (this)
{
}

Metadata::
Metadata (const Metadata& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  AuthorityDetails_ (x.AuthorityDetails_, f, this),
  DataSourceDetails_ (x.DataSourceDetails_, f, this),
  MeasurementTechniqueDetails_ (x.MeasurementTechniqueDetails_, f, this),
  ParameterDetails_ (x.ParameterDetails_, f, this),
  PropertyDetails_ (x.PropertyDetails_, f, this),
  SourceDetails_ (x.SourceDetails_, f, this),
  SpecimenDetails_ (x.SpecimenDetails_, f, this),
  TestConditionDetails_ (x.TestConditionDetails_, f, this)
{
}

Metadata::
Metadata (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  AuthorityDetails_ (this),
  DataSourceDetails_ (this),
  MeasurementTechniqueDetails_ (this),
  ParameterDetails_ (this),
  PropertyDetails_ (this),
  SourceDetails_ (this),
  SpecimenDetails_ (this),
  TestConditionDetails_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Metadata::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AuthorityDetails
    //
    if (n.name () == "AuthorityDetails" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< AuthorityDetails_type > r (
        AuthorityDetails_traits::create (i, f, this));

      this->AuthorityDetails_.push_back (::std::move (r));
      continue;
    }

    // DataSourceDetails
    //
    if (n.name () == "DataSourceDetails" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< DataSourceDetails_type > r (
        DataSourceDetails_traits::create (i, f, this));

      this->DataSourceDetails_.push_back (::std::move (r));
      continue;
    }

    // MeasurementTechniqueDetails
    //
    if (n.name () == "MeasurementTechniqueDetails" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< MeasurementTechniqueDetails_type > r (
        MeasurementTechniqueDetails_traits::create (i, f, this));

      this->MeasurementTechniqueDetails_.push_back (::std::move (r));
      continue;
    }

    // ParameterDetails
    //
    if (n.name () == "ParameterDetails" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ParameterDetails_type > r (
        ParameterDetails_traits::create (i, f, this));

      this->ParameterDetails_.push_back (::std::move (r));
      continue;
    }

    // PropertyDetails
    //
    if (n.name () == "PropertyDetails" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< PropertyDetails_type > r (
        PropertyDetails_traits::create (i, f, this));

      this->PropertyDetails_.push_back (::std::move (r));
      continue;
    }

    // SourceDetails
    //
    if (n.name () == "SourceDetails" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< SourceDetails_type > r (
        SourceDetails_traits::create (i, f, this));

      this->SourceDetails_.push_back (::std::move (r));
      continue;
    }

    // SpecimenDetails
    //
    if (n.name () == "SpecimenDetails" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< SpecimenDetails_type > r (
        SpecimenDetails_traits::create (i, f, this));

      this->SpecimenDetails_.push_back (::std::move (r));
      continue;
    }

    // TestConditionDetails
    //
    if (n.name () == "TestConditionDetails" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< TestConditionDetails_type > r (
        TestConditionDetails_traits::create (i, f, this));

      this->TestConditionDetails_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

Metadata* Metadata::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Metadata (*this, f, c);
}

Metadata& Metadata::
operator= (const Metadata& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->AuthorityDetails_ = x.AuthorityDetails_;
    this->DataSourceDetails_ = x.DataSourceDetails_;
    this->MeasurementTechniqueDetails_ = x.MeasurementTechniqueDetails_;
    this->ParameterDetails_ = x.ParameterDetails_;
    this->PropertyDetails_ = x.PropertyDetails_;
    this->SourceDetails_ = x.SourceDetails_;
    this->SpecimenDetails_ = x.SpecimenDetails_;
    this->TestConditionDetails_ = x.TestConditionDetails_;
  }

  return *this;
}

Metadata::
~Metadata ()
{
}

// Name
//

Name::
Name ()
: ::xml_schema::string (),
  authority_ (this)
{
}

Name::
Name (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  authority_ (this)
{
}

Name::
Name (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  authority_ (this)
{
}

Name::
Name (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  authority_ (this)
{
}

Name::
Name (const Name& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  authority_ (x.authority_, f, this)
{
}

Name::
Name (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  authority_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Name::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "authority" && n.namespace_ ().empty ())
    {
      this->authority_.set (authority_traits::create (i, f, this));
      continue;
    }
  }
}

Name* Name::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Name (*this, f, c);
}

Name& Name::
operator= (const Name& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->authority_ = x.authority_;
  }

  return *this;
}

Name::
~Name ()
{
}

// Notes
//

Notes::
Notes ()
: ::xml_schema::string ()
{
}

Notes::
Notes (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

Notes::
Notes (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

Notes::
Notes (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

Notes::
Notes (const Notes& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

Notes::
Notes (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

Notes::
Notes (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

Notes::
Notes (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

Notes* Notes::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Notes (*this, f, c);
}

Notes::
~Notes ()
{
}

// ParameterValue
//

ParameterValue::
ParameterValue (const Data_type& Data,
                const parameter_type& parameter,
                const format_type& format)
: ::xml_schema::type (),
  Data_ (Data, this),
  Uncertainty_ (this),
  Qualifier_ (this),
  Notes_ (this),
  parameter_ (parameter, this),
  format_ (format, this)
{
}

ParameterValue::
ParameterValue (::std::unique_ptr< Data_type > Data,
                const parameter_type& parameter,
                const format_type& format)
: ::xml_schema::type (),
  Data_ (std::move (Data), this),
  Uncertainty_ (this),
  Qualifier_ (this),
  Notes_ (this),
  parameter_ (parameter, this),
  format_ (format, this)
{
}

ParameterValue::
ParameterValue (const ParameterValue& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Data_ (x.Data_, f, this),
  Uncertainty_ (x.Uncertainty_, f, this),
  Qualifier_ (x.Qualifier_, f, this),
  Notes_ (x.Notes_, f, this),
  parameter_ (x.parameter_, f, this),
  format_ (x.format_, f, this)
{
}

ParameterValue::
ParameterValue (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Data_ (this),
  Uncertainty_ (this),
  Qualifier_ (this),
  Notes_ (this),
  parameter_ (this),
  format_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void ParameterValue::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Data
    //
    if (n.name () == "Data" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Data_type > r (
        Data_traits::create (i, f, this));

      if (!Data_.present ())
      {
        this->Data_.set (::std::move (r));
        continue;
      }
    }

    // Uncertainty
    //
    if (n.name () == "Uncertainty" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Uncertainty_type > r (
        Uncertainty_traits::create (i, f, this));

      this->Uncertainty_.push_back (::std::move (r));
      continue;
    }

    // Qualifier
    //
    if (n.name () == "Qualifier" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Qualifier_type > r (
        Qualifier_traits::create (i, f, this));

      this->Qualifier_.push_back (::std::move (r));
      continue;
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Data_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Data",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "parameter" && n.namespace_ ().empty ())
    {
      this->parameter_.set (parameter_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "format" && n.namespace_ ().empty ())
    {
      this->format_.set (format_traits::create (i, f, this));
      continue;
    }
  }

  if (!parameter_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "parameter",
      "");
  }

  if (!format_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "format",
      "");
  }
}

ParameterValue* ParameterValue::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParameterValue (*this, f, c);
}

ParameterValue& ParameterValue::
operator= (const ParameterValue& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Data_ = x.Data_;
    this->Uncertainty_ = x.Uncertainty_;
    this->Qualifier_ = x.Qualifier_;
    this->Notes_ = x.Notes_;
    this->parameter_ = x.parameter_;
    this->format_ = x.format_;
  }

  return *this;
}

ParameterValue::
~ParameterValue ()
{
}

// PhaseComposition
//

PhaseComposition::
PhaseComposition (const Name_type& Name)
: ::xml_schema::type (),
  Name_ (Name, this),
  Concentration_ (this),
  PropertyData_ (this),
  Notes_ (this)
{
}

PhaseComposition::
PhaseComposition (::std::unique_ptr< Name_type > Name)
: ::xml_schema::type (),
  Name_ (std::move (Name), this),
  Concentration_ (this),
  PropertyData_ (this),
  Notes_ (this)
{
}

PhaseComposition::
PhaseComposition (const PhaseComposition& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this),
  Concentration_ (x.Concentration_, f, this),
  PropertyData_ (x.PropertyData_, f, this),
  Notes_ (x.Notes_, f, this)
{
}

PhaseComposition::
PhaseComposition (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this),
  Concentration_ (this),
  PropertyData_ (this),
  Notes_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PhaseComposition::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!Name_.present ())
      {
        this->Name_.set (::std::move (r));
        continue;
      }
    }

    // Concentration
    //
    if (n.name () == "Concentration" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Concentration_type > r (
        Concentration_traits::create (i, f, this));

      if (!this->Concentration_)
      {
        this->Concentration_.set (::std::move (r));
        continue;
      }
    }

    // PropertyData
    //
    if (n.name () == "PropertyData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< PropertyData_type > r (
        PropertyData_traits::create (i, f, this));

      this->PropertyData_.push_back (::std::move (r));
      continue;
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Name",
      "");
  }
}

PhaseComposition* PhaseComposition::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PhaseComposition (*this, f, c);
}

PhaseComposition& PhaseComposition::
operator= (const PhaseComposition& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
    this->Concentration_ = x.Concentration_;
    this->PropertyData_ = x.PropertyData_;
    this->Notes_ = x.Notes_;
  }

  return *this;
}

PhaseComposition::
~PhaseComposition ()
{
}

// ProcessingDetails
//

ProcessingDetails::
ProcessingDetails (const Name_type& Name)
: ::xml_schema::type (),
  Name_ (Name, this),
  ParameterValue_ (this),
  Result_ (this),
  Notes_ (this)
{
}

ProcessingDetails::
ProcessingDetails (::std::unique_ptr< Name_type > Name)
: ::xml_schema::type (),
  Name_ (std::move (Name), this),
  ParameterValue_ (this),
  Result_ (this),
  Notes_ (this)
{
}

ProcessingDetails::
ProcessingDetails (const ProcessingDetails& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this),
  ParameterValue_ (x.ParameterValue_, f, this),
  Result_ (x.Result_, f, this),
  Notes_ (x.Notes_, f, this)
{
}

ProcessingDetails::
ProcessingDetails (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this),
  ParameterValue_ (this),
  Result_ (this),
  Notes_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ProcessingDetails::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!Name_.present ())
      {
        this->Name_.set (::std::move (r));
        continue;
      }
    }

    // ParameterValue
    //
    if (n.name () == "ParameterValue" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ParameterValue_type > r (
        ParameterValue_traits::create (i, f, this));

      this->ParameterValue_.push_back (::std::move (r));
      continue;
    }

    // Result
    //
    if (n.name () == "Result" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Result_type > r (
        Result_traits::create (i, f, this));

      if (!this->Result_)
      {
        this->Result_.set (::std::move (r));
        continue;
      }
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Name",
      "");
  }
}

ProcessingDetails* ProcessingDetails::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ProcessingDetails (*this, f, c);
}

ProcessingDetails& ProcessingDetails::
operator= (const ProcessingDetails& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
    this->ParameterValue_ = x.ParameterValue_;
    this->Result_ = x.Result_;
    this->Notes_ = x.Notes_;
  }

  return *this;
}

ProcessingDetails::
~ProcessingDetails ()
{
}

// PropertyData
//

const PropertyData::delimiter_type PropertyData::delimiter_default_value_ (
  ",");

PropertyData::
PropertyData (const Data_type& Data,
              const property_type& property)
: ::xml_schema::type (),
  Data_ (Data, this),
  Uncertainty_ (this),
  Qualifier_ (this),
  ParameterValue_ (this),
  Notes_ (this),
  property_ (property, this),
  technique_ (this),
  source_ (this),
  specimen_ (this),
  test_ (this),
  delimiter_ (delimiter_default_value (), this),
  quote_ (this)
{
}

PropertyData::
PropertyData (::std::unique_ptr< Data_type > Data,
              const property_type& property)
: ::xml_schema::type (),
  Data_ (std::move (Data), this),
  Uncertainty_ (this),
  Qualifier_ (this),
  ParameterValue_ (this),
  Notes_ (this),
  property_ (property, this),
  technique_ (this),
  source_ (this),
  specimen_ (this),
  test_ (this),
  delimiter_ (delimiter_default_value (), this),
  quote_ (this)
{
}

PropertyData::
PropertyData (const PropertyData& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Data_ (x.Data_, f, this),
  Uncertainty_ (x.Uncertainty_, f, this),
  Qualifier_ (x.Qualifier_, f, this),
  ParameterValue_ (x.ParameterValue_, f, this),
  Notes_ (x.Notes_, f, this),
  property_ (x.property_, f, this),
  technique_ (x.technique_, f, this),
  source_ (x.source_, f, this),
  specimen_ (x.specimen_, f, this),
  test_ (x.test_, f, this),
  delimiter_ (x.delimiter_, f, this),
  quote_ (x.quote_, f, this)
{
}

PropertyData::
PropertyData (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Data_ (this),
  Uncertainty_ (this),
  Qualifier_ (this),
  ParameterValue_ (this),
  Notes_ (this),
  property_ (this),
  technique_ (this),
  source_ (this),
  specimen_ (this),
  test_ (this),
  delimiter_ (this),
  quote_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void PropertyData::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Data
    //
    if (n.name () == "Data" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Data_type > r (
        Data_traits::create (i, f, this));

      if (!Data_.present ())
      {
        this->Data_.set (::std::move (r));
        continue;
      }
    }

    // Uncertainty
    //
    if (n.name () == "Uncertainty" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Uncertainty_type > r (
        Uncertainty_traits::create (i, f, this));

      this->Uncertainty_.push_back (::std::move (r));
      continue;
    }

    // Qualifier
    //
    if (n.name () == "Qualifier" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Qualifier_type > r (
        Qualifier_traits::create (i, f, this));

      this->Qualifier_.push_back (::std::move (r));
      continue;
    }

    // ParameterValue
    //
    if (n.name () == "ParameterValue" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ParameterValue_type > r (
        ParameterValue_traits::create (i, f, this));

      this->ParameterValue_.push_back (::std::move (r));
      continue;
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Data_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Data",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "property" && n.namespace_ ().empty ())
    {
      this->property_.set (property_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "technique" && n.namespace_ ().empty ())
    {
      this->technique_.set (technique_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "source" && n.namespace_ ().empty ())
    {
      this->source_.set (source_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "specimen" && n.namespace_ ().empty ())
    {
      this->specimen_.set (specimen_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "test" && n.namespace_ ().empty ())
    {
      this->test_.set (test_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "delimiter" && n.namespace_ ().empty ())
    {
      this->delimiter_.set (delimiter_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "quote" && n.namespace_ ().empty ())
    {
      this->quote_.set (quote_traits::create (i, f, this));
      continue;
    }
  }

  if (!property_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "property",
      "");
  }

  if (!delimiter_.present ())
  {
    this->delimiter_.set (delimiter_default_value ());
  }
}

PropertyData* PropertyData::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PropertyData (*this, f, c);
}

PropertyData& PropertyData::
operator= (const PropertyData& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Data_ = x.Data_;
    this->Uncertainty_ = x.Uncertainty_;
    this->Qualifier_ = x.Qualifier_;
    this->ParameterValue_ = x.ParameterValue_;
    this->Notes_ = x.Notes_;
    this->property_ = x.property_;
    this->technique_ = x.technique_;
    this->source_ = x.source_;
    this->specimen_ = x.specimen_;
    this->test_ = x.test_;
    this->delimiter_ = x.delimiter_;
    this->quote_ = x.quote_;
  }

  return *this;
}

PropertyData::
~PropertyData ()
{
}

// Qualifier
//

Qualifier::
Qualifier ()
: ::xml_schema::string ()
{
}

Qualifier::
Qualifier (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

Qualifier::
Qualifier (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

Qualifier::
Qualifier (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

Qualifier::
Qualifier (const Qualifier& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

Qualifier::
Qualifier (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

Qualifier::
Qualifier (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

Qualifier::
Qualifier (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

Qualifier* Qualifier::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Qualifier (*this, f, c);
}

Qualifier::
~Qualifier ()
{
}

// Relationship
//

Relationship::
Relationship ()
: ::xml_schema::string ()
{
}

Relationship::
Relationship (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

Relationship::
Relationship (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

Relationship::
Relationship (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

Relationship::
Relationship (const Relationship& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

Relationship::
Relationship (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

Relationship::
Relationship (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

Relationship::
Relationship (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

Relationship* Relationship::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Relationship (*this, f, c);
}

Relationship::
~Relationship ()
{
}

// Source
//

Source::
Source ()
: ::xml_schema::type (),
  source_ (this)
{
}

Source::
Source (const Source& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  source_ (x.source_, f, this)
{
}

Source::
Source (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  source_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Source::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "source" && n.namespace_ ().empty ())
    {
      this->source_.set (source_traits::create (i, f, this));
      continue;
    }
  }
}

Source* Source::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Source (*this, f, c);
}

Source& Source::
operator= (const Source& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->source_ = x.source_;
  }

  return *this;
}

Source::
~Source ()
{
}

// Specification
//

Specification::
Specification ()
: ::xml_schema::string (),
  authority_ (this)
{
}

Specification::
Specification (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  authority_ (this)
{
}

Specification::
Specification (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  authority_ (this)
{
}

Specification::
Specification (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  authority_ (this)
{
}

Specification::
Specification (const Specification& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  authority_ (x.authority_, f, this)
{
}

Specification::
Specification (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  authority_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Specification::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "authority" && n.namespace_ ().empty ())
    {
      this->authority_.set (authority_traits::create (i, f, this));
      continue;
    }
  }
}

Specification* Specification::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Specification (*this, f, c);
}

Specification& Specification::
operator= (const Specification& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->authority_ = x.authority_;
  }

  return *this;
}

Specification::
~Specification ()
{
}

// Uncertainty
//

const Uncertainty::Scale_type Uncertainty::Scale_default_value_ (
  "Linear");

const Uncertainty::DistributionType_type Uncertainty::DistributionType_default_value_ (
  "Normal/Gaussian");

Uncertainty::
Uncertainty (const Value_type& Value)
: ::xml_schema::type (),
  Value_ (Value, this),
  Units_ (this),
  Unitless_ (this),
  Notes_ (this),
  Scale_ (this),
  DistributionType_ (DistributionType_default_value (), this),
  Num_Std_Dev_ (Num_Std_Dev_default_value (), this),
  Percentile_ (this),
  ConfidenceLevel_ (this)
{
}

Uncertainty::
Uncertainty (::std::unique_ptr< Value_type > Value)
: ::xml_schema::type (),
  Value_ (std::move (Value), this),
  Units_ (this),
  Unitless_ (this),
  Notes_ (this),
  Scale_ (this),
  DistributionType_ (DistributionType_default_value (), this),
  Num_Std_Dev_ (Num_Std_Dev_default_value (), this),
  Percentile_ (this),
  ConfidenceLevel_ (this)
{
}

Uncertainty::
Uncertainty (const Uncertainty& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Value_ (x.Value_, f, this),
  Units_ (x.Units_, f, this),
  Unitless_ (x.Unitless_, f, this),
  Notes_ (x.Notes_, f, this),
  Scale_ (x.Scale_, f, this),
  DistributionType_ (x.DistributionType_, f, this),
  Num_Std_Dev_ (x.Num_Std_Dev_, f, this),
  Percentile_ (x.Percentile_, f, this),
  ConfidenceLevel_ (x.ConfidenceLevel_, f, this)
{
}

Uncertainty::
Uncertainty (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Value_ (this),
  Units_ (this),
  Unitless_ (this),
  Notes_ (this),
  Scale_ (this),
  DistributionType_ (this),
  Num_Std_Dev_ (this),
  Percentile_ (this),
  ConfidenceLevel_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Uncertainty::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Value
    //
    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Value_type > r (
        Value_traits::create (i, f, this));

      if (!Value_.present ())
      {
        this->Value_.set (::std::move (r));
        continue;
      }
    }

    // Units
    //
    if (n.name () == "Units" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Units_type > r (
        Units_traits::create (i, f, this));

      if (!this->Units_)
      {
        this->Units_.set (::std::move (r));
        continue;
      }
    }

    // Unitless
    //
    if (n.name () == "Unitless" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Unitless_type > r (
        Unitless_traits::create (i, f, this));

      if (!this->Unitless_)
      {
        this->Unitless_.set (::std::move (r));
        continue;
      }
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    // Scale
    //
    if (n.name () == "Scale" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Scale_type > r (
        Scale_traits::create (i, f, this));

      if (!this->Scale_)
      {
        this->Scale_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Value",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "DistributionType" && n.namespace_ ().empty ())
    {
      this->DistributionType_.set (DistributionType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Num_Std_Dev" && n.namespace_ ().empty ())
    {
      this->Num_Std_Dev_.set (Num_Std_Dev_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Percentile" && n.namespace_ ().empty ())
    {
      this->Percentile_.set (Percentile_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ConfidenceLevel" && n.namespace_ ().empty ())
    {
      this->ConfidenceLevel_.set (ConfidenceLevel_traits::create (i, f, this));
      continue;
    }
  }

  if (!DistributionType_.present ())
  {
    this->DistributionType_.set (DistributionType_default_value ());
  }

  if (!Num_Std_Dev_.present ())
  {
    this->Num_Std_Dev_.set (Num_Std_Dev_default_value ());
  }
}

Uncertainty* Uncertainty::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Uncertainty (*this, f, c);
}

Uncertainty& Uncertainty::
operator= (const Uncertainty& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Value_ = x.Value_;
    this->Units_ = x.Units_;
    this->Unitless_ = x.Unitless_;
    this->Notes_ = x.Notes_;
    this->Scale_ = x.Scale_;
    this->DistributionType_ = x.DistributionType_;
    this->Num_Std_Dev_ = x.Num_Std_Dev_;
    this->Percentile_ = x.Percentile_;
    this->ConfidenceLevel_ = x.ConfidenceLevel_;
  }

  return *this;
}

Uncertainty::
~Uncertainty ()
{
}

// Unit
//

Unit::
Unit ()
: ::xml_schema::type (),
  Name_ (this),
  Currency_ (this),
  power_ (this),
  description_ (this)
{
}

Unit::
Unit (const Unit& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this),
  Currency_ (x.Currency_, f, this),
  power_ (x.power_, f, this),
  description_ (x.description_, f, this)
{
}

Unit::
Unit (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this),
  Currency_ (this),
  power_ (this),
  description_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Unit::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!this->Name_)
      {
        this->Name_.set (::std::move (r));
        continue;
      }
    }

    // Currency
    //
    if (n.name () == "Currency" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Currency_type > r (
        Currency_traits::create (i, f, this));

      if (!this->Currency_)
      {
        this->Currency_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "power" && n.namespace_ ().empty ())
    {
      this->power_.set (power_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "description" && n.namespace_ ().empty ())
    {
      this->description_.set (description_traits::create (i, f, this));
      continue;
    }
  }
}

Unit* Unit::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Unit (*this, f, c);
}

Unit& Unit::
operator= (const Unit& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
    this->Currency_ = x.Currency_;
    this->power_ = x.power_;
    this->description_ = x.description_;
  }

  return *this;
}

Unit::
~Unit ()
{
}

// Unitless
//

Unitless::
Unitless ()
: ::xml_schema::type ()
{
}

Unitless::
Unitless (const Unitless& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c)
{
}

Unitless::
Unitless (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f, c)
{
}

Unitless::
Unitless (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (a, f, c)
{
}

Unitless::
Unitless (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (s, e, f, c)
{
}

Unitless* Unitless::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Unitless (*this, f, c);
}

Unitless::
~Unitless ()
{
}

// Units
//

Units::
Units ()
: ::xml_schema::type (),
  Unit_ (this),
  system_ (this),
  factor_ (this),
  name_ (this),
  description_ (this)
{
}

Units::
Units (const Units& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Unit_ (x.Unit_, f, this),
  system_ (x.system_, f, this),
  factor_ (x.factor_, f, this),
  name_ (x.name_, f, this),
  description_ (x.description_, f, this)
{
}

Units::
Units (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Unit_ (this),
  system_ (this),
  factor_ (this),
  name_ (this),
  description_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Units::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Unit
    //
    if (n.name () == "Unit" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Unit_type > r (
        Unit_traits::create (i, f, this));

      this->Unit_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "system" && n.namespace_ ().empty ())
    {
      this->system_.set (system_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "factor" && n.namespace_ ().empty ())
    {
      this->factor_.set (factor_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "description" && n.namespace_ ().empty ())
    {
      this->description_.set (description_traits::create (i, f, this));
      continue;
    }
  }
}

Units* Units::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Units (*this, f, c);
}

Units& Units::
operator= (const Units& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Unit_ = x.Unit_;
    this->system_ = x.system_;
    this->factor_ = x.factor_;
    this->name_ = x.name_;
    this->description_ = x.description_;
  }

  return *this;
}

Units::
~Units ()
{
}

// Value
//

Value::
Value (const format_type& format)
: ::xml_schema::string (),
  format_ (format, this)
{
}

Value::
Value (const char* _xsd_string_base,
       const format_type& format)
: ::xml_schema::string (_xsd_string_base),
  format_ (format, this)
{
}

Value::
Value (const ::std::string& _xsd_string_base,
       const format_type& format)
: ::xml_schema::string (_xsd_string_base),
  format_ (format, this)
{
}

Value::
Value (const ::xml_schema::string& _xsd_string_base,
       const format_type& format)
: ::xml_schema::string (_xsd_string_base),
  format_ (format, this)
{
}

Value::
Value (const Value& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  format_ (x.format_, f, this)
{
}

Value::
Value (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  format_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Value::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "format" && n.namespace_ ().empty ())
    {
      this->format_.set (format_traits::create (i, f, this));
      continue;
    }
  }

  if (!format_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "format",
      "");
  }
}

Value* Value::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Value (*this, f, c);
}

Value& Value::
operator= (const Value& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->format_ = x.format_;
  }

  return *this;
}

Value::
~Value ()
{
}

// AuthorityDetails
//

AuthorityDetails::
AuthorityDetails (const Name_type& Name,
                  const id_type& id)
: ::xml_schema::type (),
  Name_ (Name, this),
  Notes_ (this),
  id_ (id, this)
{
}

AuthorityDetails::
AuthorityDetails (::std::unique_ptr< Name_type > Name,
                  const id_type& id)
: ::xml_schema::type (),
  Name_ (std::move (Name), this),
  Notes_ (this),
  id_ (id, this)
{
}

AuthorityDetails::
AuthorityDetails (const AuthorityDetails& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this),
  Notes_ (x.Notes_, f, this),
  id_ (x.id_, f, this)
{
}

AuthorityDetails::
AuthorityDetails (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this),
  Notes_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void AuthorityDetails::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!Name_.present ())
      {
        this->Name_.set (::std::move (r));
        continue;
      }
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Name",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

AuthorityDetails* AuthorityDetails::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AuthorityDetails (*this, f, c);
}

AuthorityDetails& AuthorityDetails::
operator= (const AuthorityDetails& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
    this->Notes_ = x.Notes_;
    this->id_ = x.id_;
  }

  return *this;
}

AuthorityDetails::
~AuthorityDetails ()
{
}

// DataSourceDetails
//

DataSourceDetails::
DataSourceDetails (const Name_type& Name,
                   const id_type& id)
: ::xml_schema::type (),
  Name_ (Name, this),
  Notes_ (this),
  id_ (id, this),
  type_ (this)
{
}

DataSourceDetails::
DataSourceDetails (::std::unique_ptr< Name_type > Name,
                   const id_type& id)
: ::xml_schema::type (),
  Name_ (std::move (Name), this),
  Notes_ (this),
  id_ (id, this),
  type_ (this)
{
}

DataSourceDetails::
DataSourceDetails (const DataSourceDetails& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this),
  Notes_ (x.Notes_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this)
{
}

DataSourceDetails::
DataSourceDetails (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this),
  Notes_ (this),
  id_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void DataSourceDetails::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!Name_.present ())
      {
        this->Name_.set (::std::move (r));
        continue;
      }
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Name",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

DataSourceDetails* DataSourceDetails::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DataSourceDetails (*this, f, c);
}

DataSourceDetails& DataSourceDetails::
operator= (const DataSourceDetails& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
    this->Notes_ = x.Notes_;
    this->id_ = x.id_;
    this->type_ = x.type_;
  }

  return *this;
}

DataSourceDetails::
~DataSourceDetails ()
{
}

// MeasurementTechniqueDetails
//

MeasurementTechniqueDetails::
MeasurementTechniqueDetails (const Name_type& Name,
                             const id_type& id)
: ::xml_schema::type (),
  Name_ (Name, this),
  Notes_ (this),
  id_ (id, this)
{
}

MeasurementTechniqueDetails::
MeasurementTechniqueDetails (::std::unique_ptr< Name_type > Name,
                             const id_type& id)
: ::xml_schema::type (),
  Name_ (std::move (Name), this),
  Notes_ (this),
  id_ (id, this)
{
}

MeasurementTechniqueDetails::
MeasurementTechniqueDetails (const MeasurementTechniqueDetails& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this),
  Notes_ (x.Notes_, f, this),
  id_ (x.id_, f, this)
{
}

MeasurementTechniqueDetails::
MeasurementTechniqueDetails (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this),
  Notes_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void MeasurementTechniqueDetails::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!Name_.present ())
      {
        this->Name_.set (::std::move (r));
        continue;
      }
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Name",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

MeasurementTechniqueDetails* MeasurementTechniqueDetails::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MeasurementTechniqueDetails (*this, f, c);
}

MeasurementTechniqueDetails& MeasurementTechniqueDetails::
operator= (const MeasurementTechniqueDetails& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
    this->Notes_ = x.Notes_;
    this->id_ = x.id_;
  }

  return *this;
}

MeasurementTechniqueDetails::
~MeasurementTechniqueDetails ()
{
}

// ParameterDetails
//

ParameterDetails::
ParameterDetails (const Name_type& Name,
                  const id_type& id)
: ::xml_schema::type (),
  Name_ (Name, this),
  Units_ (this),
  Unitless_ (this),
  Notes_ (this),
  id_ (id, this)
{
}

ParameterDetails::
ParameterDetails (::std::unique_ptr< Name_type > Name,
                  const id_type& id)
: ::xml_schema::type (),
  Name_ (std::move (Name), this),
  Units_ (this),
  Unitless_ (this),
  Notes_ (this),
  id_ (id, this)
{
}

ParameterDetails::
ParameterDetails (const ParameterDetails& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this),
  Units_ (x.Units_, f, this),
  Unitless_ (x.Unitless_, f, this),
  Notes_ (x.Notes_, f, this),
  id_ (x.id_, f, this)
{
}

ParameterDetails::
ParameterDetails (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this),
  Units_ (this),
  Unitless_ (this),
  Notes_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void ParameterDetails::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!Name_.present ())
      {
        this->Name_.set (::std::move (r));
        continue;
      }
    }

    // Units
    //
    if (n.name () == "Units" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Units_type > r (
        Units_traits::create (i, f, this));

      if (!this->Units_)
      {
        this->Units_.set (::std::move (r));
        continue;
      }
    }

    // Unitless
    //
    if (n.name () == "Unitless" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Unitless_type > r (
        Unitless_traits::create (i, f, this));

      if (!this->Unitless_)
      {
        this->Unitless_.set (::std::move (r));
        continue;
      }
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Name",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

ParameterDetails* ParameterDetails::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParameterDetails (*this, f, c);
}

ParameterDetails& ParameterDetails::
operator= (const ParameterDetails& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
    this->Units_ = x.Units_;
    this->Unitless_ = x.Unitless_;
    this->Notes_ = x.Notes_;
    this->id_ = x.id_;
  }

  return *this;
}

ParameterDetails::
~ParameterDetails ()
{
}

// PropertyDetails
//

PropertyDetails::
PropertyDetails (const Name_type& Name,
                 const id_type& id)
: ::xml_schema::type (),
  Name_ (Name, this),
  Units_ (this),
  Unitless_ (this),
  Notes_ (this),
  id_ (id, this),
  type_ (this)
{
}

PropertyDetails::
PropertyDetails (::std::unique_ptr< Name_type > Name,
                 const id_type& id)
: ::xml_schema::type (),
  Name_ (std::move (Name), this),
  Units_ (this),
  Unitless_ (this),
  Notes_ (this),
  id_ (id, this),
  type_ (this)
{
}

PropertyDetails::
PropertyDetails (const PropertyDetails& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this),
  Units_ (x.Units_, f, this),
  Unitless_ (x.Unitless_, f, this),
  Notes_ (x.Notes_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this)
{
}

PropertyDetails::
PropertyDetails (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this),
  Units_ (this),
  Unitless_ (this),
  Notes_ (this),
  id_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void PropertyDetails::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!Name_.present ())
      {
        this->Name_.set (::std::move (r));
        continue;
      }
    }

    // Units
    //
    if (n.name () == "Units" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Units_type > r (
        Units_traits::create (i, f, this));

      if (!this->Units_)
      {
        this->Units_.set (::std::move (r));
        continue;
      }
    }

    // Unitless
    //
    if (n.name () == "Unitless" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Unitless_type > r (
        Unitless_traits::create (i, f, this));

      if (!this->Unitless_)
      {
        this->Unitless_.set (::std::move (r));
        continue;
      }
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Name",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

PropertyDetails* PropertyDetails::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PropertyDetails (*this, f, c);
}

PropertyDetails& PropertyDetails::
operator= (const PropertyDetails& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
    this->Units_ = x.Units_;
    this->Unitless_ = x.Unitless_;
    this->Notes_ = x.Notes_;
    this->id_ = x.id_;
    this->type_ = x.type_;
  }

  return *this;
}

PropertyDetails::
~PropertyDetails ()
{
}

// SourceDetails
//

SourceDetails::
SourceDetails (const Name_type& Name,
               const id_type& id)
: ::xml_schema::type (),
  Name_ (Name, this),
  Notes_ (this),
  id_ (id, this),
  type_ (this)
{
}

SourceDetails::
SourceDetails (::std::unique_ptr< Name_type > Name,
               const id_type& id)
: ::xml_schema::type (),
  Name_ (std::move (Name), this),
  Notes_ (this),
  id_ (id, this),
  type_ (this)
{
}

SourceDetails::
SourceDetails (const SourceDetails& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this),
  Notes_ (x.Notes_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this)
{
}

SourceDetails::
SourceDetails (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this),
  Notes_ (this),
  id_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void SourceDetails::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!Name_.present ())
      {
        this->Name_.set (::std::move (r));
        continue;
      }
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Name",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

SourceDetails* SourceDetails::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SourceDetails (*this, f, c);
}

SourceDetails& SourceDetails::
operator= (const SourceDetails& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
    this->Notes_ = x.Notes_;
    this->id_ = x.id_;
    this->type_ = x.type_;
  }

  return *this;
}

SourceDetails::
~SourceDetails ()
{
}

// SpecimenDetails
//

SpecimenDetails::
SpecimenDetails (const id_type& id)
: ::xml_schema::type (),
  Name_ (this),
  Notes_ (this),
  Geometry_ (this),
  id_ (id, this),
  type_ (this)
{
}

SpecimenDetails::
SpecimenDetails (const SpecimenDetails& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this),
  Notes_ (x.Notes_, f, this),
  Geometry_ (x.Geometry_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this)
{
}

SpecimenDetails::
SpecimenDetails (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this),
  Notes_ (this),
  Geometry_ (this),
  id_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void SpecimenDetails::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!this->Name_)
      {
        this->Name_.set (::std::move (r));
        continue;
      }
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    // Geometry
    //
    if (n.name () == "Geometry" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Geometry_type > r (
        Geometry_traits::create (i, f, this));

      if (!this->Geometry_)
      {
        this->Geometry_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

SpecimenDetails* SpecimenDetails::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SpecimenDetails (*this, f, c);
}

SpecimenDetails& SpecimenDetails::
operator= (const SpecimenDetails& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
    this->Notes_ = x.Notes_;
    this->Geometry_ = x.Geometry_;
    this->id_ = x.id_;
    this->type_ = x.type_;
  }

  return *this;
}

SpecimenDetails::
~SpecimenDetails ()
{
}

// TestConditionDetails
//

TestConditionDetails::
TestConditionDetails (const id_type& id)
: ::xml_schema::type (),
  ParameterValue_ (this),
  Notes_ (this),
  id_ (id, this)
{
}

TestConditionDetails::
TestConditionDetails (const TestConditionDetails& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ParameterValue_ (x.ParameterValue_, f, this),
  Notes_ (x.Notes_, f, this),
  id_ (x.id_, f, this)
{
}

TestConditionDetails::
TestConditionDetails (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ParameterValue_ (this),
  Notes_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void TestConditionDetails::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ParameterValue
    //
    if (n.name () == "ParameterValue" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ParameterValue_type > r (
        ParameterValue_traits::create (i, f, this));

      this->ParameterValue_.push_back (::std::move (r));
      continue;
    }

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!this->Notes_)
      {
        this->Notes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

TestConditionDetails* TestConditionDetails::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TestConditionDetails (*this, f, c);
}

TestConditionDetails& TestConditionDetails::
operator= (const TestConditionDetails& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ParameterValue_ = x.ParameterValue_;
    this->Notes_ = x.Notes_;
    this->id_ = x.id_;
  }

  return *this;
}

TestConditionDetails::
~TestConditionDetails ()
{
}

// ChemicalElementSymbol
//

ChemicalElementSymbol::
ChemicalElementSymbol (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_ChemicalElementSymbol_convert ();
}

ChemicalElementSymbol::
ChemicalElementSymbol (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_ChemicalElementSymbol_convert ();
}

ChemicalElementSymbol::
ChemicalElementSymbol (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_ChemicalElementSymbol_convert ();
}

ChemicalElementSymbol* ChemicalElementSymbol::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ChemicalElementSymbol (*this, f, c);
}

ChemicalElementSymbol::value ChemicalElementSymbol::
_xsd_ChemicalElementSymbol_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ChemicalElementSymbol_literals_);
  const value* i (::std::lower_bound (
                    _xsd_ChemicalElementSymbol_indexes_,
                    _xsd_ChemicalElementSymbol_indexes_ + 115,
                    *this,
                    c));

  if (i == _xsd_ChemicalElementSymbol_indexes_ + 115 || _xsd_ChemicalElementSymbol_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ChemicalElementSymbol::
_xsd_ChemicalElementSymbol_literals_[115] =
{
  "H",
  "He",
  "Li",
  "Be",
  "B",
  "C",
  "N",
  "O",
  "F",
  "Ne",
  "Na",
  "Mg",
  "Al",
  "Si",
  "P",
  "S",
  "Cl",
  "Ar",
  "K",
  "Ca",
  "Sc",
  "Ti",
  "V",
  "Cr",
  "Mn",
  "Fe",
  "Co",
  "Ni",
  "Cu",
  "Zn",
  "Ga",
  "Ge",
  "As",
  "Se",
  "Br",
  "Kr",
  "Rb",
  "Sr",
  "Y",
  "Zr",
  "Nb",
  "Mo",
  "Tc",
  "Ru",
  "Rh",
  "Pd",
  "Ag",
  "Cd",
  "In",
  "Sn",
  "Sb",
  "Te",
  "I",
  "Xe",
  "Cs",
  "Ba",
  "La",
  "Ce",
  "Pr",
  "Nd",
  "Pm",
  "Sm",
  "Eu",
  "Gd",
  "Tb",
  "Dy",
  "Ho",
  "Er",
  "Tm",
  "Yb",
  "Lu",
  "Hf",
  "Ta",
  "W",
  "Re",
  "Os",
  "Ir",
  "Pt",
  "Au",
  "Hg",
  "Tl",
  "Pb",
  "Bi",
  "Po",
  "At",
  "Rn",
  "Fr",
  "Ra",
  "Ac",
  "Th",
  "Pa",
  "U",
  "Np",
  "Pu",
  "Am",
  "Cm",
  "Bk",
  "Cf",
  "Es",
  "Fm",
  "Md",
  "No",
  "Lr",
  "Rf",
  "Db",
  "Sg",
  "Bh",
  "Hs",
  "Mt",
  "Uun",
  "Uuu",
  "Uub",
  "Uuq",
  "Uuh",
  "Uuo"
};

const ChemicalElementSymbol::value ChemicalElementSymbol::
_xsd_ChemicalElementSymbol_indexes_[115] =
{
  ::ChemicalElementSymbol::Ac,
  ::ChemicalElementSymbol::Ag,
  ::ChemicalElementSymbol::Al,
  ::ChemicalElementSymbol::Am,
  ::ChemicalElementSymbol::Ar,
  ::ChemicalElementSymbol::As,
  ::ChemicalElementSymbol::At,
  ::ChemicalElementSymbol::Au,
  ::ChemicalElementSymbol::B,
  ::ChemicalElementSymbol::Ba,
  ::ChemicalElementSymbol::Be,
  ::ChemicalElementSymbol::Bh,
  ::ChemicalElementSymbol::Bi,
  ::ChemicalElementSymbol::Bk,
  ::ChemicalElementSymbol::Br,
  ::ChemicalElementSymbol::C,
  ::ChemicalElementSymbol::Ca,
  ::ChemicalElementSymbol::Cd,
  ::ChemicalElementSymbol::Ce,
  ::ChemicalElementSymbol::Cf,
  ::ChemicalElementSymbol::Cl,
  ::ChemicalElementSymbol::Cm,
  ::ChemicalElementSymbol::Co,
  ::ChemicalElementSymbol::Cr,
  ::ChemicalElementSymbol::Cs,
  ::ChemicalElementSymbol::Cu,
  ::ChemicalElementSymbol::Db,
  ::ChemicalElementSymbol::Dy,
  ::ChemicalElementSymbol::Er,
  ::ChemicalElementSymbol::Es,
  ::ChemicalElementSymbol::Eu,
  ::ChemicalElementSymbol::F,
  ::ChemicalElementSymbol::Fe,
  ::ChemicalElementSymbol::Fm,
  ::ChemicalElementSymbol::Fr,
  ::ChemicalElementSymbol::Ga,
  ::ChemicalElementSymbol::Gd,
  ::ChemicalElementSymbol::Ge,
  ::ChemicalElementSymbol::H,
  ::ChemicalElementSymbol::He,
  ::ChemicalElementSymbol::Hf,
  ::ChemicalElementSymbol::Hg,
  ::ChemicalElementSymbol::Ho,
  ::ChemicalElementSymbol::Hs,
  ::ChemicalElementSymbol::I,
  ::ChemicalElementSymbol::In,
  ::ChemicalElementSymbol::Ir,
  ::ChemicalElementSymbol::K,
  ::ChemicalElementSymbol::Kr,
  ::ChemicalElementSymbol::La,
  ::ChemicalElementSymbol::Li,
  ::ChemicalElementSymbol::Lr,
  ::ChemicalElementSymbol::Lu,
  ::ChemicalElementSymbol::Md,
  ::ChemicalElementSymbol::Mg,
  ::ChemicalElementSymbol::Mn,
  ::ChemicalElementSymbol::Mo,
  ::ChemicalElementSymbol::Mt,
  ::ChemicalElementSymbol::N,
  ::ChemicalElementSymbol::Na,
  ::ChemicalElementSymbol::Nb,
  ::ChemicalElementSymbol::Nd,
  ::ChemicalElementSymbol::Ne,
  ::ChemicalElementSymbol::Ni,
  ::ChemicalElementSymbol::No,
  ::ChemicalElementSymbol::Np,
  ::ChemicalElementSymbol::O,
  ::ChemicalElementSymbol::Os,
  ::ChemicalElementSymbol::P,
  ::ChemicalElementSymbol::Pa,
  ::ChemicalElementSymbol::Pb,
  ::ChemicalElementSymbol::Pd,
  ::ChemicalElementSymbol::Pm,
  ::ChemicalElementSymbol::Po,
  ::ChemicalElementSymbol::Pr,
  ::ChemicalElementSymbol::Pt,
  ::ChemicalElementSymbol::Pu,
  ::ChemicalElementSymbol::Ra,
  ::ChemicalElementSymbol::Rb,
  ::ChemicalElementSymbol::Re,
  ::ChemicalElementSymbol::Rf,
  ::ChemicalElementSymbol::Rh,
  ::ChemicalElementSymbol::Rn,
  ::ChemicalElementSymbol::Ru,
  ::ChemicalElementSymbol::S,
  ::ChemicalElementSymbol::Sb,
  ::ChemicalElementSymbol::Sc,
  ::ChemicalElementSymbol::Se,
  ::ChemicalElementSymbol::Sg,
  ::ChemicalElementSymbol::Si,
  ::ChemicalElementSymbol::Sm,
  ::ChemicalElementSymbol::Sn,
  ::ChemicalElementSymbol::Sr,
  ::ChemicalElementSymbol::Ta,
  ::ChemicalElementSymbol::Tb,
  ::ChemicalElementSymbol::Tc,
  ::ChemicalElementSymbol::Te,
  ::ChemicalElementSymbol::Th,
  ::ChemicalElementSymbol::Ti,
  ::ChemicalElementSymbol::Tl,
  ::ChemicalElementSymbol::Tm,
  ::ChemicalElementSymbol::U,
  ::ChemicalElementSymbol::Uub,
  ::ChemicalElementSymbol::Uuh,
  ::ChemicalElementSymbol::Uun,
  ::ChemicalElementSymbol::Uuo,
  ::ChemicalElementSymbol::Uuq,
  ::ChemicalElementSymbol::Uuu,
  ::ChemicalElementSymbol::V,
  ::ChemicalElementSymbol::W,
  ::ChemicalElementSymbol::Xe,
  ::ChemicalElementSymbol::Y,
  ::ChemicalElementSymbol::Yb,
  ::ChemicalElementSymbol::Zn,
  ::ChemicalElementSymbol::Zr
};

// CurrencyCode
//

CurrencyCode::
CurrencyCode (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_CurrencyCode_convert ();
}

CurrencyCode::
CurrencyCode (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_CurrencyCode_convert ();
}

CurrencyCode::
CurrencyCode (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_CurrencyCode_convert ();
}

CurrencyCode* CurrencyCode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CurrencyCode (*this, f, c);
}

CurrencyCode::value CurrencyCode::
_xsd_CurrencyCode_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CurrencyCode_literals_);
  const value* i (::std::lower_bound (
                    _xsd_CurrencyCode_indexes_,
                    _xsd_CurrencyCode_indexes_ + 182,
                    *this,
                    c));

  if (i == _xsd_CurrencyCode_indexes_ + 182 || _xsd_CurrencyCode_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const CurrencyCode::
_xsd_CurrencyCode_literals_[182] =
{
  "AFA",
  "ALL",
  "AMD",
  "ANG",
  "AOA",
  "ARS",
  "ATS",
  "AUD",
  "AWG",
  "AZM",
  "BAM",
  "BBD",
  "BDT",
  "BEF",
  "BGL",
  "BGN",
  "BHD",
  "BIF",
  "BMD",
  "BND",
  "BOB",
  "BOV",
  "BRL",
  "BSD",
  "BTN",
  "BWP",
  "BYB",
  "BYR",
  "BZD",
  "CAD",
  "CDF",
  "CHF",
  "CLF",
  "CLP",
  "CNY",
  "COP",
  "CRC",
  "CUP",
  "CVE",
  "CYP",
  "CZK",
  "DEM",
  "DJF",
  "DKK",
  "DOP",
  "DZD",
  "EEK",
  "EGP",
  "ERN",
  "ESP",
  "ETB",
  "EUR",
  "FIM",
  "FJD",
  "FKP",
  "FRF",
  "GBP",
  "GEL",
  "GHC",
  "GIP",
  "GMD",
  "GNF",
  "GRD",
  "GTQ",
  "GWP",
  "GYD",
  "HKD",
  "HNL",
  "HRK",
  "HTG",
  "HUF",
  "IDR",
  "IEP",
  "ILS",
  "INR",
  "IQD",
  "IRR",
  "ISK",
  "ITL",
  "JMD",
  "JOD",
  "JPY",
  "KES",
  "KGS",
  "KHR",
  "KMF",
  "KPW",
  "KRW",
  "KWD",
  "KYD",
  "KZT",
  "LAK",
  "LBP",
  "LKR",
  "LRD",
  "LSL",
  "LTL",
  "LUF",
  "LVL",
  "LYD",
  "MAD",
  "MDL",
  "MGF",
  "MKD",
  "MMK",
  "MNT",
  "MOP",
  "MRO",
  "MTL",
  "MUR",
  "MVR",
  "MWK",
  "MXN",
  "MXV",
  "MYR",
  "MZM",
  "NAD",
  "NGN",
  "NIO",
  "NLG",
  "NOK",
  "NPR",
  "NZD",
  "OMR",
  "PAB",
  "PEN",
  "PGK",
  "PHP",
  "PKR",
  "PLN",
  "PTE",
  "PYG",
  "QAR",
  "ROL",
  "RUB",
  "RUR",
  "RWF",
  "SAR",
  "SBD",
  "SCR",
  "SDD",
  "SEK",
  "SGD",
  "SHP",
  "SIT",
  "SKK",
  "SLL",
  "SOS",
  "SRG",
  "STD",
  "SVC",
  "SYP",
  "SZL",
  "THB",
  "TJR",
  "TMM",
  "TND",
  "TOP",
  "TPE",
  "TRL",
  "TTD",
  "TWD",
  "TZS",
  "UAH",
  "UGX",
  "USD",
  "UYU",
  "UZS",
  "VEB",
  "VND",
  "VUV",
  "WST",
  "XAF",
  "XCD",
  "XDR",
  "XOF",
  "XPF",
  "YER",
  "YUM",
  "ZAR",
  "ZMK",
  "ZWD"
};

const CurrencyCode::value CurrencyCode::
_xsd_CurrencyCode_indexes_[182] =
{
  ::CurrencyCode::AFA,
  ::CurrencyCode::ALL,
  ::CurrencyCode::AMD,
  ::CurrencyCode::ANG,
  ::CurrencyCode::AOA,
  ::CurrencyCode::ARS,
  ::CurrencyCode::ATS,
  ::CurrencyCode::AUD,
  ::CurrencyCode::AWG,
  ::CurrencyCode::AZM,
  ::CurrencyCode::BAM,
  ::CurrencyCode::BBD,
  ::CurrencyCode::BDT,
  ::CurrencyCode::BEF,
  ::CurrencyCode::BGL,
  ::CurrencyCode::BGN,
  ::CurrencyCode::BHD,
  ::CurrencyCode::BIF,
  ::CurrencyCode::BMD,
  ::CurrencyCode::BND,
  ::CurrencyCode::BOB,
  ::CurrencyCode::BOV,
  ::CurrencyCode::BRL,
  ::CurrencyCode::BSD,
  ::CurrencyCode::BTN,
  ::CurrencyCode::BWP,
  ::CurrencyCode::BYB,
  ::CurrencyCode::BYR,
  ::CurrencyCode::BZD,
  ::CurrencyCode::CAD,
  ::CurrencyCode::CDF,
  ::CurrencyCode::CHF,
  ::CurrencyCode::CLF,
  ::CurrencyCode::CLP,
  ::CurrencyCode::CNY,
  ::CurrencyCode::COP,
  ::CurrencyCode::CRC,
  ::CurrencyCode::CUP,
  ::CurrencyCode::CVE,
  ::CurrencyCode::CYP,
  ::CurrencyCode::CZK,
  ::CurrencyCode::DEM,
  ::CurrencyCode::DJF,
  ::CurrencyCode::DKK,
  ::CurrencyCode::DOP,
  ::CurrencyCode::DZD,
  ::CurrencyCode::EEK,
  ::CurrencyCode::EGP,
  ::CurrencyCode::ERN,
  ::CurrencyCode::ESP,
  ::CurrencyCode::ETB,
  ::CurrencyCode::EUR,
  ::CurrencyCode::FIM,
  ::CurrencyCode::FJD,
  ::CurrencyCode::FKP,
  ::CurrencyCode::FRF,
  ::CurrencyCode::GBP,
  ::CurrencyCode::GEL,
  ::CurrencyCode::GHC,
  ::CurrencyCode::GIP,
  ::CurrencyCode::GMD,
  ::CurrencyCode::GNF,
  ::CurrencyCode::GRD,
  ::CurrencyCode::GTQ,
  ::CurrencyCode::GWP,
  ::CurrencyCode::GYD,
  ::CurrencyCode::HKD,
  ::CurrencyCode::HNL,
  ::CurrencyCode::HRK,
  ::CurrencyCode::HTG,
  ::CurrencyCode::HUF,
  ::CurrencyCode::IDR,
  ::CurrencyCode::IEP,
  ::CurrencyCode::ILS,
  ::CurrencyCode::INR,
  ::CurrencyCode::IQD,
  ::CurrencyCode::IRR,
  ::CurrencyCode::ISK,
  ::CurrencyCode::ITL,
  ::CurrencyCode::JMD,
  ::CurrencyCode::JOD,
  ::CurrencyCode::JPY,
  ::CurrencyCode::KES,
  ::CurrencyCode::KGS,
  ::CurrencyCode::KHR,
  ::CurrencyCode::KMF,
  ::CurrencyCode::KPW,
  ::CurrencyCode::KRW,
  ::CurrencyCode::KWD,
  ::CurrencyCode::KYD,
  ::CurrencyCode::KZT,
  ::CurrencyCode::LAK,
  ::CurrencyCode::LBP,
  ::CurrencyCode::LKR,
  ::CurrencyCode::LRD,
  ::CurrencyCode::LSL,
  ::CurrencyCode::LTL,
  ::CurrencyCode::LUF,
  ::CurrencyCode::LVL,
  ::CurrencyCode::LYD,
  ::CurrencyCode::MAD,
  ::CurrencyCode::MDL,
  ::CurrencyCode::MGF,
  ::CurrencyCode::MKD,
  ::CurrencyCode::MMK,
  ::CurrencyCode::MNT,
  ::CurrencyCode::MOP,
  ::CurrencyCode::MRO,
  ::CurrencyCode::MTL,
  ::CurrencyCode::MUR,
  ::CurrencyCode::MVR,
  ::CurrencyCode::MWK,
  ::CurrencyCode::MXN,
  ::CurrencyCode::MXV,
  ::CurrencyCode::MYR,
  ::CurrencyCode::MZM,
  ::CurrencyCode::NAD,
  ::CurrencyCode::NGN,
  ::CurrencyCode::NIO,
  ::CurrencyCode::NLG,
  ::CurrencyCode::NOK,
  ::CurrencyCode::NPR,
  ::CurrencyCode::NZD,
  ::CurrencyCode::OMR,
  ::CurrencyCode::PAB,
  ::CurrencyCode::PEN,
  ::CurrencyCode::PGK,
  ::CurrencyCode::PHP,
  ::CurrencyCode::PKR,
  ::CurrencyCode::PLN,
  ::CurrencyCode::PTE,
  ::CurrencyCode::PYG,
  ::CurrencyCode::QAR,
  ::CurrencyCode::ROL,
  ::CurrencyCode::RUB,
  ::CurrencyCode::RUR,
  ::CurrencyCode::RWF,
  ::CurrencyCode::SAR,
  ::CurrencyCode::SBD,
  ::CurrencyCode::SCR,
  ::CurrencyCode::SDD,
  ::CurrencyCode::SEK,
  ::CurrencyCode::SGD,
  ::CurrencyCode::SHP,
  ::CurrencyCode::SIT,
  ::CurrencyCode::SKK,
  ::CurrencyCode::SLL,
  ::CurrencyCode::SOS,
  ::CurrencyCode::SRG,
  ::CurrencyCode::STD,
  ::CurrencyCode::SVC,
  ::CurrencyCode::SYP,
  ::CurrencyCode::SZL,
  ::CurrencyCode::THB,
  ::CurrencyCode::TJR,
  ::CurrencyCode::TMM,
  ::CurrencyCode::TND,
  ::CurrencyCode::TOP,
  ::CurrencyCode::TPE,
  ::CurrencyCode::TRL,
  ::CurrencyCode::TTD,
  ::CurrencyCode::TWD,
  ::CurrencyCode::TZS,
  ::CurrencyCode::UAH,
  ::CurrencyCode::UGX,
  ::CurrencyCode::USD,
  ::CurrencyCode::UYU,
  ::CurrencyCode::UZS,
  ::CurrencyCode::VEB,
  ::CurrencyCode::VND,
  ::CurrencyCode::VUV,
  ::CurrencyCode::WST,
  ::CurrencyCode::XAF,
  ::CurrencyCode::XCD,
  ::CurrencyCode::XDR,
  ::CurrencyCode::XOF,
  ::CurrencyCode::XPF,
  ::CurrencyCode::YER,
  ::CurrencyCode::YUM,
  ::CurrencyCode::ZAR,
  ::CurrencyCode::ZMK,
  ::CurrencyCode::ZWD
};

// MatML_Doc
//

MatML_Doc::
MatML_Doc ()
: ::xml_schema::type (),
  Material_ (this),
  Metadata_ (this)
{
}

MatML_Doc::
MatML_Doc (const MatML_Doc& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Material_ (x.Material_, f, this),
  Metadata_ (x.Metadata_, f, this)
{
}

MatML_Doc::
MatML_Doc (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Material_ (this),
  Metadata_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MatML_Doc::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Material
    //
    if (n.name () == "Material" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Material_type > r (
        Material_traits::create (i, f, this));

      this->Material_.push_back (::std::move (r));
      continue;
    }

    // Metadata
    //
    if (n.name () == "Metadata" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Metadata_type > r (
        Metadata_traits::create (i, f, this));

      if (!this->Metadata_)
      {
        this->Metadata_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

MatML_Doc* MatML_Doc::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MatML_Doc (*this, f, c);
}

MatML_Doc& MatML_Doc::
operator= (const MatML_Doc& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Material_ = x.Material_;
    this->Metadata_ = x.Metadata_;
  }

  return *this;
}

MatML_Doc::
~MatML_Doc ()
{
}

// ParentMaterial
//

ParentMaterial::
ParentMaterial (const id_type& id)
: ::xml_schema::type (),
  id_ (id, this)
{
}

ParentMaterial::
ParentMaterial (const ParentMaterial& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this)
{
}

ParentMaterial::
ParentMaterial (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ParentMaterial::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

ParentMaterial* ParentMaterial::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParentMaterial (*this, f, c);
}

ParentMaterial& ParentMaterial::
operator= (const ParentMaterial& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->id_ = x.id_;
  }

  return *this;
}

ParentMaterial::
~ParentMaterial ()
{
}

// Symbol
//

const Symbol::subscript_type Symbol::subscript_default_value_ (
  "1");

Symbol::
Symbol (::ChemicalElementSymbol::value _xsd_ChemicalElementSymbol_base)
: ::ChemicalElementSymbol (_xsd_ChemicalElementSymbol_base),
  subscript_ (subscript_default_value (), this)
{
}

Symbol::
Symbol (const char* _xsd_string_base)
: ::ChemicalElementSymbol (_xsd_string_base),
  subscript_ (subscript_default_value (), this)
{
}

Symbol::
Symbol (const ::std::string& _xsd_string_base)
: ::ChemicalElementSymbol (_xsd_string_base),
  subscript_ (subscript_default_value (), this)
{
}

Symbol::
Symbol (const ::ChemicalElementSymbol& _xsd_ChemicalElementSymbol_base)
: ::ChemicalElementSymbol (_xsd_ChemicalElementSymbol_base),
  subscript_ (subscript_default_value (), this)
{
}

Symbol::
Symbol (const Symbol& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::ChemicalElementSymbol (x, f, c),
  subscript_ (x.subscript_, f, this)
{
}

Symbol::
Symbol (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::ChemicalElementSymbol (e, f | ::xml_schema::flags::base, c),
  subscript_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Symbol::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "subscript" && n.namespace_ ().empty ())
    {
      this->subscript_.set (subscript_traits::create (i, f, this));
      continue;
    }
  }

  if (!subscript_.present ())
  {
    this->subscript_.set (subscript_default_value ());
  }
}

Symbol* Symbol::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Symbol (*this, f, c);
}

Symbol& Symbol::
operator= (const Symbol& x)
{
  if (this != &x)
  {
    static_cast< ::ChemicalElementSymbol& > (*this) = x;
    this->subscript_ = x.subscript_;
  }

  return *this;
}

Symbol::
~Symbol ()
{
}

// Graph
//

Graph::
Graph ()
: ::xml_schema::type ()
{
}

Graph::
Graph (const Graph& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c)
{
}

Graph::
Graph (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Graph::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    break;
  }
}

Graph* Graph::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Graph (*this, f, c);
}

Graph::
~Graph ()
{
}

// Data
//

Data::
Data ()
: ::xml_schema::string (),
  format_ (this)
{
}

Data::
Data (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  format_ (this)
{
}

Data::
Data (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  format_ (this)
{
}

Data::
Data (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  format_ (this)
{
}

Data::
Data (const Data& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  format_ (x.format_, f, this)
{
}

Data::
Data (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  format_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Data::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "format" && n.namespace_ ().empty ())
    {
      this->format_.set (format_traits::create (i, f, this));
      continue;
    }
  }
}

Data* Data::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Data (*this, f, c);
}

Data& Data::
operator= (const Data& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->format_ = x.format_;
  }

  return *this;
}

Data::
~Data ()
{
}

// Data1
//

Data1::
Data1 (const format_type& format)
: ::xml_schema::string (),
  format_ (format, this)
{
}

Data1::
Data1 (const char* _xsd_string_base,
       const format_type& format)
: ::xml_schema::string (_xsd_string_base),
  format_ (format, this)
{
}

Data1::
Data1 (const ::std::string& _xsd_string_base,
       const format_type& format)
: ::xml_schema::string (_xsd_string_base),
  format_ (format, this)
{
}

Data1::
Data1 (const ::xml_schema::string& _xsd_string_base,
       const format_type& format)
: ::xml_schema::string (_xsd_string_base),
  format_ (format, this)
{
}

Data1::
Data1 (const Data1& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  format_ (x.format_, f, this)
{
}

Data1::
Data1 (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  format_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Data1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "format" && n.namespace_ ().empty ())
    {
      this->format_.set (format_traits::create (i, f, this));
      continue;
    }
  }

  if (!format_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "format",
      "");
  }
}

Data1* Data1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Data1 (*this, f, c);
}

Data1& Data1::
operator= (const Data1& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->format_ = x.format_;
  }

  return *this;
}

Data1::
~Data1 ()
{
}

// delimiter
//

delimiter::
delimiter ()
: ::xml_schema::string ()
{
}

delimiter::
delimiter (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

delimiter::
delimiter (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

delimiter::
delimiter (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

delimiter::
delimiter (const delimiter& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

delimiter::
delimiter (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

delimiter::
delimiter (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

delimiter::
delimiter (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

delimiter* delimiter::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class delimiter (*this, f, c);
}

delimiter::
~delimiter ()
{
}

// Scale
//

Scale::
Scale (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_Scale_convert ();
}

Scale::
Scale (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_Scale_convert ();
}

Scale::
Scale (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_Scale_convert ();
}

Scale* Scale::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Scale (*this, f, c);
}

Scale::value Scale::
_xsd_Scale_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Scale_literals_);
  const value* i (::std::lower_bound (
                    _xsd_Scale_indexes_,
                    _xsd_Scale_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_Scale_indexes_ + 2 || _xsd_Scale_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const Scale::
_xsd_Scale_literals_[2] =
{
  "Linear",
  "Logarithmic"
};

const Scale::value Scale::
_xsd_Scale_indexes_[2] =
{
  ::Scale::Linear,
  ::Scale::Logarithmic
};

#include <ostream>

::std::ostream&
operator<< (::std::ostream& o, const Associate& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const AssociationDetails& i)
{
  if (i.Associate ())
  {
    o << ::std::endl << "Associate: " << *i.Associate ();
  }

  if (i.Relationship ())
  {
    o << ::std::endl << "Relationship: " << *i.Relationship ();
  }

  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const BulkDetails& i)
{
  o << ::std::endl << "Name: " << i.Name ();
  for (BulkDetails::Class_const_iterator
       b (i.Class ().begin ()), e (i.Class ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Class: " << *b;
  }

  for (BulkDetails::Subclass_const_iterator
       b (i.Subclass ().begin ()), e (i.Subclass ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Subclass: " << *b;
  }

  for (BulkDetails::Specification_const_iterator
       b (i.Specification ().begin ()), e (i.Specification ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Specification: " << *b;
  }

  if (i.Source ())
  {
    o << ::std::endl << "Source: " << *i.Source ();
  }

  if (i.Form ())
  {
    o << ::std::endl << "Form: " << *i.Form ();
  }

  for (BulkDetails::ProcessingDetails_const_iterator
       b (i.ProcessingDetails ().begin ()), e (i.ProcessingDetails ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "ProcessingDetails: " << *b;
  }

  if (i.Characterization ())
  {
    o << ::std::endl << "Characterization: " << *i.Characterization ();
  }

  for (BulkDetails::PropertyData_const_iterator
       b (i.PropertyData ().begin ()), e (i.PropertyData ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "PropertyData: " << *b;
  }

  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Characterization& i)
{
  o << ::std::endl << "Formula: " << i.Formula ();
  if (i.ChemicalComposition ())
  {
    o << ::std::endl << "ChemicalComposition: " << *i.ChemicalComposition ();
  }

  for (Characterization::PhaseComposition_const_iterator
       b (i.PhaseComposition ().begin ()), e (i.PhaseComposition ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "PhaseComposition: " << *b;
  }

  for (Characterization::DimensionalDetails_const_iterator
       b (i.DimensionalDetails ().begin ()), e (i.DimensionalDetails ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "DimensionalDetails: " << *b;
  }

  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ChemicalComposition& i)
{
  for (ChemicalComposition::Compound_const_iterator
       b (i.Compound ().begin ()), e (i.Compound ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Compound: " << *b;
  }

  for (ChemicalComposition::Element_const_iterator
       b (i.Element ().begin ()), e (i.Element ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Element: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Class& i)
{
  if (i.Name ())
  {
    o << ::std::endl << "Name: " << *i.Name ();
  }

  for (Class::ParentMaterial_const_iterator
       b (i.ParentMaterial ().begin ()), e (i.ParentMaterial ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "ParentMaterial: " << *b;
  }

  for (Class::ParentSubClass_const_iterator
       b (i.ParentSubClass ().begin ()), e (i.ParentSubClass ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "ParentSubClass: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ComponentDetails& i)
{
  o << ::std::endl << "Name: " << i.Name ();
  for (ComponentDetails::Class_const_iterator
       b (i.Class ().begin ()), e (i.Class ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Class: " << *b;
  }

  for (ComponentDetails::Subclass_const_iterator
       b (i.Subclass ().begin ()), e (i.Subclass ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Subclass: " << *b;
  }

  for (ComponentDetails::Specification_const_iterator
       b (i.Specification ().begin ()), e (i.Specification ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Specification: " << *b;
  }

  if (i.Source ())
  {
    o << ::std::endl << "Source: " << *i.Source ();
  }

  if (i.Form ())
  {
    o << ::std::endl << "Form: " << *i.Form ();
  }

  for (ComponentDetails::ProcessingDetails_const_iterator
       b (i.ProcessingDetails ().begin ()), e (i.ProcessingDetails ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "ProcessingDetails: " << *b;
  }

  if (i.Characterization ())
  {
    o << ::std::endl << "Characterization: " << *i.Characterization ();
  }

  for (ComponentDetails::PropertyData_const_iterator
       b (i.PropertyData ().begin ()), e (i.PropertyData ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "PropertyData: " << *b;
  }

  for (ComponentDetails::AssociationDetails_const_iterator
       b (i.AssociationDetails ().begin ()), e (i.AssociationDetails ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "AssociationDetails: " << *b;
  }

  for (ComponentDetails::ComponentDetails1_const_iterator
       b (i.ComponentDetails1 ().begin ()), e (i.ComponentDetails1 ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "ComponentDetails: " << *b;
  }

  if (i.id ())
  {
    o << ::std::endl << "id: " << *i.id ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Compound& i)
{
  for (Compound::Element_const_iterator
       b (i.Element ().begin ()), e (i.Element ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Element: " << *b;
  }

  if (i.Concentration ())
  {
    o << ::std::endl << "Concentration: " << *i.Concentration ();
  }

  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Concentration& i)
{
  o << ::std::endl << "Value: " << i.Value ();
  o << ::std::endl << "Units: " << i.Units ();
  for (Concentration::Qualifier_const_iterator
       b (i.Qualifier ().begin ()), e (i.Qualifier ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Qualifier: " << *b;
  }

  for (Concentration::Uncertainty_const_iterator
       b (i.Uncertainty ().begin ()), e (i.Uncertainty ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Uncertainty: " << *b;
  }

  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, DataFormat::value i)
{
  return o << DataFormat::_xsd_DataFormat_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const DataFormat& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const DimensionalDetails& i)
{
  o << ::std::endl << "Name: " << i.Name ();
  o << ::std::endl << "Value: " << i.Value ();
  o << ::std::endl << "Units: " << i.Units ();
  if (i.Qualifier ())
  {
    o << ::std::endl << "Qualifier: " << *i.Qualifier ();
  }

  for (DimensionalDetails::Uncertainty_const_iterator
       b (i.Uncertainty ().begin ()), e (i.Uncertainty ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Uncertainty: " << *b;
  }

  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Element& i)
{
  o << ::std::endl << "Symbol: " << i.Symbol ();
  if (i.Concentration ())
  {
    o << ::std::endl << "Concentration: " << *i.Concentration ();
  }

  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Form& i)
{
  o << ::std::endl << "Description: " << i.Description ();
  if (i.Geometry ())
  {
    o << ::std::endl << "Geometry: " << *i.Geometry ();
  }

  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Formula& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Geometry& i)
{
  o << ::std::endl << "Shape: " << i.Shape ();
  if (i.Dimensions ())
  {
    o << ::std::endl << "Dimensions: " << *i.Dimensions ();
  }

  if (i.Orientation ())
  {
    o << ::std::endl << "Orientation: " << *i.Orientation ();
  }

  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Glossary& i)
{
  for (Glossary::Term_const_iterator
       b (i.Term ().begin ()), e (i.Term ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Term: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const GlossaryTerm& i)
{
  o << ::std::endl << "Name: " << i.Name ();
  o << ::std::endl << "Definition: " << i.Definition ();
  for (GlossaryTerm::Abbreviation_const_iterator
       b (i.Abbreviation ().begin ()), e (i.Abbreviation ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Abbreviation: " << *b;
  }

  for (GlossaryTerm::Synonym_const_iterator
       b (i.Synonym ().begin ()), e (i.Synonym ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Synonym: " << *b;
  }

  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Graphs& i)
{
  for (Graphs::Graph_const_iterator
       b (i.Graph ().begin ()), e (i.Graph ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Graph: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Material& i)
{
  o << ::std::endl << "BulkDetails: " << i.BulkDetails ();
  for (Material::ComponentDetails_const_iterator
       b (i.ComponentDetails ().begin ()), e (i.ComponentDetails ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "ComponentDetails: " << *b;
  }

  if (i.Graphs ())
  {
    o << ::std::endl << "Graphs: " << *i.Graphs ();
  }

  if (i.Glossary ())
  {
    o << ::std::endl << "Glossary: " << *i.Glossary ();
  }

  if (i.id ())
  {
    o << ::std::endl << "id: " << *i.id ();
  }

  if (i.layers ())
  {
    o << ::std::endl << "layers: " << *i.layers ();
  }

  if (i.local_frame_of_reference ())
  {
    o << ::std::endl << "local_frame_of_reference: " << *i.local_frame_of_reference ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Metadata& i)
{
  for (Metadata::AuthorityDetails_const_iterator
       b (i.AuthorityDetails ().begin ()), e (i.AuthorityDetails ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "AuthorityDetails: " << *b;
  }

  for (Metadata::DataSourceDetails_const_iterator
       b (i.DataSourceDetails ().begin ()), e (i.DataSourceDetails ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "DataSourceDetails: " << *b;
  }

  for (Metadata::MeasurementTechniqueDetails_const_iterator
       b (i.MeasurementTechniqueDetails ().begin ()), e (i.MeasurementTechniqueDetails ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "MeasurementTechniqueDetails: " << *b;
  }

  for (Metadata::ParameterDetails_const_iterator
       b (i.ParameterDetails ().begin ()), e (i.ParameterDetails ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "ParameterDetails: " << *b;
  }

  for (Metadata::PropertyDetails_const_iterator
       b (i.PropertyDetails ().begin ()), e (i.PropertyDetails ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "PropertyDetails: " << *b;
  }

  for (Metadata::SourceDetails_const_iterator
       b (i.SourceDetails ().begin ()), e (i.SourceDetails ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "SourceDetails: " << *b;
  }

  for (Metadata::SpecimenDetails_const_iterator
       b (i.SpecimenDetails ().begin ()), e (i.SpecimenDetails ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "SpecimenDetails: " << *b;
  }

  for (Metadata::TestConditionDetails_const_iterator
       b (i.TestConditionDetails ().begin ()), e (i.TestConditionDetails ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "TestConditionDetails: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Name& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  if (i.authority ())
  {
    o << ::std::endl << "authority: " << *i.authority ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Notes& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ParameterValue& i)
{
  o << ::std::endl << "Data: " << i.Data ();
  for (ParameterValue::Uncertainty_const_iterator
       b (i.Uncertainty ().begin ()), e (i.Uncertainty ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Uncertainty: " << *b;
  }

  for (ParameterValue::Qualifier_const_iterator
       b (i.Qualifier ().begin ()), e (i.Qualifier ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Qualifier: " << *b;
  }

  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  o << ::std::endl << "parameter: " << i.parameter ();
  o << ::std::endl << "format: " << i.format ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const PhaseComposition& i)
{
  o << ::std::endl << "Name: " << i.Name ();
  if (i.Concentration ())
  {
    o << ::std::endl << "Concentration: " << *i.Concentration ();
  }

  for (PhaseComposition::PropertyData_const_iterator
       b (i.PropertyData ().begin ()), e (i.PropertyData ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "PropertyData: " << *b;
  }

  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ProcessingDetails& i)
{
  o << ::std::endl << "Name: " << i.Name ();
  for (ProcessingDetails::ParameterValue_const_iterator
       b (i.ParameterValue ().begin ()), e (i.ParameterValue ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "ParameterValue: " << *b;
  }

  if (i.Result ())
  {
    o << ::std::endl << "Result: " << *i.Result ();
  }

  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const PropertyData& i)
{
  o << ::std::endl << "Data: " << i.Data ();
  for (PropertyData::Uncertainty_const_iterator
       b (i.Uncertainty ().begin ()), e (i.Uncertainty ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Uncertainty: " << *b;
  }

  for (PropertyData::Qualifier_const_iterator
       b (i.Qualifier ().begin ()), e (i.Qualifier ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Qualifier: " << *b;
  }

  for (PropertyData::ParameterValue_const_iterator
       b (i.ParameterValue ().begin ()), e (i.ParameterValue ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "ParameterValue: " << *b;
  }

  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  o << ::std::endl << "property: " << i.property ();
  if (i.technique ())
  {
    o << ::std::endl << "technique: " << *i.technique ();
  }

  if (i.source ())
  {
    o << ::std::endl << "source: " << *i.source ();
  }

  if (i.specimen ())
  {
    o << ::std::endl << "specimen: " << *i.specimen ();
  }

  if (i.test ())
  {
    o << ::std::endl << "test: " << *i.test ();
  }

  o << ::std::endl << "delimiter: " << i.delimiter ();
  if (i.quote ())
  {
    o << ::std::endl << "quote: " << *i.quote ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Qualifier& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Relationship& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Source& i)
{
  if (i.source ())
  {
    o << ::std::endl << "source: " << *i.source ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Specification& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  if (i.authority ())
  {
    o << ::std::endl << "authority: " << *i.authority ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Uncertainty& i)
{
  o << ::std::endl << "Value: " << i.Value ();
  if (i.Units ())
  {
    o << ::std::endl << "Units: " << *i.Units ();
  }

  if (i.Unitless ())
  {
    o << ::std::endl << "Unitless: " << *i.Unitless ();
  }

  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  if (i.Scale ())
  {
    o << ::std::endl << "Scale: " << *i.Scale ();
  }

  o << ::std::endl << "DistributionType: " << i.DistributionType ();
  o << ::std::endl << "Num_Std_Dev: " << i.Num_Std_Dev ();
  if (i.Percentile ())
  {
    o << ::std::endl << "Percentile: " << *i.Percentile ();
  }

  if (i.ConfidenceLevel ())
  {
    o << ::std::endl << "ConfidenceLevel: " << *i.ConfidenceLevel ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Unit& i)
{
  if (i.Name ())
  {
    o << ::std::endl << "Name: " << *i.Name ();
  }

  if (i.Currency ())
  {
    o << ::std::endl << "Currency: " << *i.Currency ();
  }

  if (i.power ())
  {
    o << ::std::endl << "power: " << *i.power ();
  }

  if (i.description ())
  {
    o << ::std::endl << "description: " << *i.description ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Unitless&)
{
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Units& i)
{
  for (Units::Unit_const_iterator
       b (i.Unit ().begin ()), e (i.Unit ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Unit: " << *b;
  }

  if (i.system ())
  {
    o << ::std::endl << "system: " << *i.system ();
  }

  if (i.factor ())
  {
    o << ::std::endl << "factor: " << *i.factor ();
  }

  if (i.name ())
  {
    o << ::std::endl << "name: " << *i.name ();
  }

  if (i.description ())
  {
    o << ::std::endl << "description: " << *i.description ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Value& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "format: " << i.format ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const AuthorityDetails& i)
{
  o << ::std::endl << "Name: " << i.Name ();
  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  o << ::std::endl << "id: " << i.id ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const DataSourceDetails& i)
{
  o << ::std::endl << "Name: " << i.Name ();
  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  o << ::std::endl << "id: " << i.id ();
  if (i.type ())
  {
    o << ::std::endl << "type: " << *i.type ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const MeasurementTechniqueDetails& i)
{
  o << ::std::endl << "Name: " << i.Name ();
  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  o << ::std::endl << "id: " << i.id ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ParameterDetails& i)
{
  o << ::std::endl << "Name: " << i.Name ();
  if (i.Units ())
  {
    o << ::std::endl << "Units: " << *i.Units ();
  }

  if (i.Unitless ())
  {
    o << ::std::endl << "Unitless: " << *i.Unitless ();
  }

  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  o << ::std::endl << "id: " << i.id ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const PropertyDetails& i)
{
  o << ::std::endl << "Name: " << i.Name ();
  if (i.Units ())
  {
    o << ::std::endl << "Units: " << *i.Units ();
  }

  if (i.Unitless ())
  {
    o << ::std::endl << "Unitless: " << *i.Unitless ();
  }

  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  o << ::std::endl << "id: " << i.id ();
  if (i.type ())
  {
    o << ::std::endl << "type: " << *i.type ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const SourceDetails& i)
{
  o << ::std::endl << "Name: " << i.Name ();
  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  o << ::std::endl << "id: " << i.id ();
  if (i.type ())
  {
    o << ::std::endl << "type: " << *i.type ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const SpecimenDetails& i)
{
  if (i.Name ())
  {
    o << ::std::endl << "Name: " << *i.Name ();
  }

  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  if (i.Geometry ())
  {
    o << ::std::endl << "Geometry: " << *i.Geometry ();
  }

  o << ::std::endl << "id: " << i.id ();
  if (i.type ())
  {
    o << ::std::endl << "type: " << *i.type ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const TestConditionDetails& i)
{
  for (TestConditionDetails::ParameterValue_const_iterator
       b (i.ParameterValue ().begin ()), e (i.ParameterValue ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "ParameterValue: " << *b;
  }

  if (i.Notes ())
  {
    o << ::std::endl << "Notes: " << *i.Notes ();
  }

  o << ::std::endl << "id: " << i.id ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, ChemicalElementSymbol::value i)
{
  return o << ChemicalElementSymbol::_xsd_ChemicalElementSymbol_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const ChemicalElementSymbol& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, CurrencyCode::value i)
{
  return o << CurrencyCode::_xsd_CurrencyCode_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const CurrencyCode& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const MatML_Doc& i)
{
  for (MatML_Doc::Material_const_iterator
       b (i.Material ().begin ()), e (i.Material ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Material: " << *b;
  }

  if (i.Metadata ())
  {
    o << ::std::endl << "Metadata: " << *i.Metadata ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ParentMaterial& i)
{
  o << ::std::endl << "id: " << i.id ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Symbol& i)
{
  o << static_cast< const ::ChemicalElementSymbol& > (i);

  o << ::std::endl << "subscript: " << i.subscript ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Graph&)
{
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Data& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  if (i.format ())
  {
    o << ::std::endl << "format: " << *i.format ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Data1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "format: " << i.format ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const delimiter& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, Scale::value i)
{
  return o << Scale::_xsd_Scale_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const Scale& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::MatML_Doc >
MatML_Doc_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::MatML_Doc > (
    ::MatML_Doc_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::MatML_Doc >
MatML_Doc_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::MatML_Doc > (
    ::MatML_Doc_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::MatML_Doc >
MatML_Doc_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::MatML_Doc > (
    ::MatML_Doc_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::MatML_Doc >
MatML_Doc_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MatML_Doc_ (isrc, f, p);
}

::std::unique_ptr< ::MatML_Doc >
MatML_Doc_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MatML_Doc_ (isrc, h, f, p);
}

::std::unique_ptr< ::MatML_Doc >
MatML_Doc_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MatML_Doc_ (isrc, h, f, p);
}

::std::unique_ptr< ::MatML_Doc >
MatML_Doc_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MatML_Doc_ (isrc, f, p);
}

::std::unique_ptr< ::MatML_Doc >
MatML_Doc_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MatML_Doc_ (isrc, h, f, p);
}

::std::unique_ptr< ::MatML_Doc >
MatML_Doc_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MatML_Doc_ (isrc, h, f, p);
}

::std::unique_ptr< ::MatML_Doc >
MatML_Doc_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::MatML_Doc > (
    ::MatML_Doc_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::MatML_Doc >
MatML_Doc_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::MatML_Doc > (
    ::MatML_Doc_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::MatML_Doc >
MatML_Doc_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::MatML_Doc > (
    ::MatML_Doc_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::MatML_Doc >
MatML_Doc_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::MatML_Doc > (
      ::MatML_Doc_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "MatML_Doc" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::MatML_Doc > r (
      ::xsd::cxx::tree::traits< ::MatML_Doc, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MatML_Doc",
    "");
}

::std::unique_ptr< ::MatML_Doc >
MatML_Doc_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "MatML_Doc" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::MatML_Doc > r (
      ::xsd::cxx::tree::traits< ::MatML_Doc, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MatML_Doc",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
MatML_Doc_ (::std::ostream& o,
            const ::MatML_Doc& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::MatML_Doc_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
MatML_Doc_ (::std::ostream& o,
            const ::MatML_Doc& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::MatML_Doc_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
MatML_Doc_ (::std::ostream& o,
            const ::MatML_Doc& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::MatML_Doc_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
MatML_Doc_ (::xercesc::XMLFormatTarget& t,
            const ::MatML_Doc& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::MatML_Doc_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
MatML_Doc_ (::xercesc::XMLFormatTarget& t,
            const ::MatML_Doc& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::MatML_Doc_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
MatML_Doc_ (::xercesc::XMLFormatTarget& t,
            const ::MatML_Doc& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::MatML_Doc_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
MatML_Doc_ (::xercesc::DOMDocument& d,
            const ::MatML_Doc& s,
            ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "MatML_Doc" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MatML_Doc",
      "");
  }
}

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
MatML_Doc_ (const ::MatML_Doc& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "MatML_Doc",
      "",
      m, f));

  ::MatML_Doc_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const Associate& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const Associate& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const Associate& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const AssociationDetails& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Associate
  //
  if (i.Associate ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Associate",
        e));

    s << *i.Associate ();
  }

  // Relationship
  //
  if (i.Relationship ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Relationship",
        e));

    s << *i.Relationship ();
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const BulkDetails& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Name",
        e));

    s << i.Name ();
  }

  // Class
  //
  for (BulkDetails::Class_const_iterator
       b (i.Class ().begin ()), n (i.Class ().end ());
       b != n; ++b)
  {
    const BulkDetails::Class_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Class",
        e));

    s << x;
  }

  // Subclass
  //
  for (BulkDetails::Subclass_const_iterator
       b (i.Subclass ().begin ()), n (i.Subclass ().end ());
       b != n; ++b)
  {
    const BulkDetails::Subclass_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Subclass",
        e));

    s << x;
  }

  // Specification
  //
  for (BulkDetails::Specification_const_iterator
       b (i.Specification ().begin ()), n (i.Specification ().end ());
       b != n; ++b)
  {
    const BulkDetails::Specification_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Specification",
        e));

    s << x;
  }

  // Source
  //
  if (i.Source ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Source",
        e));

    s << *i.Source ();
  }

  // Form
  //
  if (i.Form ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Form",
        e));

    s << *i.Form ();
  }

  // ProcessingDetails
  //
  for (BulkDetails::ProcessingDetails_const_iterator
       b (i.ProcessingDetails ().begin ()), n (i.ProcessingDetails ().end ());
       b != n; ++b)
  {
    const BulkDetails::ProcessingDetails_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ProcessingDetails",
        e));

    s << x;
  }

  // Characterization
  //
  if (i.Characterization ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Characterization",
        e));

    s << *i.Characterization ();
  }

  // PropertyData
  //
  for (BulkDetails::PropertyData_const_iterator
       b (i.PropertyData ().begin ()), n (i.PropertyData ().end ());
       b != n; ++b)
  {
    const BulkDetails::PropertyData_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "PropertyData",
        e));

    s << x;
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Characterization& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Formula
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Formula",
        e));

    s << i.Formula ();
  }

  // ChemicalComposition
  //
  if (i.ChemicalComposition ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ChemicalComposition",
        e));

    s << *i.ChemicalComposition ();
  }

  // PhaseComposition
  //
  for (Characterization::PhaseComposition_const_iterator
       b (i.PhaseComposition ().begin ()), n (i.PhaseComposition ().end ());
       b != n; ++b)
  {
    const Characterization::PhaseComposition_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "PhaseComposition",
        e));

    s << x;
  }

  // DimensionalDetails
  //
  for (Characterization::DimensionalDetails_const_iterator
       b (i.DimensionalDetails ().begin ()), n (i.DimensionalDetails ().end ());
       b != n; ++b)
  {
    const Characterization::DimensionalDetails_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DimensionalDetails",
        e));

    s << x;
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ChemicalComposition& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Compound
  //
  for (ChemicalComposition::Compound_const_iterator
       b (i.Compound ().begin ()), n (i.Compound ().end ());
       b != n; ++b)
  {
    const ChemicalComposition::Compound_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Compound",
        e));

    s << x;
  }

  // Element
  //
  for (ChemicalComposition::Element_const_iterator
       b (i.Element ().begin ()), n (i.Element ().end ());
       b != n; ++b)
  {
    const ChemicalComposition::Element_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Element",
        e));

    s << x;
  }
}

void
operator<< (::xercesc::DOMElement& e, const Class& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  if (i.Name ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Name",
        e));

    s << *i.Name ();
  }

  // ParentMaterial
  //
  for (Class::ParentMaterial_const_iterator
       b (i.ParentMaterial ().begin ()), n (i.ParentMaterial ().end ());
       b != n; ++b)
  {
    const Class::ParentMaterial_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ParentMaterial",
        e));

    s << x;
  }

  // ParentSubClass
  //
  for (Class::ParentSubClass_const_iterator
       b (i.ParentSubClass ().begin ()), n (i.ParentSubClass ().end ());
       b != n; ++b)
  {
    const Class::ParentSubClass_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ParentSubClass",
        e));

    s << x;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ComponentDetails& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Name",
        e));

    s << i.Name ();
  }

  // Class
  //
  for (ComponentDetails::Class_const_iterator
       b (i.Class ().begin ()), n (i.Class ().end ());
       b != n; ++b)
  {
    const ComponentDetails::Class_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Class",
        e));

    s << x;
  }

  // Subclass
  //
  for (ComponentDetails::Subclass_const_iterator
       b (i.Subclass ().begin ()), n (i.Subclass ().end ());
       b != n; ++b)
  {
    const ComponentDetails::Subclass_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Subclass",
        e));

    s << x;
  }

  // Specification
  //
  for (ComponentDetails::Specification_const_iterator
       b (i.Specification ().begin ()), n (i.Specification ().end ());
       b != n; ++b)
  {
    const ComponentDetails::Specification_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Specification",
        e));

    s << x;
  }

  // Source
  //
  if (i.Source ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Source",
        e));

    s << *i.Source ();
  }

  // Form
  //
  if (i.Form ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Form",
        e));

    s << *i.Form ();
  }

  // ProcessingDetails
  //
  for (ComponentDetails::ProcessingDetails_const_iterator
       b (i.ProcessingDetails ().begin ()), n (i.ProcessingDetails ().end ());
       b != n; ++b)
  {
    const ComponentDetails::ProcessingDetails_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ProcessingDetails",
        e));

    s << x;
  }

  // Characterization
  //
  if (i.Characterization ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Characterization",
        e));

    s << *i.Characterization ();
  }

  // PropertyData
  //
  for (ComponentDetails::PropertyData_const_iterator
       b (i.PropertyData ().begin ()), n (i.PropertyData ().end ());
       b != n; ++b)
  {
    const ComponentDetails::PropertyData_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "PropertyData",
        e));

    s << x;
  }

  // AssociationDetails
  //
  for (ComponentDetails::AssociationDetails_const_iterator
       b (i.AssociationDetails ().begin ()), n (i.AssociationDetails ().end ());
       b != n; ++b)
  {
    const ComponentDetails::AssociationDetails_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AssociationDetails",
        e));

    s << x;
  }

  // ComponentDetails
  //
  for (ComponentDetails::ComponentDetails1_const_iterator
       b (i.ComponentDetails1 ().begin ()), n (i.ComponentDetails1 ().end ());
       b != n; ++b)
  {
    const ComponentDetails::ComponentDetails1_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ComponentDetails",
        e));

    s << x;
  }

  // id
  //
  if (i.id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << *i.id ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Compound& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Element
  //
  for (Compound::Element_const_iterator
       b (i.Element ().begin ()), n (i.Element ().end ());
       b != n; ++b)
  {
    const Compound::Element_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Element",
        e));

    s << x;
  }

  // Concentration
  //
  if (i.Concentration ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Concentration",
        e));

    s << *i.Concentration ();
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Concentration& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Value
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Value",
        e));

    s << i.Value ();
  }

  // Units
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Units",
        e));

    s << i.Units ();
  }

  // Qualifier
  //
  for (Concentration::Qualifier_const_iterator
       b (i.Qualifier ().begin ()), n (i.Qualifier ().end ());
       b != n; ++b)
  {
    const Concentration::Qualifier_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Qualifier",
        e));

    s << x;
  }

  // Uncertainty
  //
  for (Concentration::Uncertainty_const_iterator
       b (i.Uncertainty ().begin ()), n (i.Uncertainty ().end ());
       b != n; ++b)
  {
    const Concentration::Uncertainty_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Uncertainty",
        e));

    s << x;
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const DataFormat& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const DataFormat& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const DataFormat& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const DimensionalDetails& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Name",
        e));

    s << i.Name ();
  }

  // Value
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Value",
        e));

    s << i.Value ();
  }

  // Units
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Units",
        e));

    s << i.Units ();
  }

  // Qualifier
  //
  if (i.Qualifier ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Qualifier",
        e));

    s << *i.Qualifier ();
  }

  // Uncertainty
  //
  for (DimensionalDetails::Uncertainty_const_iterator
       b (i.Uncertainty ().begin ()), n (i.Uncertainty ().end ());
       b != n; ++b)
  {
    const DimensionalDetails::Uncertainty_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Uncertainty",
        e));

    s << x;
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Element& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Symbol
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Symbol",
        e));

    s << i.Symbol ();
  }

  // Concentration
  //
  if (i.Concentration ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Concentration",
        e));

    s << *i.Concentration ();
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Form& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Description
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Description",
        e));

    s << i.Description ();
  }

  // Geometry
  //
  if (i.Geometry ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Geometry",
        e));

    s << *i.Geometry ();
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Formula& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const Formula& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const Formula& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const Geometry& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Shape
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Shape",
        e));

    s << i.Shape ();
  }

  // Dimensions
  //
  if (i.Dimensions ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Dimensions",
        e));

    s << *i.Dimensions ();
  }

  // Orientation
  //
  if (i.Orientation ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Orientation",
        e));

    s << *i.Orientation ();
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Glossary& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Term
  //
  for (Glossary::Term_const_iterator
       b (i.Term ().begin ()), n (i.Term ().end ());
       b != n; ++b)
  {
    const Glossary::Term_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Term",
        e));

    s << x;
  }
}

void
operator<< (::xercesc::DOMElement& e, const GlossaryTerm& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Name",
        e));

    s << i.Name ();
  }

  // Definition
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Definition",
        e));

    s << i.Definition ();
  }

  // Abbreviation
  //
  for (GlossaryTerm::Abbreviation_const_iterator
       b (i.Abbreviation ().begin ()), n (i.Abbreviation ().end ());
       b != n; ++b)
  {
    const GlossaryTerm::Abbreviation_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Abbreviation",
        e));

    s << x;
  }

  // Synonym
  //
  for (GlossaryTerm::Synonym_const_iterator
       b (i.Synonym ().begin ()), n (i.Synonym ().end ());
       b != n; ++b)
  {
    const GlossaryTerm::Synonym_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Synonym",
        e));

    s << x;
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Graphs& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Graph
  //
  for (Graphs::Graph_const_iterator
       b (i.Graph ().begin ()), n (i.Graph ().end ());
       b != n; ++b)
  {
    const Graphs::Graph_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Graph",
        e));

    s << x;
  }
}

void
operator<< (::xercesc::DOMElement& e, const Material& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // BulkDetails
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "BulkDetails",
        e));

    s << i.BulkDetails ();
  }

  // ComponentDetails
  //
  for (Material::ComponentDetails_const_iterator
       b (i.ComponentDetails ().begin ()), n (i.ComponentDetails ().end ());
       b != n; ++b)
  {
    const Material::ComponentDetails_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ComponentDetails",
        e));

    s << x;
  }

  // Graphs
  //
  if (i.Graphs ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Graphs",
        e));

    s << *i.Graphs ();
  }

  // Glossary
  //
  if (i.Glossary ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Glossary",
        e));

    s << *i.Glossary ();
  }

  // id
  //
  if (i.id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << *i.id ();
  }

  // layers
  //
  if (i.layers ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "layers",
        e));

    a << *i.layers ();
  }

  // local_frame_of_reference
  //
  if (i.local_frame_of_reference ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "local_frame_of_reference",
        e));

    a << *i.local_frame_of_reference ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Metadata& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // AuthorityDetails
  //
  for (Metadata::AuthorityDetails_const_iterator
       b (i.AuthorityDetails ().begin ()), n (i.AuthorityDetails ().end ());
       b != n; ++b)
  {
    const Metadata::AuthorityDetails_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AuthorityDetails",
        e));

    s << x;
  }

  // DataSourceDetails
  //
  for (Metadata::DataSourceDetails_const_iterator
       b (i.DataSourceDetails ().begin ()), n (i.DataSourceDetails ().end ());
       b != n; ++b)
  {
    const Metadata::DataSourceDetails_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DataSourceDetails",
        e));

    s << x;
  }

  // MeasurementTechniqueDetails
  //
  for (Metadata::MeasurementTechniqueDetails_const_iterator
       b (i.MeasurementTechniqueDetails ().begin ()), n (i.MeasurementTechniqueDetails ().end ());
       b != n; ++b)
  {
    const Metadata::MeasurementTechniqueDetails_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MeasurementTechniqueDetails",
        e));

    s << x;
  }

  // ParameterDetails
  //
  for (Metadata::ParameterDetails_const_iterator
       b (i.ParameterDetails ().begin ()), n (i.ParameterDetails ().end ());
       b != n; ++b)
  {
    const Metadata::ParameterDetails_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ParameterDetails",
        e));

    s << x;
  }

  // PropertyDetails
  //
  for (Metadata::PropertyDetails_const_iterator
       b (i.PropertyDetails ().begin ()), n (i.PropertyDetails ().end ());
       b != n; ++b)
  {
    const Metadata::PropertyDetails_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "PropertyDetails",
        e));

    s << x;
  }

  // SourceDetails
  //
  for (Metadata::SourceDetails_const_iterator
       b (i.SourceDetails ().begin ()), n (i.SourceDetails ().end ());
       b != n; ++b)
  {
    const Metadata::SourceDetails_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SourceDetails",
        e));

    s << x;
  }

  // SpecimenDetails
  //
  for (Metadata::SpecimenDetails_const_iterator
       b (i.SpecimenDetails ().begin ()), n (i.SpecimenDetails ().end ());
       b != n; ++b)
  {
    const Metadata::SpecimenDetails_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SpecimenDetails",
        e));

    s << x;
  }

  // TestConditionDetails
  //
  for (Metadata::TestConditionDetails_const_iterator
       b (i.TestConditionDetails ().begin ()), n (i.TestConditionDetails ().end ());
       b != n; ++b)
  {
    const Metadata::TestConditionDetails_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TestConditionDetails",
        e));

    s << x;
  }
}

void
operator<< (::xercesc::DOMElement& e, const Name& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // authority
  //
  if (i.authority ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "authority",
        e));

    a << *i.authority ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Notes& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const Notes& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const Notes& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const ParameterValue& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Data
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Data",
        e));

    s << i.Data ();
  }

  // Uncertainty
  //
  for (ParameterValue::Uncertainty_const_iterator
       b (i.Uncertainty ().begin ()), n (i.Uncertainty ().end ());
       b != n; ++b)
  {
    const ParameterValue::Uncertainty_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Uncertainty",
        e));

    s << x;
  }

  // Qualifier
  //
  for (ParameterValue::Qualifier_const_iterator
       b (i.Qualifier ().begin ()), n (i.Qualifier ().end ());
       b != n; ++b)
  {
    const ParameterValue::Qualifier_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Qualifier",
        e));

    s << x;
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }

  // parameter
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "parameter",
        e));

    a << i.parameter ();
  }

  // format
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "format",
        e));

    a << i.format ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const PhaseComposition& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Name",
        e));

    s << i.Name ();
  }

  // Concentration
  //
  if (i.Concentration ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Concentration",
        e));

    s << *i.Concentration ();
  }

  // PropertyData
  //
  for (PhaseComposition::PropertyData_const_iterator
       b (i.PropertyData ().begin ()), n (i.PropertyData ().end ());
       b != n; ++b)
  {
    const PhaseComposition::PropertyData_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "PropertyData",
        e));

    s << x;
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ProcessingDetails& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Name",
        e));

    s << i.Name ();
  }

  // ParameterValue
  //
  for (ProcessingDetails::ParameterValue_const_iterator
       b (i.ParameterValue ().begin ()), n (i.ParameterValue ().end ());
       b != n; ++b)
  {
    const ProcessingDetails::ParameterValue_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ParameterValue",
        e));

    s << x;
  }

  // Result
  //
  if (i.Result ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Result",
        e));

    s << *i.Result ();
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const PropertyData& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Data
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Data",
        e));

    s << i.Data ();
  }

  // Uncertainty
  //
  for (PropertyData::Uncertainty_const_iterator
       b (i.Uncertainty ().begin ()), n (i.Uncertainty ().end ());
       b != n; ++b)
  {
    const PropertyData::Uncertainty_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Uncertainty",
        e));

    s << x;
  }

  // Qualifier
  //
  for (PropertyData::Qualifier_const_iterator
       b (i.Qualifier ().begin ()), n (i.Qualifier ().end ());
       b != n; ++b)
  {
    const PropertyData::Qualifier_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Qualifier",
        e));

    s << x;
  }

  // ParameterValue
  //
  for (PropertyData::ParameterValue_const_iterator
       b (i.ParameterValue ().begin ()), n (i.ParameterValue ().end ());
       b != n; ++b)
  {
    const PropertyData::ParameterValue_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ParameterValue",
        e));

    s << x;
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }

  // property
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "property",
        e));

    a << i.property ();
  }

  // technique
  //
  if (i.technique ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "technique",
        e));

    a << *i.technique ();
  }

  // source
  //
  if (i.source ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "source",
        e));

    a << *i.source ();
  }

  // specimen
  //
  if (i.specimen ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "specimen",
        e));

    a << *i.specimen ();
  }

  // test
  //
  if (i.test ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "test",
        e));

    a << *i.test ();
  }

  // delimiter
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "delimiter",
        e));

    a << i.delimiter ();
  }

  // quote
  //
  if (i.quote ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "quote",
        e));

    a << *i.quote ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Qualifier& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const Qualifier& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const Qualifier& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const Relationship& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const Relationship& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const Relationship& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const Source& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // source
  //
  if (i.source ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "source",
        e));

    a << *i.source ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Specification& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // authority
  //
  if (i.authority ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "authority",
        e));

    a << *i.authority ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Uncertainty& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Value
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Value",
        e));

    s << i.Value ();
  }

  // Units
  //
  if (i.Units ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Units",
        e));

    s << *i.Units ();
  }

  // Unitless
  //
  if (i.Unitless ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Unitless",
        e));

    s << *i.Unitless ();
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }

  // Scale
  //
  if (i.Scale ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Scale",
        e));

    s << *i.Scale ();
  }

  // DistributionType
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "DistributionType",
        e));

    a << i.DistributionType ();
  }

  // Num_Std_Dev
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Num_Std_Dev",
        e));

    a << i.Num_Std_Dev ();
  }

  // Percentile
  //
  if (i.Percentile ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Percentile",
        e));

    a << *i.Percentile ();
  }

  // ConfidenceLevel
  //
  if (i.ConfidenceLevel ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ConfidenceLevel",
        e));

    a << *i.ConfidenceLevel ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Unit& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  if (i.Name ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Name",
        e));

    s << *i.Name ();
  }

  // Currency
  //
  if (i.Currency ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Currency",
        e));

    s << *i.Currency ();
  }

  // power
  //
  if (i.power ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "power",
        e));

    a << ::xml_schema::as_decimal(*i.power ());
  }

  // description
  //
  if (i.description ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "description",
        e));

    a << *i.description ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Unitless& i)
{
  e << static_cast< const ::xml_schema::type& > (i);
}

void
operator<< (::xercesc::DOMAttr&, const Unitless&)
{
}

void
operator<< (::xml_schema::list_stream&,
            const Unitless&)
{
}

void
operator<< (::xercesc::DOMElement& e, const Units& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Unit
  //
  for (Units::Unit_const_iterator
       b (i.Unit ().begin ()), n (i.Unit ().end ());
       b != n; ++b)
  {
    const Units::Unit_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Unit",
        e));

    s << x;
  }

  // system
  //
  if (i.system ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "system",
        e));

    a << *i.system ();
  }

  // factor
  //
  if (i.factor ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "factor",
        e));

    a << *i.factor ();
  }

  // name
  //
  if (i.name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << *i.name ();
  }

  // description
  //
  if (i.description ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "description",
        e));

    a << *i.description ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Value& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // format
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "format",
        e));

    a << i.format ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const AuthorityDetails& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Name",
        e));

    s << i.Name ();
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const DataSourceDetails& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Name",
        e));

    s << i.Name ();
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // type
  //
  if (i.type ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << *i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const MeasurementTechniqueDetails& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Name",
        e));

    s << i.Name ();
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ParameterDetails& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Name",
        e));

    s << i.Name ();
  }

  // Units
  //
  if (i.Units ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Units",
        e));

    s << *i.Units ();
  }

  // Unitless
  //
  if (i.Unitless ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Unitless",
        e));

    s << *i.Unitless ();
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const PropertyDetails& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Name",
        e));

    s << i.Name ();
  }

  // Units
  //
  if (i.Units ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Units",
        e));

    s << *i.Units ();
  }

  // Unitless
  //
  if (i.Unitless ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Unitless",
        e));

    s << *i.Unitless ();
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // type
  //
  if (i.type ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << *i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const SourceDetails& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Name",
        e));

    s << i.Name ();
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // type
  //
  if (i.type ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << *i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const SpecimenDetails& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  if (i.Name ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Name",
        e));

    s << *i.Name ();
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }

  // Geometry
  //
  if (i.Geometry ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Geometry",
        e));

    s << *i.Geometry ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // type
  //
  if (i.type ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << *i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const TestConditionDetails& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // ParameterValue
  //
  for (TestConditionDetails::ParameterValue_const_iterator
       b (i.ParameterValue ().begin ()), n (i.ParameterValue ().end ());
       b != n; ++b)
  {
    const TestConditionDetails::ParameterValue_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ParameterValue",
        e));

    s << x;
  }

  // Notes
  //
  if (i.Notes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << *i.Notes ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ChemicalElementSymbol& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const ChemicalElementSymbol& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const ChemicalElementSymbol& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const CurrencyCode& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const CurrencyCode& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const CurrencyCode& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const MatML_Doc& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Material
  //
  for (MatML_Doc::Material_const_iterator
       b (i.Material ().begin ()), n (i.Material ().end ());
       b != n; ++b)
  {
    const MatML_Doc::Material_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Material",
        e));

    s << x;
  }

  // Metadata
  //
  if (i.Metadata ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Metadata",
        e));

    s << *i.Metadata ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ParentMaterial& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Symbol& i)
{
  e << static_cast< const ::ChemicalElementSymbol& > (i);

  // subscript
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "subscript",
        e));

    a << i.subscript ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Graph& i)
{
  e << static_cast< const ::xml_schema::type& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const Data& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // format
  //
  if (i.format ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "format",
        e));

    a << *i.format ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Data1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // format
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "format",
        e));

    a << i.format ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const delimiter& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const delimiter& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const delimiter& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const Scale& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const Scale& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const Scale& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

